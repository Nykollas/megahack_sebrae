{"ast":null,"code":"'use strict';\n\nvar RTCSessionDescription = require('@twilio/webrtc').RTCSessionDescription;\n\nvar createPtToCodecName = require('./').createPtToCodecName;\n\nvar getMediaSections = require('./').getMediaSections;\n/**\n * An RTX payload type\n * @typedef {PT} RtxPT\n */\n\n/**\n * A non-RTX payload type\n * @typedef {PT} NonRtxPT\n */\n\n/**\n * A Set with at least one element\n * @typedef {Set} NonEmptySet\n */\n\n/**\n * Apply the workaround for Issue 8329 to an RTCSessionDescriptionInit.\n * @param {RTCSessionDescriptionInit} description\n * @returns {RTCSessionDescription} newDescription\n */\n\n\nfunction workaround(description) {\n  var descriptionInit = {\n    type: description.type\n  };\n\n  if (description.type !== 'rollback') {\n    descriptionInit.sdp = sdpWorkaround(description.sdp);\n  }\n\n  return new RTCSessionDescription(descriptionInit);\n}\n/**\n * @param {string} sdp\n * @returns {string} newSdp\n */\n\n\nfunction sdpWorkaround(sdp) {\n  var mediaSections = getMediaSections(sdp);\n  var session = sdp.split('\\r\\nm=')[0];\n  return [session].concat(mediaSections.map(mediaSectionWorkaround)).join('\\r\\n');\n}\n/**\n * @param {string} mediaSection\n * @returns {string} newMediaSection\n */\n\n\nfunction mediaSectionWorkaround(mediaSection) {\n  var ptToCodecName = createPtToCodecName(mediaSection);\n  mediaSection = deleteDuplicateRtxPts(mediaSection, ptToCodecName);\n  var codecNameToPts = createCodecNameToPts(ptToCodecName);\n  var rtxPts = codecNameToPts.get('rtx') || new Set();\n  var invalidRtxPts = new Set();\n  var rtxPtToAssociatedPt = createRtxPtToAssociatedPt(mediaSection, ptToCodecName, rtxPts, invalidRtxPts);\n  var associatedPtToRtxPt = createAssociatedPtToRtxPt(rtxPtToAssociatedPt, invalidRtxPts);\n  var unassociatedRtxPts = Array.from(invalidRtxPts); // NOTE(mroberts): We normalize to lowercase.\n\n  var knownCodecNames = ['h264', 'vp8', 'vp9'];\n  var unassociatedPts = knownCodecNames.reduce(function (unassociatedPts, codecName) {\n    var pts = codecNameToPts.get(codecName) || new Set();\n    return Array.from(pts).reduce(function (unassociatedPts, pt) {\n      return associatedPtToRtxPt.has(pt) ? unassociatedPts : unassociatedPts.add(pt);\n    }, unassociatedPts);\n  }, new Set());\n  unassociatedPts.forEach(function (pt) {\n    if (unassociatedRtxPts.length) {\n      var rtxPt = unassociatedRtxPts.shift();\n      mediaSection = deleteFmtpAttributesForRtxPt(mediaSection, rtxPt);\n      mediaSection = addFmtpAttributeForRtxPt(mediaSection, rtxPt, pt);\n    }\n  });\n  unassociatedRtxPts.forEach(function (rtxPt) {\n    mediaSection = deleteFmtpAttributesForRtxPt(mediaSection, rtxPt);\n    mediaSection = deleteRtpmapAttributesForRtxPt(mediaSection, rtxPt);\n  });\n  return mediaSection;\n}\n/**\n * @param {string} mediaSection\n * @param {Map<PT, Codec>} ptToCodecName\n * @returns {string} newMediaSection\n */\n\n\nfunction deleteDuplicateRtxPts(mediaSection, ptToCodecName) {\n  // NOTE(syerrapragada): In some cases Chrome produces an offer/answer\n  // with duplicate \"rtx\" payload mapping in media section. When applied,\n  // Chrome rejects the SDP. We workaround this by deleting duplicate\n  // \"rtx\" mappings found in SDP.\n  return Array.from(ptToCodecName.keys()).reduce(function (section, pt) {\n    var rtpmapRegex = new RegExp('^a=rtpmap:' + pt + ' rtx.+$', 'gm');\n    return (section.match(rtpmapRegex) || []).slice(ptToCodecName.get(pt) === 'rtx' ? 1 : 0).reduce(function (section, rtpmap) {\n      var rtpmapRegex = new RegExp('\\r\\n' + rtpmap);\n      var fmtpmapRegex = new RegExp('\\r\\na=fmtp:' + pt + ' apt=[0-9]+');\n      return section.replace(rtpmapRegex, '').replace(fmtpmapRegex, '');\n    }, section);\n  }, mediaSection);\n}\n/**\n * @param {Map<PT, Codec>} ptToCodecName\n * @returns {Map<string, NonEmptySet<PT>>} codecNameToPts\n */\n\n\nfunction createCodecNameToPts(ptToCodecName) {\n  var codecNameToPts = new Map();\n  ptToCodecName.forEach(function (codecName, pt) {\n    var pts = codecNameToPts.get(codecName) || new Set();\n    return codecNameToPts.set(codecName, pts.add(pt));\n  });\n  return codecNameToPts;\n}\n/**\n * @param {string} mediaSection\n * @param {Map<PT, Codec>} ptToCodecName\n * @param {Set<RtxPT>} rtxPts\n * @param {Set<RtxPT>} invalidRtxPts\n * @returns {Map<RtxPT, NonRtxPT>} rtxPtToAssociatedPt\n */\n\n\nfunction createRtxPtToAssociatedPt(mediaSection, ptToCodecName, rtxPts, invalidRtxPts) {\n  return Array.from(rtxPts).reduce(function (rtxPtToAssociatedPt, rtxPt) {\n    var fmtpPattern = new RegExp('a=fmtp:' + rtxPt + ' apt=(\\\\d+)');\n    var matches = mediaSection.match(fmtpPattern);\n\n    if (!matches) {\n      invalidRtxPts.add(rtxPt);\n      return rtxPtToAssociatedPt;\n    }\n\n    var pt = Number.parseInt(matches[1]);\n\n    if (!ptToCodecName.has(pt)) {\n      // This is Issue 8329.\n      invalidRtxPts.add(rtxPt);\n      return rtxPtToAssociatedPt;\n    }\n\n    var codecName = ptToCodecName.get(pt);\n\n    if (codecName === 'rtx') {\n      // Strange\n      invalidRtxPts.add(rtxPt);\n      return rtxPtToAssociatedPt;\n    }\n\n    return rtxPtToAssociatedPt.set(rtxPt, pt);\n  }, new Map());\n}\n/**\n * @param {string} mediaSection\n * @param {Map<RtxPT, NonRtxPT>} rtxPtToAssociatedPt\n * @param {Set<RtxPT>} invalidRtxPts\n * @returns {Map<NonRtxPT, RtxPT>} associatedPtToRtxPt\n */\n\n\nfunction createAssociatedPtToRtxPt(rtxPtToAssociatedPt, invalidRtxPts) {\n  // First, we construct a Map<NonRtxPT, NonEmptySet<RtxPT>>.\n  var associatedPtToRtxPts = Array.from(rtxPtToAssociatedPt).reduce(function (associatedPtToRtxPts, pair) {\n    var rtxPt = pair[0];\n    var pt = pair[1];\n    var rtxPts = associatedPtToRtxPts.get(pt) || new Set();\n    return associatedPtToRtxPts.set(pt, rtxPts.add(rtxPt));\n  }, new Map()); // Then, we filter down to a Map<NonRtxPT, RtxPt>. Any RtxPTs that map to the\n  // same NonRtxPT are removed and added to invalidRtxPts.\n\n  return Array.from(associatedPtToRtxPts).reduce(function (associatedPtToRtxPt, pair) {\n    var pt = pair[0];\n    var rtxPts = Array.from(pair[1]);\n\n    if (rtxPts.length > 1) {\n      rtxPts.forEach(function (rtxPt) {\n        invalidRtxPts.add(rtxPt);\n      });\n      return associatedPtToRtxPt;\n    }\n\n    return associatedPtToRtxPt.set(pt, rtxPts[0]);\n  }, new Map());\n}\n/**\n * @param {string} mediaSection\n * @param {RtxPT} rtxPt\n * @returns {string} newMediaSection\n */\n\n\nfunction deleteFmtpAttributesForRtxPt(mediaSection, rtxPt) {\n  var pattern = new RegExp('a=fmtp:' + rtxPt + '.*\\r\\n', 'gm');\n  return mediaSection.replace(pattern, '');\n}\n/**\n * @param {string} mediaSection\n * @param {RtxPT} rtxPt\n * @returns {string} newMediaSection\n */\n\n\nfunction deleteRtpmapAttributesForRtxPt(mediaSection, rtxPt) {\n  var pattern = new RegExp('a=rtpmap:' + rtxPt + '.*\\r\\n', 'gm');\n  return mediaSection.replace(pattern, '');\n}\n/**\n * @param {string} mediaSection\n * @param {RtxPT} rtxPt\n * @param {NonRtxPT} pt\n * @returns {string} newMediaSection\n */\n\n\nfunction addFmtpAttributeForRtxPt(mediaSection, rtxPt, pt) {\n  return mediaSection.endsWith('\\r\\n') ? mediaSection + 'a=fmtp:' + rtxPt + ' apt=' + pt + '\\r\\n' : mediaSection + '\\r\\na=fmtp:' + rtxPt + ' apt=' + pt;\n}\n\nmodule.exports = workaround;","map":{"version":3,"sources":["/home/ascencion/sebrae_megahack/node_modules/twilio-video/es5/util/sdp/issue8329.js"],"names":["RTCSessionDescription","require","createPtToCodecName","getMediaSections","workaround","description","descriptionInit","type","sdp","sdpWorkaround","mediaSections","session","split","concat","map","mediaSectionWorkaround","join","mediaSection","ptToCodecName","deleteDuplicateRtxPts","codecNameToPts","createCodecNameToPts","rtxPts","get","Set","invalidRtxPts","rtxPtToAssociatedPt","createRtxPtToAssociatedPt","associatedPtToRtxPt","createAssociatedPtToRtxPt","unassociatedRtxPts","Array","from","knownCodecNames","unassociatedPts","reduce","codecName","pts","pt","has","add","forEach","length","rtxPt","shift","deleteFmtpAttributesForRtxPt","addFmtpAttributeForRtxPt","deleteRtpmapAttributesForRtxPt","keys","section","rtpmapRegex","RegExp","match","slice","rtpmap","fmtpmapRegex","replace","Map","set","fmtpPattern","matches","Number","parseInt","associatedPtToRtxPts","pair","pattern","endsWith","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nvar RTCSessionDescription = require('@twilio/webrtc').RTCSessionDescription;\n\nvar createPtToCodecName = require('./').createPtToCodecName;\nvar getMediaSections = require('./').getMediaSections;\n\n/**\n * An RTX payload type\n * @typedef {PT} RtxPT\n */\n\n/**\n * A non-RTX payload type\n * @typedef {PT} NonRtxPT\n */\n\n/**\n * A Set with at least one element\n * @typedef {Set} NonEmptySet\n */\n\n/**\n * Apply the workaround for Issue 8329 to an RTCSessionDescriptionInit.\n * @param {RTCSessionDescriptionInit} description\n * @returns {RTCSessionDescription} newDescription\n */\nfunction workaround(description) {\n  var descriptionInit = { type: description.type };\n  if (description.type !== 'rollback') {\n    descriptionInit.sdp = sdpWorkaround(description.sdp);\n  }\n  return new RTCSessionDescription(descriptionInit);\n}\n\n/**\n * @param {string} sdp\n * @returns {string} newSdp\n */\nfunction sdpWorkaround(sdp) {\n  var mediaSections = getMediaSections(sdp);\n  var session = sdp.split('\\r\\nm=')[0];\n  return [session].concat(mediaSections.map(mediaSectionWorkaround)).join('\\r\\n');\n}\n\n/**\n * @param {string} mediaSection\n * @returns {string} newMediaSection\n */\nfunction mediaSectionWorkaround(mediaSection) {\n  var ptToCodecName = createPtToCodecName(mediaSection);\n  mediaSection = deleteDuplicateRtxPts(mediaSection, ptToCodecName);\n  var codecNameToPts = createCodecNameToPts(ptToCodecName);\n  var rtxPts = codecNameToPts.get('rtx') || new Set();\n\n  var invalidRtxPts = new Set();\n  var rtxPtToAssociatedPt = createRtxPtToAssociatedPt(mediaSection, ptToCodecName, rtxPts, invalidRtxPts);\n  var associatedPtToRtxPt = createAssociatedPtToRtxPt(rtxPtToAssociatedPt, invalidRtxPts);\n\n  var unassociatedRtxPts = Array.from(invalidRtxPts);\n\n  // NOTE(mroberts): We normalize to lowercase.\n  var knownCodecNames = ['h264', 'vp8', 'vp9'];\n  var unassociatedPts = knownCodecNames.reduce(function (unassociatedPts, codecName) {\n    var pts = codecNameToPts.get(codecName) || new Set();\n    return Array.from(pts).reduce(function (unassociatedPts, pt) {\n      return associatedPtToRtxPt.has(pt) ? unassociatedPts : unassociatedPts.add(pt);\n    }, unassociatedPts);\n  }, new Set());\n\n  unassociatedPts.forEach(function (pt) {\n    if (unassociatedRtxPts.length) {\n      var rtxPt = unassociatedRtxPts.shift();\n      mediaSection = deleteFmtpAttributesForRtxPt(mediaSection, rtxPt);\n      mediaSection = addFmtpAttributeForRtxPt(mediaSection, rtxPt, pt);\n    }\n  });\n\n  unassociatedRtxPts.forEach(function (rtxPt) {\n    mediaSection = deleteFmtpAttributesForRtxPt(mediaSection, rtxPt);\n    mediaSection = deleteRtpmapAttributesForRtxPt(mediaSection, rtxPt);\n  });\n\n  return mediaSection;\n}\n\n/**\n * @param {string} mediaSection\n * @param {Map<PT, Codec>} ptToCodecName\n * @returns {string} newMediaSection\n */\nfunction deleteDuplicateRtxPts(mediaSection, ptToCodecName) {\n  // NOTE(syerrapragada): In some cases Chrome produces an offer/answer\n  // with duplicate \"rtx\" payload mapping in media section. When applied,\n  // Chrome rejects the SDP. We workaround this by deleting duplicate\n  // \"rtx\" mappings found in SDP.\n  return Array.from(ptToCodecName.keys()).reduce(function (section, pt) {\n    var rtpmapRegex = new RegExp('^a=rtpmap:' + pt + ' rtx.+$', 'gm');\n    return (section.match(rtpmapRegex) || []).slice(ptToCodecName.get(pt) === 'rtx' ? 1 : 0).reduce(function (section, rtpmap) {\n      var rtpmapRegex = new RegExp('\\r\\n' + rtpmap);\n      var fmtpmapRegex = new RegExp('\\r\\na=fmtp:' + pt + ' apt=[0-9]+');\n      return section.replace(rtpmapRegex, '').replace(fmtpmapRegex, '');\n    }, section);\n  }, mediaSection);\n}\n\n/**\n * @param {Map<PT, Codec>} ptToCodecName\n * @returns {Map<string, NonEmptySet<PT>>} codecNameToPts\n */\nfunction createCodecNameToPts(ptToCodecName) {\n  var codecNameToPts = new Map();\n  ptToCodecName.forEach(function (codecName, pt) {\n    var pts = codecNameToPts.get(codecName) || new Set();\n    return codecNameToPts.set(codecName, pts.add(pt));\n  });\n  return codecNameToPts;\n}\n\n/**\n * @param {string} mediaSection\n * @param {Map<PT, Codec>} ptToCodecName\n * @param {Set<RtxPT>} rtxPts\n * @param {Set<RtxPT>} invalidRtxPts\n * @returns {Map<RtxPT, NonRtxPT>} rtxPtToAssociatedPt\n */\nfunction createRtxPtToAssociatedPt(mediaSection, ptToCodecName, rtxPts, invalidRtxPts) {\n  return Array.from(rtxPts).reduce(function (rtxPtToAssociatedPt, rtxPt) {\n    var fmtpPattern = new RegExp('a=fmtp:' + rtxPt + ' apt=(\\\\d+)');\n    var matches = mediaSection.match(fmtpPattern);\n    if (!matches) {\n      invalidRtxPts.add(rtxPt);\n      return rtxPtToAssociatedPt;\n    }\n\n    var pt = Number.parseInt(matches[1]);\n    if (!ptToCodecName.has(pt)) {\n      // This is Issue 8329.\n      invalidRtxPts.add(rtxPt);\n      return rtxPtToAssociatedPt;\n    }\n\n    var codecName = ptToCodecName.get(pt);\n    if (codecName === 'rtx') {\n      // Strange\n      invalidRtxPts.add(rtxPt);\n      return rtxPtToAssociatedPt;\n    }\n\n    return rtxPtToAssociatedPt.set(rtxPt, pt);\n  }, new Map());\n}\n\n/**\n * @param {string} mediaSection\n * @param {Map<RtxPT, NonRtxPT>} rtxPtToAssociatedPt\n * @param {Set<RtxPT>} invalidRtxPts\n * @returns {Map<NonRtxPT, RtxPT>} associatedPtToRtxPt\n */\nfunction createAssociatedPtToRtxPt(rtxPtToAssociatedPt, invalidRtxPts) {\n  // First, we construct a Map<NonRtxPT, NonEmptySet<RtxPT>>.\n  var associatedPtToRtxPts = Array.from(rtxPtToAssociatedPt).reduce(function (associatedPtToRtxPts, pair) {\n    var rtxPt = pair[0];\n    var pt = pair[1];\n    var rtxPts = associatedPtToRtxPts.get(pt) || new Set();\n    return associatedPtToRtxPts.set(pt, rtxPts.add(rtxPt));\n  }, new Map());\n\n  // Then, we filter down to a Map<NonRtxPT, RtxPt>. Any RtxPTs that map to the\n  // same NonRtxPT are removed and added to invalidRtxPts.\n  return Array.from(associatedPtToRtxPts).reduce(function (associatedPtToRtxPt, pair) {\n    var pt = pair[0];\n    var rtxPts = Array.from(pair[1]);\n    if (rtxPts.length > 1) {\n      rtxPts.forEach(function (rtxPt) {\n        invalidRtxPts.add(rtxPt);\n      });\n      return associatedPtToRtxPt;\n    }\n    return associatedPtToRtxPt.set(pt, rtxPts[0]);\n  }, new Map());\n}\n\n/**\n * @param {string} mediaSection\n * @param {RtxPT} rtxPt\n * @returns {string} newMediaSection\n */\nfunction deleteFmtpAttributesForRtxPt(mediaSection, rtxPt) {\n  var pattern = new RegExp('a=fmtp:' + rtxPt + '.*\\r\\n', 'gm');\n  return mediaSection.replace(pattern, '');\n}\n\n/**\n * @param {string} mediaSection\n * @param {RtxPT} rtxPt\n * @returns {string} newMediaSection\n */\nfunction deleteRtpmapAttributesForRtxPt(mediaSection, rtxPt) {\n  var pattern = new RegExp('a=rtpmap:' + rtxPt + '.*\\r\\n', 'gm');\n  return mediaSection.replace(pattern, '');\n}\n\n/**\n * @param {string} mediaSection\n * @param {RtxPT} rtxPt\n * @param {NonRtxPT} pt\n * @returns {string} newMediaSection\n */\nfunction addFmtpAttributeForRtxPt(mediaSection, rtxPt, pt) {\n  return mediaSection.endsWith('\\r\\n') ? mediaSection + 'a=fmtp:' + rtxPt + ' apt=' + pt + '\\r\\n' : mediaSection + '\\r\\na=fmtp:' + rtxPt + ' apt=' + pt;\n}\n\nmodule.exports = workaround;"]},"metadata":{},"sourceType":"script"}