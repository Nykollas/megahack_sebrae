{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\nUnescape token part of a JSON Pointer string\n\n`token` should *not* contain any '/' characters.\n\n> Evaluation of each reference token begins by decoding any escaped\n> character sequence.  This is performed by first transforming any\n> occurrence of the sequence '~1' to '/', and then transforming any\n> occurrence of the sequence '~0' to '~'.  By performing the\n> substitutions in this order, an implementation avoids the error of\n> turning '~01' first into '~1' and then into '/', which would be\n> incorrect (the string '~01' correctly becomes '~1' after\n> transformation).\n\nHere's my take:\n\n~1 is unescaped with higher priority than ~0 because it is a lower-order escape character.\nI say \"lower order\" because '/' needs escaping due to the JSON Pointer serialization technique.\nWhereas, '~' is escaped because escaping '/' uses the '~' character.\n*/\n\nfunction unescape(token) {\n  return token.replace(/~1/g, '/').replace(/~0/g, '~');\n}\n/** Escape token part of a JSON Pointer string\n\n> '~' needs to be encoded as '~0' and '/'\n> needs to be encoded as '~1' when these characters appear in a\n> reference token.\n\nThis is the exact inverse of `unescape()`, so the reverse replacements must take place in reverse order.\n*/\n\n\nfunction escape(token) {\n  return token.replace(/~/g, '~0').replace(/\\//g, '~1');\n}\n/**\nJSON Pointer representation\n*/\n\n\nvar Pointer =\n/** @class */\nfunction () {\n  function Pointer(tokens) {\n    if (tokens === void 0) {\n      tokens = [''];\n    }\n\n    this.tokens = tokens;\n  }\n  /**\n  `path` *must* be a properly escaped string.\n  */\n\n\n  Pointer.fromJSON = function (path) {\n    var tokens = path.split('/').map(unescape);\n    if (tokens[0] !== '') throw new Error(\"Invalid JSON Pointer: \" + path);\n    return new Pointer(tokens);\n  };\n\n  Pointer.prototype.toString = function () {\n    return this.tokens.map(escape).join('/');\n  };\n  /**\n  Returns an object with 'parent', 'key', and 'value' properties.\n  In the special case that this Pointer's path == \"\",\n  this object will be {parent: null, key: '', value: object}.\n  Otherwise, parent and key will have the property such that parent[key] == value.\n  */\n\n\n  Pointer.prototype.evaluate = function (object) {\n    var parent = null;\n    var key = '';\n    var value = object;\n\n    for (var i = 1, l = this.tokens.length; i < l; i++) {\n      parent = value;\n      key = this.tokens[i]; // not sure if this the best way to handle non-existant paths...\n\n      value = (parent || {})[key];\n    }\n\n    return {\n      parent: parent,\n      key: key,\n      value: value\n    };\n  };\n\n  Pointer.prototype.get = function (object) {\n    return this.evaluate(object).value;\n  };\n\n  Pointer.prototype.set = function (object, value) {\n    var cursor = object;\n\n    for (var i = 1, l = this.tokens.length - 1, token = this.tokens[i]; i < l; i++) {\n      // not sure if this the best way to handle non-existant paths...\n      cursor = (cursor || {})[token];\n    }\n\n    if (cursor) {\n      cursor[this.tokens[this.tokens.length - 1]] = value;\n    }\n  };\n\n  Pointer.prototype.push = function (token) {\n    // mutable\n    this.tokens.push(token);\n  };\n  /**\n  `token` should be a String. It'll be coerced to one anyway.\n     immutable (shallowly)\n  */\n\n\n  Pointer.prototype.add = function (token) {\n    var tokens = this.tokens.concat(String(token));\n    return new Pointer(tokens);\n  };\n\n  return Pointer;\n}();\n\nexports.Pointer = Pointer;","map":{"version":3,"sources":["/home/ascencion/sebrae_megahack/node_modules/rfc6902/pointer.js"],"names":["Object","defineProperty","exports","value","unescape","token","replace","escape","Pointer","tokens","fromJSON","path","split","map","Error","prototype","toString","join","evaluate","object","parent","key","i","l","length","get","set","cursor","push","add","concat","String"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\nUnescape token part of a JSON Pointer string\n\n`token` should *not* contain any '/' characters.\n\n> Evaluation of each reference token begins by decoding any escaped\n> character sequence.  This is performed by first transforming any\n> occurrence of the sequence '~1' to '/', and then transforming any\n> occurrence of the sequence '~0' to '~'.  By performing the\n> substitutions in this order, an implementation avoids the error of\n> turning '~01' first into '~1' and then into '/', which would be\n> incorrect (the string '~01' correctly becomes '~1' after\n> transformation).\n\nHere's my take:\n\n~1 is unescaped with higher priority than ~0 because it is a lower-order escape character.\nI say \"lower order\" because '/' needs escaping due to the JSON Pointer serialization technique.\nWhereas, '~' is escaped because escaping '/' uses the '~' character.\n*/\nfunction unescape(token) {\n    return token.replace(/~1/g, '/').replace(/~0/g, '~');\n}\n/** Escape token part of a JSON Pointer string\n\n> '~' needs to be encoded as '~0' and '/'\n> needs to be encoded as '~1' when these characters appear in a\n> reference token.\n\nThis is the exact inverse of `unescape()`, so the reverse replacements must take place in reverse order.\n*/\nfunction escape(token) {\n    return token.replace(/~/g, '~0').replace(/\\//g, '~1');\n}\n/**\nJSON Pointer representation\n*/\nvar Pointer = /** @class */ (function () {\n    function Pointer(tokens) {\n        if (tokens === void 0) { tokens = ['']; }\n        this.tokens = tokens;\n    }\n    /**\n    `path` *must* be a properly escaped string.\n    */\n    Pointer.fromJSON = function (path) {\n        var tokens = path.split('/').map(unescape);\n        if (tokens[0] !== '')\n            throw new Error(\"Invalid JSON Pointer: \" + path);\n        return new Pointer(tokens);\n    };\n    Pointer.prototype.toString = function () {\n        return this.tokens.map(escape).join('/');\n    };\n    /**\n    Returns an object with 'parent', 'key', and 'value' properties.\n    In the special case that this Pointer's path == \"\",\n    this object will be {parent: null, key: '', value: object}.\n    Otherwise, parent and key will have the property such that parent[key] == value.\n    */\n    Pointer.prototype.evaluate = function (object) {\n        var parent = null;\n        var key = '';\n        var value = object;\n        for (var i = 1, l = this.tokens.length; i < l; i++) {\n            parent = value;\n            key = this.tokens[i];\n            // not sure if this the best way to handle non-existant paths...\n            value = (parent || {})[key];\n        }\n        return { parent: parent, key: key, value: value };\n    };\n    Pointer.prototype.get = function (object) {\n        return this.evaluate(object).value;\n    };\n    Pointer.prototype.set = function (object, value) {\n        var cursor = object;\n        for (var i = 1, l = this.tokens.length - 1, token = this.tokens[i]; i < l; i++) {\n            // not sure if this the best way to handle non-existant paths...\n            cursor = (cursor || {})[token];\n        }\n        if (cursor) {\n            cursor[this.tokens[this.tokens.length - 1]] = value;\n        }\n    };\n    Pointer.prototype.push = function (token) {\n        // mutable\n        this.tokens.push(token);\n    };\n    /**\n    `token` should be a String. It'll be coerced to one anyway.\n  \n    immutable (shallowly)\n    */\n    Pointer.prototype.add = function (token) {\n        var tokens = this.tokens.concat(String(token));\n        return new Pointer(tokens);\n    };\n    return Pointer;\n}());\nexports.Pointer = Pointer;\n"]},"metadata":{},"sourceType":"script"}