{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst events_1 = require(\"events\");\n\nconst twilsock_1 = require(\"twilsock\");\n\nconst configuration_1 = require(\"./configuration\");\n\nconst registrar_1 = require(\"./registrar\");\n\nconst logger_1 = require(\"./logger\");\n/**\n * @class\n * @alias Notifications\n * @classdesc The helper library for the notification service.\n * Provides high level api for creating and managing notification subscriptions and receiving messages\n * Creates the instance of Notification helper library\n *\n * @constructor\n * @param {string} token - Twilio access token\n * @param {Notifications#ClientOptions} options - Options to customize client behavior\n */\n\n\nclass Client extends events_1.EventEmitter {\n  constructor(token, options = {}) {\n    super();\n\n    if (!token || token.length === 0) {\n      throw new Error('Token is required for Notifications client');\n    }\n\n    options.logLevel = options.logLevel || 'error';\n    logger_1.log.setLevel(options.logLevel);\n    const minTokenRefreshInterval = options.minTokenRefreshInterval || 10000;\n    const productId = options.productId || 'notifications';\n    options.twilsockClient = options.twilsockClient || new twilsock_1.TwilsockClient(token, productId, options);\n    options.transport = options.transport || options.twilsockClient;\n    this.services = {\n      twilsock: options.twilsockClient,\n      transport: options.transport,\n      config: new configuration_1.Configuration(null, options)\n    };\n    this.registrar = new registrar_1.Registrar(productId, this.services.transport, this.services.twilsock, this.services.config);\n    this.reliableTransportState = {\n      overall: false,\n      transport: false,\n      registration: false,\n      lastEmitted: null\n    };\n\n    this._onTransportStateChange(this.services.twilsock.isConnected);\n\n    this.registrar.on('transportReady', state => {\n      this._onRegistrationStateChange(state ? 'registered' : '');\n    });\n    this.registrar.on('stateChanged', state => {\n      this._onRegistrationStateChange(state);\n    });\n    this.registrar.on('needReliableTransport', this._onNeedReliableTransport.bind(this));\n    this.services.twilsock.on('message', (type, message) => this._routeMessage(type, message));\n    this.services.twilsock.on('connected', notificationId => {\n      this._onTransportStateChange(true);\n\n      this.registrar.setNotificationId('twilsock', notificationId);\n    });\n    this.services.twilsock.on('disconnected', () => {\n      this._onTransportStateChange(false);\n    });\n    this.services.config.updateToken(token);\n    this.registrar.updateToken(token);\n  }\n\n  get connectionState() {\n    if (this.services.twilsock.state === 'disconnected') {\n      return 'disconnected';\n    } else if (this.services.twilsock.state === 'disconnecting') {\n      return 'disconnecting';\n    } else if (this.services.twilsock.state === 'connected' && this.reliableTransportState.registration) {\n      return 'connected';\n    } else if (this.services.twilsock.state === 'rejected') {\n      return 'denied';\n    }\n\n    return 'connecting';\n  }\n  /**\n   * Routes messages to the external subscribers\n   * @private\n   */\n\n\n  _routeMessage(type, message) {\n    logger_1.log.trace('Message arrived: ', type, message);\n    this.emit('message', type, message);\n  }\n\n  _onNeedReliableTransport(isNeeded) {\n    if (isNeeded) {\n      this.services.twilsock.connect();\n    } else {\n      this.services.twilsock.disconnect();\n    }\n  }\n\n  _onRegistrationStateChange(state) {\n    this.reliableTransportState.registration = state === 'registered';\n\n    this._updateTransportState();\n  }\n\n  _onTransportStateChange(connected) {\n    this.reliableTransportState.transport = connected;\n\n    this._updateTransportState();\n  }\n\n  _updateTransportState() {\n    const overallState = this.reliableTransportState.transport && this.reliableTransportState.registration;\n\n    if (this.reliableTransportState.overall !== overallState) {\n      this.reliableTransportState.overall = overallState;\n      logger_1.log.info('Transport ready:', overallState);\n      this.emit('transportReady', overallState);\n    }\n\n    if (this.reliableTransportState.lastEmitted !== this.connectionState) {\n      this.reliableTransportState.lastEmitted = this.connectionState;\n      this.emit('connectionStateChanged', this.connectionState);\n    }\n  }\n  /**\n   * Adds the subscription for the given message type\n   * @param {string} messageType The type of message that you want to receive\n   * @param {string} channelType. Supported are 'twilsock', 'gcm' and 'fcm'\n   */\n\n\n  subscribe(messageType, channelType = 'twilsock') {\n    logger_1.log.trace('Add subscriptions for message type: ', messageType, channelType);\n    return this.registrar.subscribe(messageType, channelType);\n  }\n  /**\n   * Remove the subscription for the particular message type\n   * @param {string} messageType The type of message that you don't want to receive anymore\n   * @param {string} channelType. Supported are 'twilsock', 'gcm' and 'fcm'\n   */\n\n\n  unsubscribe(messageType, channelType = 'twilsock') {\n    logger_1.log.trace('Remove subscriptions for message type: ', messageType, channelType);\n    return this.registrar.unsubscribe(messageType, channelType);\n  }\n  /**\n   * Handle incoming push notification.\n   * Client application should call this method when it receives push notifications and pass the received data\n   * @param {Object} message push message\n   * @return {PushNotification}\n   */\n\n\n  handlePushNotification(message) {\n    return {\n      messageType: message.twi_message_type,\n      payload: message.payload\n    };\n  }\n  /**\n   * Set APN/GCM/FCM token to enable application register for a push messages\n   * @param {string} gcmToken/fcmToken Token received from GCM/FCM system\n   */\n\n\n  setPushRegistrationId(registrationId, channelType) {\n    logger_1.log.trace('Set push registration id', registrationId, channelType);\n    this.registrar.setNotificationId(channelType, registrationId);\n  }\n  /**\n   * Updates auth token for registration\n   * @param {string} token Authentication token for registrations\n   */\n\n\n  async updateToken(token) {\n    logger_1.log.info('authTokenUpdated');\n\n    if (this.services.config.token === token) {\n      return;\n    }\n\n    await this.services.twilsock.updateToken(token);\n    this.services.config.updateToken(token);\n    this.registrar.updateToken(token);\n  }\n\n}\n\nexports.Client = Client;\n/**\n * Fired when new message arrived.\n * @param {Object} message`\n * @event Client#message\n */\n\n/**\n * Fired when transport state has changed\n * @param {boolean} transport state\n * @event Client#transportReady\n */\n\n/**\n * Fired when transport state has been changed\n * @param {string} transport state\n * @event Client#connectionStateChanged\n */\n\n/**\n * These options can be passed to Client constructor\n * @typedef {Object} Notifications#ClientOptions\n * @property {String} [logLevel='error'] - The level of logging to enable. Valid options\n *   (from strictest to broadest): ['silent', 'error', 'warn', 'info', 'debug', 'trace']\n */","map":{"version":3,"sources":["/home/ascencion/sebrae_megahack/node_modules/twilio-notifications/lib/client.js"],"names":["Object","defineProperty","exports","value","events_1","require","twilsock_1","configuration_1","registrar_1","logger_1","Client","EventEmitter","constructor","token","options","length","Error","logLevel","log","setLevel","minTokenRefreshInterval","productId","twilsockClient","TwilsockClient","transport","services","twilsock","config","Configuration","registrar","Registrar","reliableTransportState","overall","registration","lastEmitted","_onTransportStateChange","isConnected","on","state","_onRegistrationStateChange","_onNeedReliableTransport","bind","type","message","_routeMessage","notificationId","setNotificationId","updateToken","connectionState","trace","emit","isNeeded","connect","disconnect","_updateTransportState","connected","overallState","info","subscribe","messageType","channelType","unsubscribe","handlePushNotification","twi_message_type","payload","setPushRegistrationId","registrationId"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst events_1 = require(\"events\");\nconst twilsock_1 = require(\"twilsock\");\nconst configuration_1 = require(\"./configuration\");\nconst registrar_1 = require(\"./registrar\");\nconst logger_1 = require(\"./logger\");\n/**\n * @class\n * @alias Notifications\n * @classdesc The helper library for the notification service.\n * Provides high level api for creating and managing notification subscriptions and receiving messages\n * Creates the instance of Notification helper library\n *\n * @constructor\n * @param {string} token - Twilio access token\n * @param {Notifications#ClientOptions} options - Options to customize client behavior\n */\nclass Client extends events_1.EventEmitter {\n    constructor(token, options = {}) {\n        super();\n        if (!token || token.length === 0) {\n            throw new Error('Token is required for Notifications client');\n        }\n        options.logLevel = options.logLevel || 'error';\n        logger_1.log.setLevel(options.logLevel);\n        const minTokenRefreshInterval = options.minTokenRefreshInterval || 10000;\n        const productId = options.productId || 'notifications';\n        options.twilsockClient = options.twilsockClient || new twilsock_1.TwilsockClient(token, productId, options);\n        options.transport = options.transport || options.twilsockClient;\n        this.services = {\n            twilsock: options.twilsockClient,\n            transport: options.transport,\n            config: new configuration_1.Configuration(null, options)\n        };\n        this.registrar = new registrar_1.Registrar(productId, this.services.transport, this.services.twilsock, this.services.config);\n        this.reliableTransportState = {\n            overall: false,\n            transport: false,\n            registration: false,\n            lastEmitted: null\n        };\n        this._onTransportStateChange(this.services.twilsock.isConnected);\n        this.registrar.on('transportReady', state => {\n            this._onRegistrationStateChange(state ? 'registered' : '');\n        });\n        this.registrar.on('stateChanged', (state) => {\n            this._onRegistrationStateChange(state);\n        });\n        this.registrar.on('needReliableTransport', this._onNeedReliableTransport.bind(this));\n        this.services.twilsock.on('message', (type, message) => this._routeMessage(type, message));\n        this.services.twilsock.on('connected', (notificationId) => {\n            this._onTransportStateChange(true);\n            this.registrar.setNotificationId('twilsock', notificationId);\n        });\n        this.services.twilsock.on('disconnected', () => {\n            this._onTransportStateChange(false);\n        });\n        this.services.config.updateToken(token);\n        this.registrar.updateToken(token);\n    }\n    get connectionState() {\n        if (this.services.twilsock.state === 'disconnected') {\n            return 'disconnected';\n        }\n        else if (this.services.twilsock.state === 'disconnecting') {\n            return 'disconnecting';\n        }\n        else if (this.services.twilsock.state === 'connected' && this.reliableTransportState.registration) {\n            return 'connected';\n        }\n        else if (this.services.twilsock.state === 'rejected') {\n            return 'denied';\n        }\n        return 'connecting';\n    }\n    /**\n     * Routes messages to the external subscribers\n     * @private\n     */\n    _routeMessage(type, message) {\n        logger_1.log.trace('Message arrived: ', type, message);\n        this.emit('message', type, message);\n    }\n    _onNeedReliableTransport(isNeeded) {\n        if (isNeeded) {\n            this.services.twilsock.connect();\n        }\n        else {\n            this.services.twilsock.disconnect();\n        }\n    }\n    _onRegistrationStateChange(state) {\n        this.reliableTransportState.registration = (state === 'registered');\n        this._updateTransportState();\n    }\n    _onTransportStateChange(connected) {\n        this.reliableTransportState.transport = connected;\n        this._updateTransportState();\n    }\n    _updateTransportState() {\n        const overallState = this.reliableTransportState.transport\n            && this.reliableTransportState.registration;\n        if (this.reliableTransportState.overall !== overallState) {\n            this.reliableTransportState.overall = overallState;\n            logger_1.log.info('Transport ready:', overallState);\n            this.emit('transportReady', overallState);\n        }\n        if (this.reliableTransportState.lastEmitted !== this.connectionState) {\n            this.reliableTransportState.lastEmitted = this.connectionState;\n            this.emit('connectionStateChanged', this.connectionState);\n        }\n    }\n    /**\n     * Adds the subscription for the given message type\n     * @param {string} messageType The type of message that you want to receive\n     * @param {string} channelType. Supported are 'twilsock', 'gcm' and 'fcm'\n     */\n    subscribe(messageType, channelType = 'twilsock') {\n        logger_1.log.trace('Add subscriptions for message type: ', messageType, channelType);\n        return this.registrar.subscribe(messageType, channelType);\n    }\n    /**\n     * Remove the subscription for the particular message type\n     * @param {string} messageType The type of message that you don't want to receive anymore\n     * @param {string} channelType. Supported are 'twilsock', 'gcm' and 'fcm'\n     */\n    unsubscribe(messageType, channelType = 'twilsock') {\n        logger_1.log.trace('Remove subscriptions for message type: ', messageType, channelType);\n        return this.registrar.unsubscribe(messageType, channelType);\n    }\n    /**\n     * Handle incoming push notification.\n     * Client application should call this method when it receives push notifications and pass the received data\n     * @param {Object} message push message\n     * @return {PushNotification}\n     */\n    handlePushNotification(message) {\n        return {\n            messageType: message.twi_message_type,\n            payload: message.payload\n        };\n    }\n    /**\n     * Set APN/GCM/FCM token to enable application register for a push messages\n     * @param {string} gcmToken/fcmToken Token received from GCM/FCM system\n     */\n    setPushRegistrationId(registrationId, channelType) {\n        logger_1.log.trace('Set push registration id', registrationId, channelType);\n        this.registrar.setNotificationId(channelType, registrationId);\n    }\n    /**\n     * Updates auth token for registration\n     * @param {string} token Authentication token for registrations\n     */\n    async updateToken(token) {\n        logger_1.log.info('authTokenUpdated');\n        if (this.services.config.token === token) {\n            return;\n        }\n        await this.services.twilsock.updateToken(token);\n        this.services.config.updateToken(token);\n        this.registrar.updateToken(token);\n    }\n}\nexports.Client = Client;\n/**\n * Fired when new message arrived.\n * @param {Object} message`\n * @event Client#message\n */\n/**\n * Fired when transport state has changed\n * @param {boolean} transport state\n * @event Client#transportReady\n */\n/**\n * Fired when transport state has been changed\n * @param {string} transport state\n * @event Client#connectionStateChanged\n */\n/**\n * These options can be passed to Client constructor\n * @typedef {Object} Notifications#ClientOptions\n * @property {String} [logLevel='error'] - The level of logging to enable. Valid options\n *   (from strictest to broadest): ['silent', 'error', 'warn', 'info', 'debug', 'trace']\n */\n"]},"metadata":{},"sourceType":"script"}