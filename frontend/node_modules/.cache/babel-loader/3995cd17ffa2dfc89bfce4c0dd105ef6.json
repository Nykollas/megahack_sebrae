{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nclass Node {\n  constructor(key, value) {\n    this.balanceFactor = 0;\n    this.key = key;\n    this.value = value;\n    this.parent = null;\n    this.left = null;\n    this.right = null;\n  }\n\n  get isRoot() {\n    return this.parent === null;\n  }\n\n  get isLeaf() {\n    return this.left === null && this.right === null;\n  }\n\n  get isLeftChild() {\n    return this.parent.left === this;\n  }\n\n  update(value) {\n    this.value = value;\n  }\n\n  replace(target, replacement) {\n    if (!target) {\n      return;\n    }\n\n    if (this.left === replacement) {\n      this.left = replacement;\n    } else if (this.right === replacement) {\n      this.right = replacement;\n    }\n  }\n\n}\n/**\n * @property length\n */\n\n\nclass TreeMap {\n  constructor(less, equal) {\n    this.isLessThan = less || ((x, y) => x < y);\n\n    this.isEqual = equal || ((x, y) => x === y);\n\n    this.root = null;\n    this.count = null;\n  }\n\n  get size() {\n    return this.count;\n  }\n\n  clear() {\n    this.root = null;\n    this.count = 0;\n  }\n\n  set(key, value) {\n    let node = this.getNode(key);\n\n    if (node) {\n      node.update(value);\n    } else {\n      this.insert(key, value);\n    } // return node;\n\n  }\n\n  insert(key, value) {\n    let node = new Node(key, value);\n    this.count++;\n\n    if (!this.root) {\n      this.root = node; // return node;\n\n      return;\n    }\n\n    let currNode = this.root;\n\n    for (;;) {\n      if (this.isLessThan(key, currNode.key)) {\n        if (currNode.left) {\n          currNode = currNode.left;\n        } else {\n          currNode.left = node;\n          break;\n        }\n      } else {\n        if (currNode.right) {\n          // eslint-disable-line no-lonely-if\n          currNode = currNode.right;\n        } else {\n          currNode.right = node;\n          break;\n        }\n      }\n    }\n\n    node.parent = currNode;\n    currNode = node;\n\n    while (currNode.parent) {\n      let parent = currNode.parent;\n      let prevBalanceFactor = parent.balanceFactor;\n\n      if (currNode.isLeftChild) {\n        parent.balanceFactor++;\n      } else {\n        parent.balanceFactor--;\n      }\n\n      if (Math.abs(parent.balanceFactor) < Math.abs(prevBalanceFactor)) {\n        break;\n      }\n\n      if (parent.balanceFactor < -1 || parent.balanceFactor > 1) {\n        this.rebalance(parent);\n        break;\n      }\n\n      currNode = parent;\n    } // return node;\n\n  }\n\n  get(key) {\n    let currentNode = this.root;\n\n    while (currentNode) {\n      if (this.isEqual(key, currentNode.key)) {\n        return currentNode.value;\n      }\n\n      if (this.isLessThan(key, currentNode.key)) {\n        currentNode = currentNode.left;\n      } else {\n        currentNode = currentNode.right;\n      }\n    }\n\n    return null;\n  }\n\n  delete(key) {\n    // update this algorithm and remove any\n    let node = this.getNode(key);\n\n    if (!node || node.key !== key) {\n      return null;\n    }\n\n    let parent = node.parent;\n    let left = node.left;\n    let right = node.right;\n\n    if (!!left !== !!right) {\n      // one child\n      let child = left || right;\n\n      if (!parent && !child) {\n        this.root = null;\n      } else if (parent && !child) {\n        this.root = child;\n      } else {\n        parent.replace(node, null);\n        this.rebalance(parent);\n      }\n    } else {\n      // two children\n      let maxLeft = node.left;\n\n      while (maxLeft.right) {\n        maxLeft = maxLeft.right;\n      }\n\n      if (node.left === maxLeft) {\n        if (node.isRoot) {\n          this.root = maxLeft;\n          maxLeft.parent = null;\n        } else {\n          if (node.isLeftChild) {\n            node.parent.left = maxLeft;\n          } else {\n            node.parent.right = maxLeft;\n          }\n\n          maxLeft.parent = node.parent;\n        }\n\n        maxLeft.right = node.right;\n        maxLeft.right.parent = maxLeft;\n        maxLeft.balanceFactor = node.balanceFactor;\n        node = {\n          parent: maxLeft,\n          isLeftChild: true\n        };\n      } else {\n        let mlParent = maxLeft.parent;\n        let mlLeft = maxLeft.left;\n        mlParent.right = mlLeft;\n\n        if (mlLeft) {\n          mlLeft.parent = mlParent;\n        }\n\n        if (node.isRoot) {\n          this.root = maxLeft;\n          maxLeft.parent = null;\n        } else {\n          if (node.isLeftChild) {\n            node.parent.left = maxLeft;\n          } else {\n            node.parent.right = maxLeft;\n          }\n\n          maxLeft.parent = node.parent;\n        }\n\n        maxLeft.right = node.right;\n        maxLeft.right.parent = maxLeft;\n        maxLeft.left = node.left;\n        maxLeft.left.parent = maxLeft;\n        maxLeft.balanceFactor = node.balanceFactor;\n        node = {\n          parent: mlParent,\n          isLeftChild: false\n        };\n      }\n    }\n\n    this.count--;\n\n    while (node.parent) {\n      let parent = node.parent;\n      let prevBalanceFactor = parent.balanceFactor;\n\n      if (node.isLeftChild) {\n        parent.balanceFactor -= 1;\n      } else {\n        parent.balanceFactor += 1;\n      }\n\n      if (Math.abs(parent.balanceFactor) > Math.abs(prevBalanceFactor)) {\n        if (parent.balanceFactor < -1 || parent.balanceFactor > 1) {\n          this.rebalance(parent);\n\n          if (parent.parent.balanceFactor === 0) {\n            node = parent.parent;\n          } else {\n            break;\n          }\n        } else {\n          break;\n        }\n      } else {\n        node = parent;\n      }\n    }\n\n    return null;\n  }\n\n  getNode(key) {\n    let currentNode = this.root;\n\n    while (currentNode) {\n      if (this.isEqual(key, currentNode.key)) {\n        return currentNode;\n      }\n\n      if (this.isLessThan(key, currentNode.key)) {\n        currentNode = currentNode.left;\n      } else {\n        currentNode = currentNode.right;\n      }\n    }\n\n    return null;\n  }\n\n  rebalance(node) {\n    if (node.balanceFactor < 0) {\n      if (node.right.balanceFactor > 0) {\n        this.rotateRight(node.right);\n        this.rotateLeft(node);\n      } else {\n        this.rotateLeft(node);\n      }\n    } else if (node.balanceFactor > 0) {\n      if (node.left.balanceFactor < 0) {\n        this.rotateLeft(node.left);\n        this.rotateRight(node);\n      } else {\n        this.rotateRight(node);\n      }\n    }\n  }\n\n  rotateLeft(pivot) {\n    let root = pivot.right;\n    pivot.right = root.left;\n\n    if (root.left !== null) {\n      root.left.parent = pivot;\n    }\n\n    root.parent = pivot.parent;\n\n    if (root.parent === null) {\n      this.root = root;\n    } else if (pivot.isLeftChild) {\n      root.parent.left = root;\n    } else {\n      root.parent.right = root;\n    }\n\n    root.left = pivot;\n    pivot.parent = root;\n    pivot.balanceFactor = pivot.balanceFactor + 1 - Math.min(root.balanceFactor, 0);\n    root.balanceFactor = root.balanceFactor + 1 - Math.max(pivot.balanceFactor, 0);\n  }\n\n  rotateRight(pivot) {\n    let root = pivot.left;\n    pivot.left = root.right;\n\n    if (root.right !== null) {\n      root.right.parent = pivot;\n    }\n\n    root.parent = pivot.parent;\n\n    if (root.parent === null) {\n      this.root = root;\n    } else if (pivot.isLeftChild) {\n      root.parent.left = root;\n    } else {\n      root.parent.right = root;\n    }\n\n    root.right = pivot;\n    pivot.parent = root;\n    pivot.balanceFactor = pivot.balanceFactor - 1 - Math.min(root.balanceFactor, 0);\n    root.balanceFactor = root.balanceFactor - 1 - Math.max(pivot.balanceFactor, 0);\n  }\n\n  *[Symbol.iterator]() {\n    for (let iter of this.getIterator()) {\n      yield iter;\n    }\n  }\n\n  *getIterator(key = null) {\n    let currentNode = this.root;\n\n    while (currentNode) {\n      if (this.isEqual(key, currentNode.key) || key === null && !currentNode.left) {\n        break;\n      }\n\n      if (this.isLessThan(key, currentNode.key) || key === null) {\n        currentNode = currentNode.left;\n      } else {\n        currentNode = currentNode.right;\n      }\n    }\n\n    if (!currentNode) {\n      return null;\n    }\n\n    let fromleft = true;\n\n    for (;;) {\n      if (fromleft) {\n        yield [currentNode.key, currentNode.value];\n        fromleft = false;\n\n        if (currentNode.right) {\n          currentNode = currentNode.right;\n\n          while (currentNode.left) {\n            currentNode = currentNode.left;\n          }\n\n          fromleft = true;\n        } else if (currentNode.parent) {\n          fromleft = currentNode.parent.left === currentNode;\n          currentNode = currentNode.parent;\n        } else {\n          break;\n        }\n      } else if (currentNode.parent) {\n        fromleft = currentNode.parent.left === currentNode;\n        currentNode = currentNode.parent;\n      } else {\n        break;\n      }\n    }\n\n    return null;\n  }\n\n  *getReverseIterator(key = null) {\n    let currentNode = this.root;\n\n    while (currentNode) {\n      if (this.isEqual(key, currentNode.key) || key === null && !currentNode.right) {\n        break;\n      }\n\n      if (!this.isLessThan(key, currentNode.key) || key === null) {\n        currentNode = currentNode.right;\n      } else {\n        currentNode = currentNode.left;\n      }\n    }\n\n    if (!currentNode) {\n      return null;\n    }\n\n    let fromright = true;\n\n    for (;;) {\n      if (fromright) {\n        yield [currentNode.key, currentNode.value];\n        fromright = false;\n\n        if (currentNode.left) {\n          currentNode = currentNode.left;\n\n          while (currentNode.right) {\n            currentNode = currentNode.right;\n          }\n\n          fromright = true;\n        } else if (currentNode.parent) {\n          fromright = currentNode.parent.right === currentNode;\n          currentNode = currentNode.parent;\n        } else {\n          break;\n        }\n      } else if (currentNode.parent) {\n        fromright = currentNode.parent.right === currentNode;\n        currentNode = currentNode.parent;\n      } else {\n        break;\n      }\n    }\n\n    return null;\n  }\n\n}\n\nexports.TreeMap = TreeMap;","map":{"version":3,"sources":["/home/ascencion/sebrae_megahack/node_modules/twilio-sync/lib/utils/tree.js"],"names":["Object","defineProperty","exports","value","Node","constructor","key","balanceFactor","parent","left","right","isRoot","isLeaf","isLeftChild","update","replace","target","replacement","TreeMap","less","equal","isLessThan","x","y","isEqual","root","count","size","clear","set","node","getNode","insert","currNode","prevBalanceFactor","Math","abs","rebalance","get","currentNode","delete","child","maxLeft","mlParent","mlLeft","rotateRight","rotateLeft","pivot","min","max","Symbol","iterator","iter","getIterator","fromleft","getReverseIterator","fromright"],"mappings":"AAAA;;AACAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;;AACA,MAAMC,IAAN,CAAW;AACPC,EAAAA,WAAW,CAACC,GAAD,EAAMH,KAAN,EAAa;AACpB,SAAKI,aAAL,GAAqB,CAArB;AACA,SAAKD,GAAL,GAAWA,GAAX;AACA,SAAKH,KAAL,GAAaA,KAAb;AACA,SAAKK,MAAL,GAAc,IAAd;AACA,SAAKC,IAAL,GAAY,IAAZ;AACA,SAAKC,KAAL,GAAa,IAAb;AACH;;AACD,MAAIC,MAAJ,GAAa;AAAE,WAAO,KAAKH,MAAL,KAAgB,IAAvB;AAA8B;;AAC7C,MAAII,MAAJ,GAAa;AAAE,WAAQ,KAAKH,IAAL,KAAc,IAAf,IAAyB,KAAKC,KAAL,KAAe,IAA/C;AAAuD;;AACtE,MAAIG,WAAJ,GAAkB;AAAE,WAAO,KAAKL,MAAL,CAAYC,IAAZ,KAAqB,IAA5B;AAAmC;;AACvDK,EAAAA,MAAM,CAACX,KAAD,EAAQ;AACV,SAAKA,KAAL,GAAaA,KAAb;AACH;;AACDY,EAAAA,OAAO,CAACC,MAAD,EAASC,WAAT,EAAsB;AACzB,QAAI,CAACD,MAAL,EAAa;AACT;AACH;;AACD,QAAI,KAAKP,IAAL,KAAcQ,WAAlB,EAA+B;AAC3B,WAAKR,IAAL,GAAYQ,WAAZ;AACH,KAFD,MAGK,IAAI,KAAKP,KAAL,KAAeO,WAAnB,EAAgC;AACjC,WAAKP,KAAL,GAAaO,WAAb;AACH;AACJ;;AAzBM;AA2BX;;;;;AAGA,MAAMC,OAAN,CAAc;AACVb,EAAAA,WAAW,CAACc,IAAD,EAAOC,KAAP,EAAc;AACrB,SAAKC,UAAL,GAAkBF,IAAI,KAAK,CAACG,CAAD,EAAIC,CAAJ,KAAUD,CAAC,GAAGC,CAAnB,CAAtB;;AACA,SAAKC,OAAL,GAAeJ,KAAK,KAAK,CAACE,CAAD,EAAIC,CAAJ,KAAUD,CAAC,KAAKC,CAArB,CAApB;;AACA,SAAKE,IAAL,GAAY,IAAZ;AACA,SAAKC,KAAL,GAAa,IAAb;AACH;;AACD,MAAIC,IAAJ,GAAW;AAAE,WAAO,KAAKD,KAAZ;AAAoB;;AACjCE,EAAAA,KAAK,GAAG;AACJ,SAAKH,IAAL,GAAY,IAAZ;AACA,SAAKC,KAAL,GAAa,CAAb;AACH;;AACDG,EAAAA,GAAG,CAACvB,GAAD,EAAMH,KAAN,EAAa;AACZ,QAAI2B,IAAI,GAAG,KAAKC,OAAL,CAAazB,GAAb,CAAX;;AACA,QAAIwB,IAAJ,EAAU;AACNA,MAAAA,IAAI,CAAChB,MAAL,CAAYX,KAAZ;AACH,KAFD,MAGK;AACD,WAAK6B,MAAL,CAAY1B,GAAZ,EAAiBH,KAAjB;AACH,KAPW,CAQZ;;AACH;;AACD6B,EAAAA,MAAM,CAAC1B,GAAD,EAAMH,KAAN,EAAa;AACf,QAAI2B,IAAI,GAAG,IAAI1B,IAAJ,CAASE,GAAT,EAAcH,KAAd,CAAX;AACA,SAAKuB,KAAL;;AACA,QAAI,CAAC,KAAKD,IAAV,EAAgB;AACZ,WAAKA,IAAL,GAAYK,IAAZ,CADY,CAEZ;;AACA;AACH;;AACD,QAAIG,QAAQ,GAAG,KAAKR,IAApB;;AACA,aAAS;AACL,UAAI,KAAKJ,UAAL,CAAgBf,GAAhB,EAAqB2B,QAAQ,CAAC3B,GAA9B,CAAJ,EAAwC;AACpC,YAAI2B,QAAQ,CAACxB,IAAb,EAAmB;AACfwB,UAAAA,QAAQ,GAAGA,QAAQ,CAACxB,IAApB;AACH,SAFD,MAGK;AACDwB,UAAAA,QAAQ,CAACxB,IAAT,GAAgBqB,IAAhB;AACA;AACH;AACJ,OARD,MASK;AACD,YAAIG,QAAQ,CAACvB,KAAb,EAAoB;AAAE;AAClBuB,UAAAA,QAAQ,GAAGA,QAAQ,CAACvB,KAApB;AACH,SAFD,MAGK;AACDuB,UAAAA,QAAQ,CAACvB,KAAT,GAAiBoB,IAAjB;AACA;AACH;AACJ;AACJ;;AACDA,IAAAA,IAAI,CAACtB,MAAL,GAAcyB,QAAd;AACAA,IAAAA,QAAQ,GAAGH,IAAX;;AACA,WAAOG,QAAQ,CAACzB,MAAhB,EAAwB;AACpB,UAAIA,MAAM,GAAGyB,QAAQ,CAACzB,MAAtB;AACA,UAAI0B,iBAAiB,GAAG1B,MAAM,CAACD,aAA/B;;AACA,UAAI0B,QAAQ,CAACpB,WAAb,EAA0B;AACtBL,QAAAA,MAAM,CAACD,aAAP;AACH,OAFD,MAGK;AACDC,QAAAA,MAAM,CAACD,aAAP;AACH;;AACD,UAAI4B,IAAI,CAACC,GAAL,CAAS5B,MAAM,CAACD,aAAhB,IAAiC4B,IAAI,CAACC,GAAL,CAASF,iBAAT,CAArC,EAAkE;AAC9D;AACH;;AACD,UAAI1B,MAAM,CAACD,aAAP,GAAuB,CAAC,CAAxB,IAA6BC,MAAM,CAACD,aAAP,GAAuB,CAAxD,EAA2D;AACvD,aAAK8B,SAAL,CAAe7B,MAAf;AACA;AACH;;AACDyB,MAAAA,QAAQ,GAAGzB,MAAX;AACH,KAhDc,CAiDf;;AACH;;AACD8B,EAAAA,GAAG,CAAChC,GAAD,EAAM;AACL,QAAIiC,WAAW,GAAG,KAAKd,IAAvB;;AACA,WAAOc,WAAP,EAAoB;AAChB,UAAI,KAAKf,OAAL,CAAalB,GAAb,EAAkBiC,WAAW,CAACjC,GAA9B,CAAJ,EAAwC;AACpC,eAAOiC,WAAW,CAACpC,KAAnB;AACH;;AACD,UAAI,KAAKkB,UAAL,CAAgBf,GAAhB,EAAqBiC,WAAW,CAACjC,GAAjC,CAAJ,EAA2C;AACvCiC,QAAAA,WAAW,GAAGA,WAAW,CAAC9B,IAA1B;AACH,OAFD,MAGK;AACD8B,QAAAA,WAAW,GAAGA,WAAW,CAAC7B,KAA1B;AACH;AACJ;;AACD,WAAO,IAAP;AACH;;AACD8B,EAAAA,MAAM,CAAClC,GAAD,EAAM;AACR;AACA,QAAIwB,IAAI,GAAG,KAAKC,OAAL,CAAazB,GAAb,CAAX;;AACA,QAAI,CAACwB,IAAD,IAASA,IAAI,CAACxB,GAAL,KAAaA,GAA1B,EAA+B;AAC3B,aAAO,IAAP;AACH;;AACD,QAAIE,MAAM,GAAGsB,IAAI,CAACtB,MAAlB;AACA,QAAIC,IAAI,GAAGqB,IAAI,CAACrB,IAAhB;AACA,QAAIC,KAAK,GAAGoB,IAAI,CAACpB,KAAjB;;AACA,QAAI,CAAC,CAACD,IAAF,KAAW,CAAC,CAACC,KAAjB,EAAwB;AAAE;AACtB,UAAI+B,KAAK,GAAGhC,IAAI,IAAIC,KAApB;;AACA,UAAI,CAACF,MAAD,IAAW,CAACiC,KAAhB,EAAuB;AACnB,aAAKhB,IAAL,GAAY,IAAZ;AACH,OAFD,MAGK,IAAIjB,MAAM,IAAI,CAACiC,KAAf,EAAsB;AACvB,aAAKhB,IAAL,GAAYgB,KAAZ;AACH,OAFI,MAGA;AACDjC,QAAAA,MAAM,CAACO,OAAP,CAAee,IAAf,EAAqB,IAArB;AACA,aAAKO,SAAL,CAAe7B,MAAf;AACH;AACJ,KAZD,MAaK;AAAE;AACH,UAAIkC,OAAO,GAAGZ,IAAI,CAACrB,IAAnB;;AACA,aAAOiC,OAAO,CAAChC,KAAf,EAAsB;AAClBgC,QAAAA,OAAO,GAAGA,OAAO,CAAChC,KAAlB;AACH;;AACD,UAAIoB,IAAI,CAACrB,IAAL,KAAciC,OAAlB,EAA2B;AACvB,YAAIZ,IAAI,CAACnB,MAAT,EAAiB;AACb,eAAKc,IAAL,GAAYiB,OAAZ;AACAA,UAAAA,OAAO,CAAClC,MAAR,GAAiB,IAAjB;AACH,SAHD,MAIK;AACD,cAAIsB,IAAI,CAACjB,WAAT,EAAsB;AAClBiB,YAAAA,IAAI,CAACtB,MAAL,CAAYC,IAAZ,GAAmBiC,OAAnB;AACH,WAFD,MAGK;AACDZ,YAAAA,IAAI,CAACtB,MAAL,CAAYE,KAAZ,GAAoBgC,OAApB;AACH;;AACDA,UAAAA,OAAO,CAAClC,MAAR,GAAiBsB,IAAI,CAACtB,MAAtB;AACH;;AACDkC,QAAAA,OAAO,CAAChC,KAAR,GAAgBoB,IAAI,CAACpB,KAArB;AACAgC,QAAAA,OAAO,CAAChC,KAAR,CAAcF,MAAd,GAAuBkC,OAAvB;AACAA,QAAAA,OAAO,CAACnC,aAAR,GAAwBuB,IAAI,CAACvB,aAA7B;AACAuB,QAAAA,IAAI,GAAG;AACHtB,UAAAA,MAAM,EAAEkC,OADL;AACc7B,UAAAA,WAAW,EAAE;AAD3B,SAAP;AAGH,OApBD,MAqBK;AACD,YAAI8B,QAAQ,GAAGD,OAAO,CAAClC,MAAvB;AACA,YAAIoC,MAAM,GAAGF,OAAO,CAACjC,IAArB;AACAkC,QAAAA,QAAQ,CAACjC,KAAT,GAAiBkC,MAAjB;;AACA,YAAIA,MAAJ,EAAY;AACRA,UAAAA,MAAM,CAACpC,MAAP,GAAgBmC,QAAhB;AACH;;AACD,YAAIb,IAAI,CAACnB,MAAT,EAAiB;AACb,eAAKc,IAAL,GAAYiB,OAAZ;AACAA,UAAAA,OAAO,CAAClC,MAAR,GAAiB,IAAjB;AACH,SAHD,MAIK;AACD,cAAIsB,IAAI,CAACjB,WAAT,EAAsB;AAClBiB,YAAAA,IAAI,CAACtB,MAAL,CAAYC,IAAZ,GAAmBiC,OAAnB;AACH,WAFD,MAGK;AACDZ,YAAAA,IAAI,CAACtB,MAAL,CAAYE,KAAZ,GAAoBgC,OAApB;AACH;;AACDA,UAAAA,OAAO,CAAClC,MAAR,GAAiBsB,IAAI,CAACtB,MAAtB;AACH;;AACDkC,QAAAA,OAAO,CAAChC,KAAR,GAAgBoB,IAAI,CAACpB,KAArB;AACAgC,QAAAA,OAAO,CAAChC,KAAR,CAAcF,MAAd,GAAuBkC,OAAvB;AACAA,QAAAA,OAAO,CAACjC,IAAR,GAAeqB,IAAI,CAACrB,IAApB;AACAiC,QAAAA,OAAO,CAACjC,IAAR,CAAaD,MAAb,GAAsBkC,OAAtB;AACAA,QAAAA,OAAO,CAACnC,aAAR,GAAwBuB,IAAI,CAACvB,aAA7B;AACAuB,QAAAA,IAAI,GAAG;AACHtB,UAAAA,MAAM,EAAEmC,QADL;AACe9B,UAAAA,WAAW,EAAE;AAD5B,SAAP;AAGH;AACJ;;AACD,SAAKa,KAAL;;AACA,WAAOI,IAAI,CAACtB,MAAZ,EAAoB;AAChB,UAAIA,MAAM,GAAGsB,IAAI,CAACtB,MAAlB;AACA,UAAI0B,iBAAiB,GAAG1B,MAAM,CAACD,aAA/B;;AACA,UAAIuB,IAAI,CAACjB,WAAT,EAAsB;AAClBL,QAAAA,MAAM,CAACD,aAAP,IAAwB,CAAxB;AACH,OAFD,MAGK;AACDC,QAAAA,MAAM,CAACD,aAAP,IAAwB,CAAxB;AACH;;AACD,UAAI4B,IAAI,CAACC,GAAL,CAAS5B,MAAM,CAACD,aAAhB,IAAiC4B,IAAI,CAACC,GAAL,CAASF,iBAAT,CAArC,EAAkE;AAC9D,YAAI1B,MAAM,CAACD,aAAP,GAAuB,CAAC,CAAxB,IAA6BC,MAAM,CAACD,aAAP,GAAuB,CAAxD,EAA2D;AACvD,eAAK8B,SAAL,CAAe7B,MAAf;;AACA,cAAIA,MAAM,CAACA,MAAP,CAAcD,aAAd,KAAgC,CAApC,EAAuC;AACnCuB,YAAAA,IAAI,GAAGtB,MAAM,CAACA,MAAd;AACH,WAFD,MAGK;AACD;AACH;AACJ,SARD,MASK;AACD;AACH;AACJ,OAbD,MAcK;AACDsB,QAAAA,IAAI,GAAGtB,MAAP;AACH;AACJ;;AACD,WAAO,IAAP;AACH;;AACDuB,EAAAA,OAAO,CAACzB,GAAD,EAAM;AACT,QAAIiC,WAAW,GAAG,KAAKd,IAAvB;;AACA,WAAOc,WAAP,EAAoB;AAChB,UAAI,KAAKf,OAAL,CAAalB,GAAb,EAAkBiC,WAAW,CAACjC,GAA9B,CAAJ,EAAwC;AACpC,eAAOiC,WAAP;AACH;;AACD,UAAI,KAAKlB,UAAL,CAAgBf,GAAhB,EAAqBiC,WAAW,CAACjC,GAAjC,CAAJ,EAA2C;AACvCiC,QAAAA,WAAW,GAAGA,WAAW,CAAC9B,IAA1B;AACH,OAFD,MAGK;AACD8B,QAAAA,WAAW,GAAGA,WAAW,CAAC7B,KAA1B;AACH;AACJ;;AACD,WAAO,IAAP;AACH;;AACD2B,EAAAA,SAAS,CAACP,IAAD,EAAO;AACZ,QAAIA,IAAI,CAACvB,aAAL,GAAqB,CAAzB,EAA4B;AACxB,UAAIuB,IAAI,CAACpB,KAAL,CAAWH,aAAX,GAA2B,CAA/B,EAAkC;AAC9B,aAAKsC,WAAL,CAAiBf,IAAI,CAACpB,KAAtB;AACA,aAAKoC,UAAL,CAAgBhB,IAAhB;AACH,OAHD,MAIK;AACD,aAAKgB,UAAL,CAAgBhB,IAAhB;AACH;AACJ,KARD,MASK,IAAIA,IAAI,CAACvB,aAAL,GAAqB,CAAzB,EAA4B;AAC7B,UAAIuB,IAAI,CAACrB,IAAL,CAAUF,aAAV,GAA0B,CAA9B,EAAiC;AAC7B,aAAKuC,UAAL,CAAgBhB,IAAI,CAACrB,IAArB;AACA,aAAKoC,WAAL,CAAiBf,IAAjB;AACH,OAHD,MAIK;AACD,aAAKe,WAAL,CAAiBf,IAAjB;AACH;AACJ;AACJ;;AACDgB,EAAAA,UAAU,CAACC,KAAD,EAAQ;AACd,QAAItB,IAAI,GAAGsB,KAAK,CAACrC,KAAjB;AACAqC,IAAAA,KAAK,CAACrC,KAAN,GAAce,IAAI,CAAChB,IAAnB;;AACA,QAAIgB,IAAI,CAAChB,IAAL,KAAc,IAAlB,EAAwB;AACpBgB,MAAAA,IAAI,CAAChB,IAAL,CAAUD,MAAV,GAAmBuC,KAAnB;AACH;;AACDtB,IAAAA,IAAI,CAACjB,MAAL,GAAcuC,KAAK,CAACvC,MAApB;;AACA,QAAIiB,IAAI,CAACjB,MAAL,KAAgB,IAApB,EAA0B;AACtB,WAAKiB,IAAL,GAAYA,IAAZ;AACH,KAFD,MAGK,IAAIsB,KAAK,CAAClC,WAAV,EAAuB;AACxBY,MAAAA,IAAI,CAACjB,MAAL,CAAYC,IAAZ,GAAmBgB,IAAnB;AACH,KAFI,MAGA;AACDA,MAAAA,IAAI,CAACjB,MAAL,CAAYE,KAAZ,GAAoBe,IAApB;AACH;;AACDA,IAAAA,IAAI,CAAChB,IAAL,GAAYsC,KAAZ;AACAA,IAAAA,KAAK,CAACvC,MAAN,GAAeiB,IAAf;AACAsB,IAAAA,KAAK,CAACxC,aAAN,GAAsBwC,KAAK,CAACxC,aAAN,GAAsB,CAAtB,GAA0B4B,IAAI,CAACa,GAAL,CAASvB,IAAI,CAAClB,aAAd,EAA6B,CAA7B,CAAhD;AACAkB,IAAAA,IAAI,CAAClB,aAAL,GAAqBkB,IAAI,CAAClB,aAAL,GAAqB,CAArB,GAAyB4B,IAAI,CAACc,GAAL,CAASF,KAAK,CAACxC,aAAf,EAA8B,CAA9B,CAA9C;AACH;;AACDsC,EAAAA,WAAW,CAACE,KAAD,EAAQ;AACf,QAAItB,IAAI,GAAGsB,KAAK,CAACtC,IAAjB;AACAsC,IAAAA,KAAK,CAACtC,IAAN,GAAagB,IAAI,CAACf,KAAlB;;AACA,QAAIe,IAAI,CAACf,KAAL,KAAe,IAAnB,EAAyB;AACrBe,MAAAA,IAAI,CAACf,KAAL,CAAWF,MAAX,GAAoBuC,KAApB;AACH;;AACDtB,IAAAA,IAAI,CAACjB,MAAL,GAAcuC,KAAK,CAACvC,MAApB;;AACA,QAAIiB,IAAI,CAACjB,MAAL,KAAgB,IAApB,EAA0B;AACtB,WAAKiB,IAAL,GAAYA,IAAZ;AACH,KAFD,MAGK,IAAIsB,KAAK,CAAClC,WAAV,EAAuB;AACxBY,MAAAA,IAAI,CAACjB,MAAL,CAAYC,IAAZ,GAAmBgB,IAAnB;AACH,KAFI,MAGA;AACDA,MAAAA,IAAI,CAACjB,MAAL,CAAYE,KAAZ,GAAoBe,IAApB;AACH;;AACDA,IAAAA,IAAI,CAACf,KAAL,GAAaqC,KAAb;AACAA,IAAAA,KAAK,CAACvC,MAAN,GAAeiB,IAAf;AACAsB,IAAAA,KAAK,CAACxC,aAAN,GAAsBwC,KAAK,CAACxC,aAAN,GAAsB,CAAtB,GAA0B4B,IAAI,CAACa,GAAL,CAASvB,IAAI,CAAClB,aAAd,EAA6B,CAA7B,CAAhD;AACAkB,IAAAA,IAAI,CAAClB,aAAL,GAAqBkB,IAAI,CAAClB,aAAL,GAAqB,CAArB,GAAyB4B,IAAI,CAACc,GAAL,CAASF,KAAK,CAACxC,aAAf,EAA8B,CAA9B,CAA9C;AACH;;AACD,IAAE2C,MAAM,CAACC,QAAT,IAAqB;AACjB,SAAK,IAAIC,IAAT,IAAiB,KAAKC,WAAL,EAAjB,EAAqC;AACjC,YAAMD,IAAN;AACH;AACJ;;AACD,GAACC,WAAD,CAAa/C,GAAG,GAAG,IAAnB,EAAyB;AACrB,QAAIiC,WAAW,GAAG,KAAKd,IAAvB;;AACA,WAAOc,WAAP,EAAoB;AAChB,UAAI,KAAKf,OAAL,CAAalB,GAAb,EAAkBiC,WAAW,CAACjC,GAA9B,KAAwCA,GAAG,KAAK,IAAT,IAAkB,CAACiC,WAAW,CAAC9B,IAA1E,EAAiF;AAC7E;AACH;;AACD,UAAI,KAAKY,UAAL,CAAgBf,GAAhB,EAAqBiC,WAAW,CAACjC,GAAjC,KAA0CA,GAAG,KAAK,IAAtD,EAA6D;AACzDiC,QAAAA,WAAW,GAAGA,WAAW,CAAC9B,IAA1B;AACH,OAFD,MAGK;AACD8B,QAAAA,WAAW,GAAGA,WAAW,CAAC7B,KAA1B;AACH;AACJ;;AACD,QAAI,CAAC6B,WAAL,EAAkB;AACd,aAAO,IAAP;AACH;;AACD,QAAIe,QAAQ,GAAG,IAAf;;AACA,aAAS;AACL,UAAIA,QAAJ,EAAc;AACV,cAAM,CAACf,WAAW,CAACjC,GAAb,EAAkBiC,WAAW,CAACpC,KAA9B,CAAN;AACAmD,QAAAA,QAAQ,GAAG,KAAX;;AACA,YAAIf,WAAW,CAAC7B,KAAhB,EAAuB;AACnB6B,UAAAA,WAAW,GAAGA,WAAW,CAAC7B,KAA1B;;AACA,iBAAO6B,WAAW,CAAC9B,IAAnB,EAAyB;AACrB8B,YAAAA,WAAW,GAAGA,WAAW,CAAC9B,IAA1B;AACH;;AACD6C,UAAAA,QAAQ,GAAG,IAAX;AACH,SAND,MAOK,IAAIf,WAAW,CAAC/B,MAAhB,EAAwB;AACzB8C,UAAAA,QAAQ,GAAIf,WAAW,CAAC/B,MAAZ,CAAmBC,IAAnB,KAA4B8B,WAAxC;AACAA,UAAAA,WAAW,GAAGA,WAAW,CAAC/B,MAA1B;AACH,SAHI,MAIA;AACD;AACH;AACJ,OAjBD,MAkBK,IAAI+B,WAAW,CAAC/B,MAAhB,EAAwB;AACzB8C,QAAAA,QAAQ,GAAIf,WAAW,CAAC/B,MAAZ,CAAmBC,IAAnB,KAA4B8B,WAAxC;AACAA,QAAAA,WAAW,GAAGA,WAAW,CAAC/B,MAA1B;AACH,OAHI,MAIA;AACD;AACH;AACJ;;AACD,WAAO,IAAP;AACH;;AACD,GAAC+C,kBAAD,CAAoBjD,GAAG,GAAG,IAA1B,EAAgC;AAC5B,QAAIiC,WAAW,GAAG,KAAKd,IAAvB;;AACA,WAAOc,WAAP,EAAoB;AAChB,UAAI,KAAKf,OAAL,CAAalB,GAAb,EAAkBiC,WAAW,CAACjC,GAA9B,KAAwCA,GAAG,KAAK,IAAT,IAAkB,CAACiC,WAAW,CAAC7B,KAA1E,EAAkF;AAC9E;AACH;;AACD,UAAI,CAAC,KAAKW,UAAL,CAAgBf,GAAhB,EAAqBiC,WAAW,CAACjC,GAAjC,CAAD,IAA2CA,GAAG,KAAK,IAAvD,EAA8D;AAC1DiC,QAAAA,WAAW,GAAGA,WAAW,CAAC7B,KAA1B;AACH,OAFD,MAGK;AACD6B,QAAAA,WAAW,GAAGA,WAAW,CAAC9B,IAA1B;AACH;AACJ;;AACD,QAAI,CAAC8B,WAAL,EAAkB;AACd,aAAO,IAAP;AACH;;AACD,QAAIiB,SAAS,GAAG,IAAhB;;AACA,aAAS;AACL,UAAIA,SAAJ,EAAe;AACX,cAAM,CAACjB,WAAW,CAACjC,GAAb,EAAkBiC,WAAW,CAACpC,KAA9B,CAAN;AACAqD,QAAAA,SAAS,GAAG,KAAZ;;AACA,YAAIjB,WAAW,CAAC9B,IAAhB,EAAsB;AAClB8B,UAAAA,WAAW,GAAGA,WAAW,CAAC9B,IAA1B;;AACA,iBAAO8B,WAAW,CAAC7B,KAAnB,EAA0B;AACtB6B,YAAAA,WAAW,GAAGA,WAAW,CAAC7B,KAA1B;AACH;;AACD8C,UAAAA,SAAS,GAAG,IAAZ;AACH,SAND,MAOK,IAAIjB,WAAW,CAAC/B,MAAhB,EAAwB;AACzBgD,UAAAA,SAAS,GAAIjB,WAAW,CAAC/B,MAAZ,CAAmBE,KAAnB,KAA6B6B,WAA1C;AACAA,UAAAA,WAAW,GAAGA,WAAW,CAAC/B,MAA1B;AACH,SAHI,MAIA;AACD;AACH;AACJ,OAjBD,MAkBK,IAAI+B,WAAW,CAAC/B,MAAhB,EAAwB;AACzBgD,QAAAA,SAAS,GAAIjB,WAAW,CAAC/B,MAAZ,CAAmBE,KAAnB,KAA6B6B,WAA1C;AACAA,QAAAA,WAAW,GAAGA,WAAW,CAAC/B,MAA1B;AACH,OAHI,MAIA;AACD;AACH;AACJ;;AACD,WAAO,IAAP;AACH;;AAjXS;;AAmXdN,OAAO,CAACgB,OAAR,GAAkBA,OAAlB","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass Node {\n    constructor(key, value) {\n        this.balanceFactor = 0;\n        this.key = key;\n        this.value = value;\n        this.parent = null;\n        this.left = null;\n        this.right = null;\n    }\n    get isRoot() { return this.parent === null; }\n    get isLeaf() { return (this.left === null) && (this.right === null); }\n    get isLeftChild() { return this.parent.left === this; }\n    update(value) {\n        this.value = value;\n    }\n    replace(target, replacement) {\n        if (!target) {\n            return;\n        }\n        if (this.left === replacement) {\n            this.left = replacement;\n        }\n        else if (this.right === replacement) {\n            this.right = replacement;\n        }\n    }\n}\n/**\n * @property length\n */\nclass TreeMap {\n    constructor(less, equal) {\n        this.isLessThan = less || ((x, y) => x < y);\n        this.isEqual = equal || ((x, y) => x === y);\n        this.root = null;\n        this.count = null;\n    }\n    get size() { return this.count; }\n    clear() {\n        this.root = null;\n        this.count = 0;\n    }\n    set(key, value) {\n        let node = this.getNode(key);\n        if (node) {\n            node.update(value);\n        }\n        else {\n            this.insert(key, value);\n        }\n        // return node;\n    }\n    insert(key, value) {\n        let node = new Node(key, value);\n        this.count++;\n        if (!this.root) {\n            this.root = node;\n            // return node;\n            return;\n        }\n        let currNode = this.root;\n        for (;;) {\n            if (this.isLessThan(key, currNode.key)) {\n                if (currNode.left) {\n                    currNode = currNode.left;\n                }\n                else {\n                    currNode.left = node;\n                    break;\n                }\n            }\n            else {\n                if (currNode.right) { // eslint-disable-line no-lonely-if\n                    currNode = currNode.right;\n                }\n                else {\n                    currNode.right = node;\n                    break;\n                }\n            }\n        }\n        node.parent = currNode;\n        currNode = node;\n        while (currNode.parent) {\n            let parent = currNode.parent;\n            let prevBalanceFactor = parent.balanceFactor;\n            if (currNode.isLeftChild) {\n                parent.balanceFactor++;\n            }\n            else {\n                parent.balanceFactor--;\n            }\n            if (Math.abs(parent.balanceFactor) < Math.abs(prevBalanceFactor)) {\n                break;\n            }\n            if (parent.balanceFactor < -1 || parent.balanceFactor > 1) {\n                this.rebalance(parent);\n                break;\n            }\n            currNode = parent;\n        }\n        // return node;\n    }\n    get(key) {\n        let currentNode = this.root;\n        while (currentNode) {\n            if (this.isEqual(key, currentNode.key)) {\n                return currentNode.value;\n            }\n            if (this.isLessThan(key, currentNode.key)) {\n                currentNode = currentNode.left;\n            }\n            else {\n                currentNode = currentNode.right;\n            }\n        }\n        return null;\n    }\n    delete(key) {\n        // update this algorithm and remove any\n        let node = this.getNode(key);\n        if (!node || node.key !== key) {\n            return null;\n        }\n        let parent = node.parent;\n        let left = node.left;\n        let right = node.right;\n        if (!!left !== !!right) { // one child\n            let child = left || right;\n            if (!parent && !child) {\n                this.root = null;\n            }\n            else if (parent && !child) {\n                this.root = child;\n            }\n            else {\n                parent.replace(node, null);\n                this.rebalance(parent);\n            }\n        }\n        else { // two children\n            let maxLeft = node.left;\n            while (maxLeft.right) {\n                maxLeft = maxLeft.right;\n            }\n            if (node.left === maxLeft) {\n                if (node.isRoot) {\n                    this.root = maxLeft;\n                    maxLeft.parent = null;\n                }\n                else {\n                    if (node.isLeftChild) {\n                        node.parent.left = maxLeft;\n                    }\n                    else {\n                        node.parent.right = maxLeft;\n                    }\n                    maxLeft.parent = node.parent;\n                }\n                maxLeft.right = node.right;\n                maxLeft.right.parent = maxLeft;\n                maxLeft.balanceFactor = node.balanceFactor;\n                node = {\n                    parent: maxLeft, isLeftChild: true\n                };\n            }\n            else {\n                let mlParent = maxLeft.parent;\n                let mlLeft = maxLeft.left;\n                mlParent.right = mlLeft;\n                if (mlLeft) {\n                    mlLeft.parent = mlParent;\n                }\n                if (node.isRoot) {\n                    this.root = maxLeft;\n                    maxLeft.parent = null;\n                }\n                else {\n                    if (node.isLeftChild) {\n                        node.parent.left = maxLeft;\n                    }\n                    else {\n                        node.parent.right = maxLeft;\n                    }\n                    maxLeft.parent = node.parent;\n                }\n                maxLeft.right = node.right;\n                maxLeft.right.parent = maxLeft;\n                maxLeft.left = node.left;\n                maxLeft.left.parent = maxLeft;\n                maxLeft.balanceFactor = node.balanceFactor;\n                node = {\n                    parent: mlParent, isLeftChild: false\n                };\n            }\n        }\n        this.count--;\n        while (node.parent) {\n            let parent = node.parent;\n            let prevBalanceFactor = parent.balanceFactor;\n            if (node.isLeftChild) {\n                parent.balanceFactor -= 1;\n            }\n            else {\n                parent.balanceFactor += 1;\n            }\n            if (Math.abs(parent.balanceFactor) > Math.abs(prevBalanceFactor)) {\n                if (parent.balanceFactor < -1 || parent.balanceFactor > 1) {\n                    this.rebalance(parent);\n                    if (parent.parent.balanceFactor === 0) {\n                        node = parent.parent;\n                    }\n                    else {\n                        break;\n                    }\n                }\n                else {\n                    break;\n                }\n            }\n            else {\n                node = parent;\n            }\n        }\n        return null;\n    }\n    getNode(key) {\n        let currentNode = this.root;\n        while (currentNode) {\n            if (this.isEqual(key, currentNode.key)) {\n                return currentNode;\n            }\n            if (this.isLessThan(key, currentNode.key)) {\n                currentNode = currentNode.left;\n            }\n            else {\n                currentNode = currentNode.right;\n            }\n        }\n        return null;\n    }\n    rebalance(node) {\n        if (node.balanceFactor < 0) {\n            if (node.right.balanceFactor > 0) {\n                this.rotateRight(node.right);\n                this.rotateLeft(node);\n            }\n            else {\n                this.rotateLeft(node);\n            }\n        }\n        else if (node.balanceFactor > 0) {\n            if (node.left.balanceFactor < 0) {\n                this.rotateLeft(node.left);\n                this.rotateRight(node);\n            }\n            else {\n                this.rotateRight(node);\n            }\n        }\n    }\n    rotateLeft(pivot) {\n        let root = pivot.right;\n        pivot.right = root.left;\n        if (root.left !== null) {\n            root.left.parent = pivot;\n        }\n        root.parent = pivot.parent;\n        if (root.parent === null) {\n            this.root = root;\n        }\n        else if (pivot.isLeftChild) {\n            root.parent.left = root;\n        }\n        else {\n            root.parent.right = root;\n        }\n        root.left = pivot;\n        pivot.parent = root;\n        pivot.balanceFactor = pivot.balanceFactor + 1 - Math.min(root.balanceFactor, 0);\n        root.balanceFactor = root.balanceFactor + 1 - Math.max(pivot.balanceFactor, 0);\n    }\n    rotateRight(pivot) {\n        let root = pivot.left;\n        pivot.left = root.right;\n        if (root.right !== null) {\n            root.right.parent = pivot;\n        }\n        root.parent = pivot.parent;\n        if (root.parent === null) {\n            this.root = root;\n        }\n        else if (pivot.isLeftChild) {\n            root.parent.left = root;\n        }\n        else {\n            root.parent.right = root;\n        }\n        root.right = pivot;\n        pivot.parent = root;\n        pivot.balanceFactor = pivot.balanceFactor - 1 - Math.min(root.balanceFactor, 0);\n        root.balanceFactor = root.balanceFactor - 1 - Math.max(pivot.balanceFactor, 0);\n    }\n    *[Symbol.iterator]() {\n        for (let iter of this.getIterator()) {\n            yield iter;\n        }\n    }\n    *getIterator(key = null) {\n        let currentNode = this.root;\n        while (currentNode) {\n            if (this.isEqual(key, currentNode.key) || ((key === null) && !currentNode.left)) {\n                break;\n            }\n            if (this.isLessThan(key, currentNode.key) || (key === null)) {\n                currentNode = currentNode.left;\n            }\n            else {\n                currentNode = currentNode.right;\n            }\n        }\n        if (!currentNode) {\n            return null;\n        }\n        let fromleft = true;\n        for (;;) {\n            if (fromleft) {\n                yield [currentNode.key, currentNode.value];\n                fromleft = false;\n                if (currentNode.right) {\n                    currentNode = currentNode.right;\n                    while (currentNode.left) {\n                        currentNode = currentNode.left;\n                    }\n                    fromleft = true;\n                }\n                else if (currentNode.parent) {\n                    fromleft = (currentNode.parent.left === currentNode);\n                    currentNode = currentNode.parent;\n                }\n                else {\n                    break;\n                }\n            }\n            else if (currentNode.parent) {\n                fromleft = (currentNode.parent.left === currentNode);\n                currentNode = currentNode.parent;\n            }\n            else {\n                break;\n            }\n        }\n        return null;\n    }\n    *getReverseIterator(key = null) {\n        let currentNode = this.root;\n        while (currentNode) {\n            if (this.isEqual(key, currentNode.key) || ((key === null) && !currentNode.right)) {\n                break;\n            }\n            if (!this.isLessThan(key, currentNode.key) || (key === null)) {\n                currentNode = currentNode.right;\n            }\n            else {\n                currentNode = currentNode.left;\n            }\n        }\n        if (!currentNode) {\n            return null;\n        }\n        let fromright = true;\n        for (;;) {\n            if (fromright) {\n                yield [currentNode.key, currentNode.value];\n                fromright = false;\n                if (currentNode.left) {\n                    currentNode = currentNode.left;\n                    while (currentNode.right) {\n                        currentNode = currentNode.right;\n                    }\n                    fromright = true;\n                }\n                else if (currentNode.parent) {\n                    fromright = (currentNode.parent.right === currentNode);\n                    currentNode = currentNode.parent;\n                }\n                else {\n                    break;\n                }\n            }\n            else if (currentNode.parent) {\n                fromright = (currentNode.parent.right === currentNode);\n                currentNode = currentNode.parent;\n            }\n            else {\n                break;\n            }\n        }\n        return null;\n    }\n}\nexports.TreeMap = TreeMap;\n"]},"metadata":{},"sourceType":"script"}