{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst events_1 = require(\"events\");\n\nconst operation_retrier_1 = require(\"operation-retrier\");\n/**\n * Retrier with backoff override capability\n*/\n\n\nclass BackoffRetrier extends events_1.EventEmitter {\n  constructor(options) {\n    super();\n    this.options = options ? Object.assign({}, options) : {};\n  }\n\n  get inProgress() {\n    return !!this.retrier;\n  }\n  /**\n   * Should be called once per attempt series to start retrier.\n  */\n\n\n  start() {\n    if (this.inProgress) {\n      throw new Error('Already waiting for next attempt, call finishAttempt(success : boolean) to finish it');\n    }\n\n    this.createRetrier();\n  }\n  /**\n   * Should be called to stop retrier entirely.\n  */\n\n\n  stop() {\n    this.cleanRetrier();\n    this.newBackoff = null;\n    this.usedBackoff = null;\n  }\n  /**\n   * Modifies backoff for next attempt.\n   * Expected behavior:\n   * - If there was no backoff passed previously reschedulling next attempt to given backoff\n   * - If previous backoff was longer then ignoring this one.\n   * - If previous backoff was shorter then reschedulling with this one.\n   * With or without backoff retrier will keep growing normally.\n   * @param delay delay of next attempts in ms.\n   */\n\n\n  modifyBackoff(delay) {\n    this.newBackoff = delay;\n  }\n  /**\n   * Mark last emmited attempt as failed, initiating either next of fail if limits were hit.\n  */\n\n\n  attemptFailed() {\n    if (!this.inProgress) {\n      throw new Error('No attempt is in progress');\n    }\n\n    if (this.newBackoff) {\n      const shouldUseNewBackoff = !this.usedBackoff || this.usedBackoff < this.newBackoff;\n\n      if (shouldUseNewBackoff) {\n        this.createRetrier();\n      } else {\n        this.retrier.failed(new Error());\n      }\n    } else {\n      this.retrier.failed(new Error());\n    }\n  }\n\n  cancel() {\n    if (this.retrier) {\n      this.retrier.cancel();\n    }\n  }\n\n  cleanRetrier() {\n    if (this.retrier) {\n      this.retrier.removeAllListeners();\n      this.retrier.cancel();\n      this.retrier = null;\n    }\n  }\n\n  getRetryPolicy() {\n    const clone = Object.assign({}, this.options);\n\n    if (this.newBackoff) {\n      clone.min = this.newBackoff;\n      clone.max = this.options.max && this.options.max > this.newBackoff ? this.options.max : this.newBackoff;\n    } // As we're always skipping first attempt we should add one extra if limit is present\n\n\n    clone.maxAttemptsCount = this.options.maxAttemptsCount ? this.options.maxAttemptsCount + 1 : undefined;\n    return clone;\n  }\n\n  createRetrier() {\n    this.cleanRetrier();\n    const retryPolicy = this.getRetryPolicy();\n    this.retrier = new operation_retrier_1.Retrier(retryPolicy);\n    this.retrier.once('attempt', () => {\n      this.retrier.on('attempt', () => this.emit('attempt'));\n      this.retrier.failed(new Error('Skipping first attempt'));\n    });\n    this.retrier.on('failed', err => this.emit('failed', err));\n    this.usedBackoff = this.newBackoff;\n    this.newBackoff = null;\n    this.retrier.start().catch(err => {});\n  }\n\n}\n\nexports.BackoffRetrier = BackoffRetrier;","map":{"version":3,"sources":["/home/ascencion/sebrae_megahack/node_modules/twilsock/lib/backoffretrier.js"],"names":["Object","defineProperty","exports","value","events_1","require","operation_retrier_1","BackoffRetrier","EventEmitter","constructor","options","assign","inProgress","retrier","start","Error","createRetrier","stop","cleanRetrier","newBackoff","usedBackoff","modifyBackoff","delay","attemptFailed","shouldUseNewBackoff","failed","cancel","removeAllListeners","getRetryPolicy","clone","min","max","maxAttemptsCount","undefined","retryPolicy","Retrier","once","on","emit","err","catch"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst events_1 = require(\"events\");\nconst operation_retrier_1 = require(\"operation-retrier\");\n/**\n * Retrier with backoff override capability\n*/\nclass BackoffRetrier extends events_1.EventEmitter {\n    constructor(options) {\n        super();\n        this.options = options ? Object.assign({}, options) : {};\n    }\n    get inProgress() { return !!this.retrier; }\n    /**\n     * Should be called once per attempt series to start retrier.\n    */\n    start() {\n        if (this.inProgress) {\n            throw new Error('Already waiting for next attempt, call finishAttempt(success : boolean) to finish it');\n        }\n        this.createRetrier();\n    }\n    /**\n     * Should be called to stop retrier entirely.\n    */\n    stop() {\n        this.cleanRetrier();\n        this.newBackoff = null;\n        this.usedBackoff = null;\n    }\n    /**\n     * Modifies backoff for next attempt.\n     * Expected behavior:\n     * - If there was no backoff passed previously reschedulling next attempt to given backoff\n     * - If previous backoff was longer then ignoring this one.\n     * - If previous backoff was shorter then reschedulling with this one.\n     * With or without backoff retrier will keep growing normally.\n     * @param delay delay of next attempts in ms.\n     */\n    modifyBackoff(delay) {\n        this.newBackoff = delay;\n    }\n    /**\n     * Mark last emmited attempt as failed, initiating either next of fail if limits were hit.\n    */\n    attemptFailed() {\n        if (!this.inProgress) {\n            throw new Error('No attempt is in progress');\n        }\n        if (this.newBackoff) {\n            const shouldUseNewBackoff = !this.usedBackoff || this.usedBackoff < this.newBackoff;\n            if (shouldUseNewBackoff) {\n                this.createRetrier();\n            }\n            else {\n                this.retrier.failed(new Error());\n            }\n        }\n        else {\n            this.retrier.failed(new Error());\n        }\n    }\n    cancel() {\n        if (this.retrier) {\n            this.retrier.cancel();\n        }\n    }\n    cleanRetrier() {\n        if (this.retrier) {\n            this.retrier.removeAllListeners();\n            this.retrier.cancel();\n            this.retrier = null;\n        }\n    }\n    getRetryPolicy() {\n        const clone = Object.assign({}, this.options);\n        if (this.newBackoff) {\n            clone.min = this.newBackoff;\n            clone.max = this.options.max && this.options.max > this.newBackoff\n                ? this.options.max\n                : this.newBackoff;\n        }\n        // As we're always skipping first attempt we should add one extra if limit is present\n        clone.maxAttemptsCount = this.options.maxAttemptsCount\n            ? this.options.maxAttemptsCount + 1\n            : undefined;\n        return clone;\n    }\n    createRetrier() {\n        this.cleanRetrier();\n        const retryPolicy = this.getRetryPolicy();\n        this.retrier = new operation_retrier_1.Retrier(retryPolicy);\n        this.retrier.once('attempt', () => {\n            this.retrier.on('attempt', () => this.emit('attempt'));\n            this.retrier.failed(new Error('Skipping first attempt'));\n        });\n        this.retrier.on('failed', err => this.emit('failed', err));\n        this.usedBackoff = this.newBackoff;\n        this.newBackoff = null;\n        this.retrier.start()\n            .catch(err => { });\n    }\n}\nexports.BackoffRetrier = BackoffRetrier;\n"]},"metadata":{},"sourceType":"script"}