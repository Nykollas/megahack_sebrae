{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst sanitize_1 = require(\"./utils/sanitize\");\n\nconst uri_1 = require(\"./utils/uri\");\n\nconst syncerror_1 = require(\"./utils/syncerror\");\n\nconst logger_1 = require(\"./utils/logger\");\n\nconst entity_1 = require(\"./entity\");\n\nconst mapitem_1 = require(\"./mapitem\");\n\nconst paginator_1 = require(\"./paginator\");\n\nconst cache_1 = require(\"./cache\");\n\nconst mergingqueue_1 = require(\"./mergingqueue\");\n\nconst closeable_1 = require(\"./closeable\");\n\nclass SyncMapImpl extends entity_1.SyncEntity {\n  /**\n   * @private\n   */\n  constructor(services, descriptor, removalHandler) {\n    super(services, removalHandler);\n\n    const updateRequestReducer = (acc, input) => typeof input.ttl === 'number' ? {\n      ttl: input.ttl\n    } : acc;\n\n    this.updateMergingQueue = new mergingqueue_1.NamespacedMergingQueue(updateRequestReducer);\n    this.cache = new cache_1.Cache();\n    this.descriptor = descriptor;\n    this.descriptor.date_updated = new Date(this.descriptor.date_updated);\n\n    if (descriptor.items) {\n      descriptor.items.forEach(itemDescriptor => {\n        itemDescriptor.date_updated = new Date(itemDescriptor.date_updated);\n        this.cache.store(itemDescriptor.key, new mapitem_1.MapItem(itemDescriptor), itemDescriptor.last_event_id);\n      });\n    }\n  } // private props\n\n\n  get uri() {\n    return this.descriptor.url;\n  }\n\n  get links() {\n    return this.descriptor.links;\n  }\n\n  get revision() {\n    return this.descriptor.revision;\n  }\n\n  get lastEventId() {\n    return this.descriptor.last_event_id;\n  }\n\n  get dateExpires() {\n    return this.descriptor.date_expires;\n  }\n\n  static get type() {\n    return 'map';\n  }\n\n  get type() {\n    return 'map';\n  } // below properties are specific to Insights only\n\n\n  get indexName() {\n    return undefined;\n  }\n\n  get queryString() {\n    return undefined;\n  } // public props, documented along with class description\n\n\n  get sid() {\n    return this.descriptor.sid;\n  }\n\n  get uniqueName() {\n    return this.descriptor.unique_name || null;\n  }\n\n  get dateUpdated() {\n    return this.descriptor.date_updated;\n  }\n\n  async set(key, value, itemMetadataUpdates) {\n    const input = itemMetadataUpdates || {};\n    sanitize_1.validateOptionalTtl(input.ttl);\n    return this.updateMergingQueue.squashAndAdd(key, input, input => this._putItemUnconditionally(key, value, input.ttl));\n  }\n\n  async get(key) {\n    if (this.cache.has(key)) {\n      return this.cache.get(key);\n    } else {\n      return this._getItemFromServer(key);\n    }\n  }\n\n  async _getItemFromServer(key) {\n    let result = await this.queryItems({\n      key: key\n    });\n\n    if (result.items.length < 1) {\n      throw new syncerror_1.SyncError(`No item with key ${key} found`, 404, 54201);\n    } else {\n      return result.items[0];\n    }\n  }\n\n  async mutate(key, mutator, itemMetadataUpdates) {\n    const input = itemMetadataUpdates || {};\n    sanitize_1.validateOptionalTtl(input.ttl);\n    return this.updateMergingQueue.add(key, input, input => this._putItemWithIfMatch(key, mutator, input.ttl));\n  }\n\n  async update(key, obj, itemMetadataUpdates) {\n    return this.mutate(key, remote => Object.assign(remote, obj), itemMetadataUpdates);\n  }\n\n  async _putItemUnconditionally(key, data, ttl) {\n    const result = await this._putItemToServer(key, data, undefined, ttl);\n    const item = result.item;\n\n    this._handleItemMutated(item.key, item.url, item.last_event_id, item.revision, item.data, item.date_updated, item.date_expires, result.added, false);\n\n    return this.cache.get(item.key);\n  }\n\n  async _putItemWithIfMatch(key, mutatorFunction, ttl) {\n    const currentItem = await this.get(key).catch(error => {\n      if (error.status === 404) {\n        // PUT /Items/myKey with `If-Match: -1` acts as \"put if not exists\"\n        return new mapitem_1.MapItem({\n          key: key,\n          data: {},\n          last_event_id: -1,\n          revision: '-1',\n          url: null,\n          date_updated: null,\n          date_expires: null\n        });\n      } else {\n        throw error;\n      }\n    });\n    let data = mutatorFunction(sanitize_1.deepClone(currentItem.value));\n\n    if (data) {\n      let ifMatch = currentItem.revision;\n\n      try {\n        const result = await this._putItemToServer(key, data, ifMatch, ttl);\n        const item = result.item;\n\n        this._handleItemMutated(item.key, item.url, item.last_event_id, item.revision, item.data, item.date_updated, item.date_expires, result.added, false);\n\n        return this.cache.get(item.key);\n      } catch (error) {\n        if (error.status === 412) {\n          await this._getItemFromServer(key);\n          return this._putItemWithIfMatch(key, mutatorFunction, ttl);\n        } else {\n          throw error;\n        }\n      }\n    } else {\n      return currentItem;\n    }\n  }\n\n  async _putItemToServer(key, data, ifMatch, ttl) {\n    const url = new uri_1.UriBuilder(this.links.items).pathSegment(key).build();\n    const requestBody = {\n      data\n    };\n\n    if (ttl !== undefined) {\n      requestBody.ttl = ttl;\n    }\n\n    try {\n      const response = await this.services.network.put(url, requestBody, ifMatch);\n      const mapItemDescriptor = response.body;\n      mapItemDescriptor.data = data; // The server does not return the data in the response\n\n      mapItemDescriptor.date_updated = new Date(mapItemDescriptor.date_updated);\n      const added = response.status.code === 201;\n      return {\n        added,\n        item: mapItemDescriptor\n      };\n    } catch (error) {\n      if (error.status === 404) {\n        this.onRemoved(false);\n      }\n\n      throw error;\n    }\n  }\n\n  async remove(key) {\n    if (typeof key === 'undefined') {\n      throw new Error('Key argument is invalid');\n    }\n\n    let item = await this.get(key);\n    let response = await this.services.network.delete(item.uri);\n\n    this._handleItemRemoved(key, response.body.last_event_id, undefined, new Date(response.body.date_updated), false);\n  }\n  /**\n   * @private\n   */\n\n\n  async queryItems(args) {\n    args = args || {};\n    const uri = new uri_1.UriBuilder(this.links.items).queryParam('From', args.from).queryParam('PageSize', args.limit).queryParam('Key', args.key).queryParam('PageToken', args.pageToken).queryParam('Order', args.order).build();\n    let response = await this.services.network.get(uri);\n    let items = response.body.items.map(el => {\n      el.date_updated = new Date(el.date_updated);\n      let itemInCache = this.cache.get(el.key);\n\n      if (itemInCache) {\n        this._handleItemMutated(el.key, el.url, el.last_event_id, el.revision, el.data, el.date_updated, el.date_expires, false, true);\n      } else {\n        this.cache.store(el.key, new mapitem_1.MapItem(el), el.last_event_id);\n      }\n\n      return this.cache.get(el.key);\n    });\n    const meta = response.body.meta;\n    return new paginator_1.Paginator(items, pageToken => this.queryItems({\n      pageToken\n    }), meta.previous_token, meta.next_token);\n  }\n\n  async getItems(args) {\n    args = args || {};\n    sanitize_1.validatePageSize(args.pageSize);\n    args.limit = args.pageSize || args.limit || 50;\n    args.order = args.order || 'asc';\n    return this.queryItems(args);\n  }\n\n  shouldIgnoreEvent(key, eventId) {\n    return this.cache.isKnown(key, eventId);\n  }\n  /**\n   * Handle update from the server\n   * @private\n   */\n\n\n  _update(update, isStrictlyOrdered) {\n    update.date_created = new Date(update.date_created);\n\n    switch (update.type) {\n      case 'map_item_added':\n      case 'map_item_updated':\n        {\n          this._handleItemMutated(update.item_key, update.item_url, update.id, update.item_revision, update.item_data, update.date_created, undefined, // orchestration events do not include date_expires\n          update.type === 'map_item_added', true);\n        }\n        break;\n\n      case 'map_item_removed':\n        {\n          this._handleItemRemoved(update.item_key, update.id, update.item_data, update.date_created, true);\n        }\n        break;\n\n      case 'map_removed':\n        {\n          this.onRemoved(false);\n        }\n        break;\n    }\n\n    if (isStrictlyOrdered) {\n      this._advanceLastEventId(update.id, update.map_revision);\n    }\n  }\n\n  _advanceLastEventId(eventId, revision) {\n    if (this.lastEventId < eventId) {\n      this.descriptor.last_event_id = eventId;\n\n      if (revision) {\n        this.descriptor.revision = revision;\n      }\n    }\n  }\n\n  _updateRootDateUpdated(dateUpdated) {\n    if (!this.descriptor.date_updated || dateUpdated.getTime() > this.descriptor.date_updated.getTime()) {\n      this.descriptor.date_updated = dateUpdated;\n      this.services.storage.update(this.type, this.sid, this.uniqueName, {\n        date_updated: dateUpdated\n      });\n    }\n  }\n\n  _handleItemMutated(key, url, lastEventId, revision, value, dateUpdated, dateExpires, added, remote) {\n    if (this.shouldIgnoreEvent(key, lastEventId)) {\n      logger_1.default.trace('Item ', key, ' update skipped, current:', this.lastEventId, ', remote:', lastEventId);\n      return;\n    } else {\n      this._updateRootDateUpdated(dateUpdated);\n\n      let item = this.cache.get(key);\n\n      if (!item) {\n        item = new mapitem_1.MapItem({\n          key: key,\n          url,\n          last_event_id: lastEventId,\n          revision,\n          data: value,\n          date_updated: dateUpdated,\n          date_expires: dateExpires\n        });\n        this.cache.store(key, item, lastEventId);\n        this.emitItemMutationEvent(item, remote, added);\n      } else {\n        item.update(lastEventId, revision, value, dateUpdated);\n        this.cache.store(key, item, lastEventId);\n\n        if (dateExpires !== undefined) {\n          item.updateDateExpires(dateExpires);\n        }\n\n        this.emitItemMutationEvent(item, remote, false);\n      }\n    }\n  }\n\n  emitItemMutationEvent(item, remote, added) {\n    let eventName = added ? 'itemAdded' : 'itemUpdated';\n    this.broadcastEventToListeners(eventName, {\n      item: item,\n      isLocal: !remote\n    });\n  }\n  /**\n   * @private\n   */\n\n\n  _handleItemRemoved(key, eventId, oldData, dateUpdated, remote) {\n    this._updateRootDateUpdated(dateUpdated);\n\n    this.cache.delete(key, eventId);\n    this.broadcastEventToListeners('itemRemoved', {\n      key: key,\n      isLocal: !remote,\n      value: oldData\n    });\n  }\n\n  onRemoved(locally) {\n    this._unsubscribe();\n\n    this.removalHandler(this.type, this.sid, this.uniqueName);\n    this.broadcastEventToListeners('removed', {\n      isLocal: locally\n    });\n  }\n\n  async setTtl(ttl) {\n    sanitize_1.validateMandatoryTtl(ttl);\n\n    try {\n      const requestBody = {\n        ttl\n      };\n      const response = await this.services.network.post(this.uri, requestBody);\n      this.descriptor.date_expires = response.body.date_expires;\n    } catch (error) {\n      if (error.status === 404) {\n        this.onRemoved(false);\n      }\n\n      throw error;\n    }\n  }\n\n  async setItemTtl(key, ttl) {\n    sanitize_1.validateMandatoryTtl(ttl);\n    let existingItem = await this.get(key);\n    const requestBody = {\n      ttl\n    };\n    const response = await this.services.network.post(existingItem.uri, requestBody);\n    existingItem.updateDateExpires(response.body.date_expires);\n  }\n\n  async removeMap() {\n    await this.services.network.delete(this.uri);\n    this.onRemoved(true);\n  }\n\n}\n\nexports.SyncMapImpl = SyncMapImpl;\n/**\n * @class\n * @alias Map\n * @classdesc Represents a Sync Map, which stores an unordered set of key:value pairs.\n * Use the {@link Client#map} method to obtain a reference to a Sync Map.\n * @property {String} sid An immutable identifier (a SID) assigned by the system on creation.\n * @property {String} [uniqueName=null] - An optional immutable identifier that may be assigned by the\n * programmer to this map on creation. Unique among other Maps.\n * @property {Date} dateUpdated Date when the Map was last updated.\n *\n * @fires Map#removed\n * @fires Map#itemAdded\n * @fires Map#itemRemoved\n * @fires Map#itemUpdated\n */\n\nclass SyncMap extends closeable_1.Closeable {\n  constructor(syncMapImpl) {\n    super();\n    this.syncMapImpl = syncMapImpl;\n    this.syncMapImpl.attach(this);\n  } // private props\n\n\n  get uri() {\n    return this.syncMapImpl.uri;\n  }\n\n  get links() {\n    return this.syncMapImpl.links;\n  }\n\n  get revision() {\n    return this.syncMapImpl.revision;\n  }\n\n  get lastEventId() {\n    return this.syncMapImpl.lastEventId;\n  }\n\n  get dateExpires() {\n    return this.syncMapImpl.dateExpires;\n  }\n\n  static get type() {\n    return SyncMapImpl.type;\n  }\n\n  get type() {\n    return SyncMapImpl.type;\n  } // public props, documented along with class description\n\n\n  get sid() {\n    return this.syncMapImpl.sid;\n  }\n\n  get uniqueName() {\n    return this.syncMapImpl.uniqueName;\n  }\n\n  get dateUpdated() {\n    return this.syncMapImpl.dateUpdated;\n  }\n  /**\n   * Add a new item to the map with the given key:value pair. Overwrites any value that might already exist at that key.\n   * @param {String} key Unique item identifier.\n   * @param {Object} value Value to be set.\n   * @param {Map#ItemMetadata} [itemMetadataUpdates] New item metadata.\n   * @returns {Promise<MapItem>} Newly added item, or modified one if already exists, with the latest known value.\n   * @public\n   * @example\n   * map.set('myKey', { name: 'John Smith' }, { ttl: 86400 })\n   *   .then(function(item) {\n   *     console.log('Map Item set() successful, item value:', item.value);\n   *   })\n   *   .catch(function(error) {\n   *     console.error('Map Item set() failed', error);\n   *   });\n   */\n\n\n  async set(key, value, itemMetadataUpdates) {\n    this.ensureNotClosed();\n    return this.syncMapImpl.set(key, value, itemMetadataUpdates);\n  }\n  /**\n   * Retrieve an item by key.\n   * @param {String} key Identifies the desired item.\n   * @returns {Promise<MapItem>} A promise that resolves when the item has been fetched.\n   * This promise will be rejected if item was not found.\n   * @public\n   * @example\n   * map.get('myKey')\n   *   .then(function(item) {\n   *     console.log('Map Item get() successful, item value:', item.value)\n   *   })\n   *   .catch(function(error) {\n   *     console.error('Map Item get() failed', error);\n   *   });\n   */\n\n\n  async get(key) {\n    this.ensureNotClosed();\n    return this.syncMapImpl.get(key);\n  }\n  /**\n   * Schedules a modification to this Map Item that will apply a mutation function.\n   * If no Item with the given key exists, it will first be created, having the default value (<code>{}</code>).\n   * @param {String} key Selects the map item to be mutated.\n   * @param {Map~Mutator} mutator A function that outputs a new value based on the existing value.\n   * May be called multiple times, particularly if this Map Item is modified concurrently by remote code.\n   * If the mutation ultimately succeeds, the Map Item will have made the particular transition described\n   * by this function.\n   * @param {Map#ItemMetadata} [itemMetadataUpdates] New item metadata.\n   * @returns {Promise<MapItem>} Resolves with the most recent item state, the output of a successful\n   * mutation or a state that prompted graceful cancellation (mutator returned <code>null</code>).\n   * @public\n   * @example\n   * var mutatorFunction = function(currentValue) {\n   *     currentValue.viewCount = (currentValue.viewCount || 0) + 1;\n   *     return currentValue;\n   * };\n   * map.mutate('myKey', mutatorFunction, { ttl: 86400 })\n   *   .then(function(item) {\n   *     console.log('Map Item mutate() successful, new value:', item.value)\n   *   })\n   *   .catch(function(error) {\n   *     console.error('Map Item mutate() failed', error);\n   *   });\n   */\n\n\n  async mutate(key, mutator, itemMetadataUpdates) {\n    this.ensureNotClosed();\n    return this.syncMapImpl.mutate(key, mutator, itemMetadataUpdates);\n  }\n  /**\n   * Modify a map item by appending new fields (or by overwriting existing ones) with the values from\n   * the provided Object. Creates a new item if no item by this key exists, copying all given fields and values\n   * into it.\n   * This is equivalent to\n   * <pre>\n   * map.mutate('myKey', function(currentValue) {\n   *   return Object.assign(currentValue, obj));\n   * });\n   * </pre>\n   * @param {String} key Selects the map item to update.\n   * @param {Object} obj Specifies the particular (top-level) attributes that will receive new values.\n   * @param {Map#ItemMetadata} [itemMetadataUpdates] New item metadata.\n   * @returns {Promise<MapItem>} A promise resolving to the modified item in its new state.\n   * @public\n   * @example\n   * // Say, the Map Item (key: 'myKey') value is { name: 'John Smith' }\n   * map.update('myKey', { age: 34 }, { ttl: 86400 })\n   *   .then(function(item) {\n   *     // Now the Map Item value is { name: 'John Smith', age: 34 }\n   *     console.log('Map Item update() successful, new value:', item.value);\n   *   })\n   *   .catch(function(error) {\n   *     console.error('Map Item update() failed', error);\n   *   });\n   */\n\n\n  async update(key, obj, itemMetadataUpdates) {\n    this.ensureNotClosed();\n    return this.syncMapImpl.update(key, obj, itemMetadataUpdates);\n  }\n  /**\n   * Delete an item, given its key.\n   * @param {String} key Selects the item to delete.\n   * @returns {Promise<void>} A promise to remove an item.\n   * The promise will be rejected if 'key' is undefined or an item was not found.\n   * @public\n   * @example\n   * map.remove('myKey')\n   *   .then(function() {\n   *     console.log('Map Item remove() successful');\n   *   })\n   *   .catch(function(error) {\n   *     console.error('Map Item remove() failed', error);\n   *   });\n   */\n\n\n  async remove(key) {\n    this.ensureNotClosed();\n    return this.syncMapImpl.remove(key);\n  }\n  /**\n   * Get a complete list of items from the map.\n   * @param {Object} [args] Arguments for query.\n   * @param {String} [args.from] Item key, which should be used as the offset. If undefined, starts from the beginning or end depending on args.order.\n   * @param {Number} [args.pageSize=50] Result page size.\n   * @param {'asc'|'desc'} [args.order='asc'] Lexicographical order of results.\n   * @return {Promise<Paginator<MapItem>>}\n   * @public\n   * @example\n   * var pageHandler = function(paginator) {\n   *   paginator.items.forEach(function(item) {\n   *     console.log('Item ' + item.key + ': ', item.value);\n   *   });\n   *   return paginator.hasNextPage ? paginator.nextPage().then(pageHandler)\n   *                                : null;\n   * };\n   * map.getItems({ from: 'myKey', order: 'asc' })\n   *   .then(pageHandler)\n   *   .catch(function(error) {\n   *     console.error('Map getItems() failed', error);\n   *   });\n   */\n\n\n  async getItems(args) {\n    this.ensureNotClosed();\n    return this.syncMapImpl.getItems(args);\n  }\n  /**\n   * Update the time-to-live of the map.\n   * @param {Number} ttl Specifies the TTL in seconds after which the map is subject to automatic deletion. The value 0 means infinity.\n   * @return {Promise<void>} A promise that resolves after the TTL update was successful.\n   * @public\n   * @example\n   * map.setTtl(3600)\n   *   .then(function() {\n   *     console.log('Map setTtl() successful');\n   *   })\n   *   .catch(function(error) {\n   *     console.error('Map setTtl() failed', error);\n   *   });\n   */\n\n\n  async setTtl(ttl) {\n    this.ensureNotClosed();\n    return this.syncMapImpl.setTtl(ttl);\n  }\n  /**\n   * Update the time-to-live of a map item.\n   * @param {Number} key Item key.\n   * @param {Number} ttl Specifies the TTL in seconds after which the map item is subject to automatic deletion. The value 0 means infinity.\n   * @return {Promise<void>} A promise that resolves after the TTL update was successful.\n   * @public\n   * @example\n   * map.setItemTtl('myKey', 86400)\n   *   .then(function() {\n   *     console.log('Map setItemTtl() successful');\n   *   })\n   *   .catch(function(error) {\n   *     console.error('Map setItemTtl() failed', error);\n   *   });\n   */\n\n\n  async setItemTtl(key, ttl) {\n    this.ensureNotClosed();\n    return this.syncMapImpl.setItemTtl(key, ttl);\n  }\n  /**\n   * Delete this map. It will be impossible to restore it.\n   * @return {Promise<void>} A promise that resolves when the map has been deleted.\n   * @public\n   * @example\n   * map.removeMap()\n   *   .then(function() {\n   *     console.log('Map removeMap() successful');\n   *   })\n   *   .catch(function(error) {\n   *     console.error('Map removeMap() failed', error);\n   *   });\n   */\n\n\n  async removeMap() {\n    this.ensureNotClosed();\n    await this.syncMapImpl.removeMap();\n  }\n  /**\n   * Conclude work with the map instance and remove all event listeners attached to it.\n   * Any subsequent operation on this object will be rejected with error.\n   * Other local copies of this map will continue operating and receiving events normally.\n   * @public\n   * @example\n   * map.close();\n   */\n\n\n  close() {\n    super.close();\n    this.syncMapImpl.detach(this.listenerUuid);\n  }\n\n}\n\nexports.SyncMap = SyncMap;\nexports.default = SyncMap;\n/**\n * Contains Map Item metadata.\n * @typedef {Object} Map#ItemMetadata\n * @property {Number} [ttl] Specifies the time-to-live in seconds after which the map item is subject to automatic deletion.\n * The value 0 means infinity.\n */\n\n/**\n * Applies a transformation to the item value. May be called multiple times on the\n * same datum in case of collisions with remote code.\n * @callback Map~Mutator\n * @param {Object} currentValue The current value of the item in the cloud.\n * @return {Object} The desired new value for the item or <code>null</code> to gracefully cancel the mutation.\n */\n\n/**\n * Fired when a new item appears in the map, whether its creator was local or remote.\n * @event Map#itemAdded\n * @param {Object} args Arguments provided with the event.\n * @param {MapItem} args.item Added item.\n * @param {Boolean} args.isLocal Equals 'true' if item was added by local actor, 'false' otherwise.\n * @example\n * map.on('itemAdded', function(args) {\n *   console.log('Map item ' + args.item.key + ' was added');\n *   console.log('args.item.value:', args.item.value);\n *   console.log('args.isLocal:', args.isLocal);\n * });\n */\n\n/**\n * Fired when a map item is updated (not added or removed, but changed), whether the updater was local or remote.\n * @event Map#itemUpdated\n * @param {Object} args Arguments provided with the event.\n * @param {MapItem} args.item Updated item.\n * @param {Boolean} args.isLocal Equals 'true' if item was updated by local actor, 'false' otherwise.\n * @example\n * map.on('itemUpdated', function(args) {\n *   console.log('Map item ' + args.item.key + ' was updated');\n *   console.log('args.item.value:', args.item.value);\n *   console.log('args.isLocal:', args.isLocal);\n * });\n */\n\n/**\n * Fired when a map item is removed, whether the remover was local or remote.\n * @event Map#itemRemoved\n * @param {Object} args Arguments provided with the event.\n * @param {String} args.key The key of the removed item.\n * @param {Boolean} args.isLocal Equals 'true' if item was removed by local actor, 'false' otherwise.\n * @param {Object} args.value In case item was removed by a remote actor, contains a snapshot of item data before removal.\n * @example\n * map.on('itemRemoved', function(args) {\n *   console.log('Map item ' + args.key + ' was removed');\n *   console.log('args.value:', args.value);\n *   console.log('args.isLocal:', args.isLocal);\n * });\n */\n\n/**\n * Fired when a map is deleted entirely, by any actor local or remote.\n * @event Map#removed\n * @param {Object} args Arguments provided with the event.\n * @param {Boolean} args.isLocal Equals 'true' if map was removed by local actor, 'false' otherwise.\n * @example\n * map.on('removed', function(args) {\n *   console.log('Map ' + map.sid + ' was removed');\n *   console.log('args.isLocal:', args.isLocal);\n * });\n */","map":{"version":3,"sources":["/home/ascencion/sebrae_megahack/node_modules/twilio-sync/lib/syncmap.js"],"names":["Object","defineProperty","exports","value","sanitize_1","require","uri_1","syncerror_1","logger_1","entity_1","mapitem_1","paginator_1","cache_1","mergingqueue_1","closeable_1","SyncMapImpl","SyncEntity","constructor","services","descriptor","removalHandler","updateRequestReducer","acc","input","ttl","updateMergingQueue","NamespacedMergingQueue","cache","Cache","date_updated","Date","items","forEach","itemDescriptor","store","key","MapItem","last_event_id","uri","url","links","revision","lastEventId","dateExpires","date_expires","type","indexName","undefined","queryString","sid","uniqueName","unique_name","dateUpdated","set","itemMetadataUpdates","validateOptionalTtl","squashAndAdd","_putItemUnconditionally","get","has","_getItemFromServer","result","queryItems","length","SyncError","mutate","mutator","add","_putItemWithIfMatch","update","obj","remote","assign","data","_putItemToServer","item","_handleItemMutated","added","mutatorFunction","currentItem","catch","error","status","deepClone","ifMatch","UriBuilder","pathSegment","build","requestBody","response","network","put","mapItemDescriptor","body","code","onRemoved","remove","Error","delete","_handleItemRemoved","args","queryParam","from","limit","pageToken","order","map","el","itemInCache","meta","Paginator","previous_token","next_token","getItems","validatePageSize","pageSize","shouldIgnoreEvent","eventId","isKnown","_update","isStrictlyOrdered","date_created","item_key","item_url","id","item_revision","item_data","_advanceLastEventId","map_revision","_updateRootDateUpdated","getTime","storage","default","trace","emitItemMutationEvent","updateDateExpires","eventName","broadcastEventToListeners","isLocal","oldData","locally","_unsubscribe","setTtl","validateMandatoryTtl","post","setItemTtl","existingItem","removeMap","SyncMap","Closeable","syncMapImpl","attach","ensureNotClosed","close","detach","listenerUuid"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst sanitize_1 = require(\"./utils/sanitize\");\nconst uri_1 = require(\"./utils/uri\");\nconst syncerror_1 = require(\"./utils/syncerror\");\nconst logger_1 = require(\"./utils/logger\");\nconst entity_1 = require(\"./entity\");\nconst mapitem_1 = require(\"./mapitem\");\nconst paginator_1 = require(\"./paginator\");\nconst cache_1 = require(\"./cache\");\nconst mergingqueue_1 = require(\"./mergingqueue\");\nconst closeable_1 = require(\"./closeable\");\nclass SyncMapImpl extends entity_1.SyncEntity {\n    /**\n     * @private\n     */\n    constructor(services, descriptor, removalHandler) {\n        super(services, removalHandler);\n        const updateRequestReducer = (acc, input) => (typeof input.ttl === 'number') ? { ttl: input.ttl }\n            : acc;\n        this.updateMergingQueue = new mergingqueue_1.NamespacedMergingQueue(updateRequestReducer);\n        this.cache = new cache_1.Cache();\n        this.descriptor = descriptor;\n        this.descriptor.date_updated = new Date(this.descriptor.date_updated);\n        if (descriptor.items) {\n            descriptor.items.forEach(itemDescriptor => {\n                itemDescriptor.date_updated = new Date(itemDescriptor.date_updated);\n                this.cache.store(itemDescriptor.key, new mapitem_1.MapItem(itemDescriptor), itemDescriptor.last_event_id);\n            });\n        }\n    }\n    // private props\n    get uri() {\n        return this.descriptor.url;\n    }\n    get links() {\n        return this.descriptor.links;\n    }\n    get revision() {\n        return this.descriptor.revision;\n    }\n    get lastEventId() {\n        return this.descriptor.last_event_id;\n    }\n    get dateExpires() {\n        return this.descriptor.date_expires;\n    }\n    static get type() {\n        return 'map';\n    }\n    get type() {\n        return 'map';\n    }\n    // below properties are specific to Insights only\n    get indexName() {\n        return undefined;\n    }\n    get queryString() {\n        return undefined;\n    }\n    // public props, documented along with class description\n    get sid() {\n        return this.descriptor.sid;\n    }\n    get uniqueName() {\n        return this.descriptor.unique_name || null;\n    }\n    get dateUpdated() {\n        return this.descriptor.date_updated;\n    }\n    async set(key, value, itemMetadataUpdates) {\n        const input = itemMetadataUpdates || {};\n        sanitize_1.validateOptionalTtl(input.ttl);\n        return this.updateMergingQueue.squashAndAdd(key, input, (input) => this._putItemUnconditionally(key, value, input.ttl));\n    }\n    async get(key) {\n        if (this.cache.has(key)) {\n            return this.cache.get(key);\n        }\n        else {\n            return this._getItemFromServer(key);\n        }\n    }\n    async _getItemFromServer(key) {\n        let result = await this.queryItems({ key: key });\n        if (result.items.length < 1) {\n            throw new syncerror_1.SyncError(`No item with key ${key} found`, 404, 54201);\n        }\n        else {\n            return result.items[0];\n        }\n    }\n    async mutate(key, mutator, itemMetadataUpdates) {\n        const input = itemMetadataUpdates || {};\n        sanitize_1.validateOptionalTtl(input.ttl);\n        return this.updateMergingQueue.add(key, input, (input) => this._putItemWithIfMatch(key, mutator, input.ttl));\n    }\n    async update(key, obj, itemMetadataUpdates) {\n        return this.mutate(key, remote => Object.assign(remote, obj), itemMetadataUpdates);\n    }\n    async _putItemUnconditionally(key, data, ttl) {\n        const result = await this._putItemToServer(key, data, undefined, ttl);\n        const item = result.item;\n        this._handleItemMutated(item.key, item.url, item.last_event_id, item.revision, item.data, item.date_updated, item.date_expires, result.added, false);\n        return this.cache.get(item.key);\n    }\n    async _putItemWithIfMatch(key, mutatorFunction, ttl) {\n        const currentItem = await this.get(key)\n            .catch(error => {\n            if (error.status === 404) {\n                // PUT /Items/myKey with `If-Match: -1` acts as \"put if not exists\"\n                return new mapitem_1.MapItem({ key: key, data: {}, last_event_id: -1, revision: '-1', url: null, date_updated: null, date_expires: null });\n            }\n            else {\n                throw error;\n            }\n        });\n        let data = mutatorFunction(sanitize_1.deepClone(currentItem.value));\n        if (data) {\n            let ifMatch = currentItem.revision;\n            try {\n                const result = await this._putItemToServer(key, data, ifMatch, ttl);\n                const item = result.item;\n                this._handleItemMutated(item.key, item.url, item.last_event_id, item.revision, item.data, item.date_updated, item.date_expires, result.added, false);\n                return this.cache.get(item.key);\n            }\n            catch (error) {\n                if (error.status === 412) {\n                    await this._getItemFromServer(key);\n                    return this._putItemWithIfMatch(key, mutatorFunction, ttl);\n                }\n                else {\n                    throw error;\n                }\n            }\n        }\n        else {\n            return currentItem;\n        }\n    }\n    async _putItemToServer(key, data, ifMatch, ttl) {\n        const url = new uri_1.UriBuilder(this.links.items).pathSegment(key).build();\n        const requestBody = { data };\n        if (ttl !== undefined) {\n            requestBody.ttl = ttl;\n        }\n        try {\n            const response = await this.services.network.put(url, requestBody, ifMatch);\n            const mapItemDescriptor = response.body;\n            mapItemDescriptor.data = data; // The server does not return the data in the response\n            mapItemDescriptor.date_updated = new Date(mapItemDescriptor.date_updated);\n            const added = response.status.code === 201;\n            return { added, item: mapItemDescriptor };\n        }\n        catch (error) {\n            if (error.status === 404) {\n                this.onRemoved(false);\n            }\n            throw error;\n        }\n    }\n    async remove(key) {\n        if (typeof key === 'undefined') {\n            throw new Error('Key argument is invalid');\n        }\n        let item = await this.get(key);\n        let response = await this.services.network.delete(item.uri);\n        this._handleItemRemoved(key, response.body.last_event_id, undefined, new Date(response.body.date_updated), false);\n    }\n    /**\n     * @private\n     */\n    async queryItems(args) {\n        args = args || {};\n        const uri = new uri_1.UriBuilder(this.links.items)\n            .queryParam('From', args.from)\n            .queryParam('PageSize', args.limit)\n            .queryParam('Key', args.key)\n            .queryParam('PageToken', args.pageToken)\n            .queryParam('Order', args.order)\n            .build();\n        let response = await this.services.network.get(uri);\n        let items = response.body.items.map(el => {\n            el.date_updated = new Date(el.date_updated);\n            let itemInCache = this.cache.get(el.key);\n            if (itemInCache) {\n                this._handleItemMutated(el.key, el.url, el.last_event_id, el.revision, el.data, el.date_updated, el.date_expires, false, true);\n            }\n            else {\n                this.cache.store(el.key, new mapitem_1.MapItem(el), el.last_event_id);\n            }\n            return this.cache.get(el.key);\n        });\n        const meta = response.body.meta;\n        return new paginator_1.Paginator(items, pageToken => this.queryItems({ pageToken }), meta.previous_token, meta.next_token);\n    }\n    async getItems(args) {\n        args = args || {};\n        sanitize_1.validatePageSize(args.pageSize);\n        args.limit = args.pageSize || args.limit || 50;\n        args.order = args.order || 'asc';\n        return this.queryItems(args);\n    }\n    shouldIgnoreEvent(key, eventId) {\n        return this.cache.isKnown(key, eventId);\n    }\n    /**\n     * Handle update from the server\n     * @private\n     */\n    _update(update, isStrictlyOrdered) {\n        update.date_created = new Date(update.date_created);\n        switch (update.type) {\n            case 'map_item_added':\n            case 'map_item_updated':\n                {\n                    this._handleItemMutated(update.item_key, update.item_url, update.id, update.item_revision, update.item_data, update.date_created, undefined, // orchestration events do not include date_expires\n                    update.type === 'map_item_added', true);\n                }\n                break;\n            case 'map_item_removed':\n                {\n                    this._handleItemRemoved(update.item_key, update.id, update.item_data, update.date_created, true);\n                }\n                break;\n            case 'map_removed':\n                {\n                    this.onRemoved(false);\n                }\n                break;\n        }\n        if (isStrictlyOrdered) {\n            this._advanceLastEventId(update.id, update.map_revision);\n        }\n    }\n    _advanceLastEventId(eventId, revision) {\n        if (this.lastEventId < eventId) {\n            this.descriptor.last_event_id = eventId;\n            if (revision) {\n                this.descriptor.revision = revision;\n            }\n        }\n    }\n    _updateRootDateUpdated(dateUpdated) {\n        if (!this.descriptor.date_updated || dateUpdated.getTime() > this.descriptor.date_updated.getTime()) {\n            this.descriptor.date_updated = dateUpdated;\n            this.services.storage.update(this.type, this.sid, this.uniqueName, { date_updated: dateUpdated });\n        }\n    }\n    _handleItemMutated(key, url, lastEventId, revision, value, dateUpdated, dateExpires, added, remote) {\n        if (this.shouldIgnoreEvent(key, lastEventId)) {\n            logger_1.default.trace('Item ', key, ' update skipped, current:', this.lastEventId, ', remote:', lastEventId);\n            return;\n        }\n        else {\n            this._updateRootDateUpdated(dateUpdated);\n            let item = this.cache.get(key);\n            if (!item) {\n                item = new mapitem_1.MapItem({ key: key, url, last_event_id: lastEventId, revision, data: value, date_updated: dateUpdated, date_expires: dateExpires });\n                this.cache.store(key, item, lastEventId);\n                this.emitItemMutationEvent(item, remote, added);\n            }\n            else {\n                item.update(lastEventId, revision, value, dateUpdated);\n                this.cache.store(key, item, lastEventId);\n                if (dateExpires !== undefined) {\n                    item.updateDateExpires(dateExpires);\n                }\n                this.emitItemMutationEvent(item, remote, false);\n            }\n        }\n    }\n    emitItemMutationEvent(item, remote, added) {\n        let eventName = added ? 'itemAdded' : 'itemUpdated';\n        this.broadcastEventToListeners(eventName, { item: item, isLocal: !remote });\n    }\n    /**\n     * @private\n     */\n    _handleItemRemoved(key, eventId, oldData, dateUpdated, remote) {\n        this._updateRootDateUpdated(dateUpdated);\n        this.cache.delete(key, eventId);\n        this.broadcastEventToListeners('itemRemoved', { key: key, isLocal: !remote, value: oldData });\n    }\n    onRemoved(locally) {\n        this._unsubscribe();\n        this.removalHandler(this.type, this.sid, this.uniqueName);\n        this.broadcastEventToListeners('removed', { isLocal: locally });\n    }\n    async setTtl(ttl) {\n        sanitize_1.validateMandatoryTtl(ttl);\n        try {\n            const requestBody = { ttl };\n            const response = await this.services.network.post(this.uri, requestBody);\n            this.descriptor.date_expires = response.body.date_expires;\n        }\n        catch (error) {\n            if (error.status === 404) {\n                this.onRemoved(false);\n            }\n            throw error;\n        }\n    }\n    async setItemTtl(key, ttl) {\n        sanitize_1.validateMandatoryTtl(ttl);\n        let existingItem = await this.get(key);\n        const requestBody = { ttl };\n        const response = await this.services.network.post(existingItem.uri, requestBody);\n        existingItem.updateDateExpires(response.body.date_expires);\n    }\n    async removeMap() {\n        await this.services.network.delete(this.uri);\n        this.onRemoved(true);\n    }\n}\nexports.SyncMapImpl = SyncMapImpl;\n/**\n * @class\n * @alias Map\n * @classdesc Represents a Sync Map, which stores an unordered set of key:value pairs.\n * Use the {@link Client#map} method to obtain a reference to a Sync Map.\n * @property {String} sid An immutable identifier (a SID) assigned by the system on creation.\n * @property {String} [uniqueName=null] - An optional immutable identifier that may be assigned by the\n * programmer to this map on creation. Unique among other Maps.\n * @property {Date} dateUpdated Date when the Map was last updated.\n *\n * @fires Map#removed\n * @fires Map#itemAdded\n * @fires Map#itemRemoved\n * @fires Map#itemUpdated\n */\nclass SyncMap extends closeable_1.Closeable {\n    constructor(syncMapImpl) {\n        super();\n        this.syncMapImpl = syncMapImpl;\n        this.syncMapImpl.attach(this);\n    }\n    // private props\n    get uri() {\n        return this.syncMapImpl.uri;\n    }\n    get links() {\n        return this.syncMapImpl.links;\n    }\n    get revision() {\n        return this.syncMapImpl.revision;\n    }\n    get lastEventId() {\n        return this.syncMapImpl.lastEventId;\n    }\n    get dateExpires() {\n        return this.syncMapImpl.dateExpires;\n    }\n    static get type() {\n        return SyncMapImpl.type;\n    }\n    get type() {\n        return SyncMapImpl.type;\n    }\n    // public props, documented along with class description\n    get sid() {\n        return this.syncMapImpl.sid;\n    }\n    get uniqueName() {\n        return this.syncMapImpl.uniqueName;\n    }\n    get dateUpdated() {\n        return this.syncMapImpl.dateUpdated;\n    }\n    /**\n     * Add a new item to the map with the given key:value pair. Overwrites any value that might already exist at that key.\n     * @param {String} key Unique item identifier.\n     * @param {Object} value Value to be set.\n     * @param {Map#ItemMetadata} [itemMetadataUpdates] New item metadata.\n     * @returns {Promise<MapItem>} Newly added item, or modified one if already exists, with the latest known value.\n     * @public\n     * @example\n     * map.set('myKey', { name: 'John Smith' }, { ttl: 86400 })\n     *   .then(function(item) {\n     *     console.log('Map Item set() successful, item value:', item.value);\n     *   })\n     *   .catch(function(error) {\n     *     console.error('Map Item set() failed', error);\n     *   });\n     */\n    async set(key, value, itemMetadataUpdates) {\n        this.ensureNotClosed();\n        return this.syncMapImpl.set(key, value, itemMetadataUpdates);\n    }\n    /**\n     * Retrieve an item by key.\n     * @param {String} key Identifies the desired item.\n     * @returns {Promise<MapItem>} A promise that resolves when the item has been fetched.\n     * This promise will be rejected if item was not found.\n     * @public\n     * @example\n     * map.get('myKey')\n     *   .then(function(item) {\n     *     console.log('Map Item get() successful, item value:', item.value)\n     *   })\n     *   .catch(function(error) {\n     *     console.error('Map Item get() failed', error);\n     *   });\n     */\n    async get(key) {\n        this.ensureNotClosed();\n        return this.syncMapImpl.get(key);\n    }\n    /**\n     * Schedules a modification to this Map Item that will apply a mutation function.\n     * If no Item with the given key exists, it will first be created, having the default value (<code>{}</code>).\n     * @param {String} key Selects the map item to be mutated.\n     * @param {Map~Mutator} mutator A function that outputs a new value based on the existing value.\n     * May be called multiple times, particularly if this Map Item is modified concurrently by remote code.\n     * If the mutation ultimately succeeds, the Map Item will have made the particular transition described\n     * by this function.\n     * @param {Map#ItemMetadata} [itemMetadataUpdates] New item metadata.\n     * @returns {Promise<MapItem>} Resolves with the most recent item state, the output of a successful\n     * mutation or a state that prompted graceful cancellation (mutator returned <code>null</code>).\n     * @public\n     * @example\n     * var mutatorFunction = function(currentValue) {\n     *     currentValue.viewCount = (currentValue.viewCount || 0) + 1;\n     *     return currentValue;\n     * };\n     * map.mutate('myKey', mutatorFunction, { ttl: 86400 })\n     *   .then(function(item) {\n     *     console.log('Map Item mutate() successful, new value:', item.value)\n     *   })\n     *   .catch(function(error) {\n     *     console.error('Map Item mutate() failed', error);\n     *   });\n     */\n    async mutate(key, mutator, itemMetadataUpdates) {\n        this.ensureNotClosed();\n        return this.syncMapImpl.mutate(key, mutator, itemMetadataUpdates);\n    }\n    /**\n     * Modify a map item by appending new fields (or by overwriting existing ones) with the values from\n     * the provided Object. Creates a new item if no item by this key exists, copying all given fields and values\n     * into it.\n     * This is equivalent to\n     * <pre>\n     * map.mutate('myKey', function(currentValue) {\n     *   return Object.assign(currentValue, obj));\n     * });\n     * </pre>\n     * @param {String} key Selects the map item to update.\n     * @param {Object} obj Specifies the particular (top-level) attributes that will receive new values.\n     * @param {Map#ItemMetadata} [itemMetadataUpdates] New item metadata.\n     * @returns {Promise<MapItem>} A promise resolving to the modified item in its new state.\n     * @public\n     * @example\n     * // Say, the Map Item (key: 'myKey') value is { name: 'John Smith' }\n     * map.update('myKey', { age: 34 }, { ttl: 86400 })\n     *   .then(function(item) {\n     *     // Now the Map Item value is { name: 'John Smith', age: 34 }\n     *     console.log('Map Item update() successful, new value:', item.value);\n     *   })\n     *   .catch(function(error) {\n     *     console.error('Map Item update() failed', error);\n     *   });\n     */\n    async update(key, obj, itemMetadataUpdates) {\n        this.ensureNotClosed();\n        return this.syncMapImpl.update(key, obj, itemMetadataUpdates);\n    }\n    /**\n     * Delete an item, given its key.\n     * @param {String} key Selects the item to delete.\n     * @returns {Promise<void>} A promise to remove an item.\n     * The promise will be rejected if 'key' is undefined or an item was not found.\n     * @public\n     * @example\n     * map.remove('myKey')\n     *   .then(function() {\n     *     console.log('Map Item remove() successful');\n     *   })\n     *   .catch(function(error) {\n     *     console.error('Map Item remove() failed', error);\n     *   });\n     */\n    async remove(key) {\n        this.ensureNotClosed();\n        return this.syncMapImpl.remove(key);\n    }\n    /**\n     * Get a complete list of items from the map.\n     * @param {Object} [args] Arguments for query.\n     * @param {String} [args.from] Item key, which should be used as the offset. If undefined, starts from the beginning or end depending on args.order.\n     * @param {Number} [args.pageSize=50] Result page size.\n     * @param {'asc'|'desc'} [args.order='asc'] Lexicographical order of results.\n     * @return {Promise<Paginator<MapItem>>}\n     * @public\n     * @example\n     * var pageHandler = function(paginator) {\n     *   paginator.items.forEach(function(item) {\n     *     console.log('Item ' + item.key + ': ', item.value);\n     *   });\n     *   return paginator.hasNextPage ? paginator.nextPage().then(pageHandler)\n     *                                : null;\n     * };\n     * map.getItems({ from: 'myKey', order: 'asc' })\n     *   .then(pageHandler)\n     *   .catch(function(error) {\n     *     console.error('Map getItems() failed', error);\n     *   });\n     */\n    async getItems(args) {\n        this.ensureNotClosed();\n        return this.syncMapImpl.getItems(args);\n    }\n    /**\n     * Update the time-to-live of the map.\n     * @param {Number} ttl Specifies the TTL in seconds after which the map is subject to automatic deletion. The value 0 means infinity.\n     * @return {Promise<void>} A promise that resolves after the TTL update was successful.\n     * @public\n     * @example\n     * map.setTtl(3600)\n     *   .then(function() {\n     *     console.log('Map setTtl() successful');\n     *   })\n     *   .catch(function(error) {\n     *     console.error('Map setTtl() failed', error);\n     *   });\n     */\n    async setTtl(ttl) {\n        this.ensureNotClosed();\n        return this.syncMapImpl.setTtl(ttl);\n    }\n    /**\n     * Update the time-to-live of a map item.\n     * @param {Number} key Item key.\n     * @param {Number} ttl Specifies the TTL in seconds after which the map item is subject to automatic deletion. The value 0 means infinity.\n     * @return {Promise<void>} A promise that resolves after the TTL update was successful.\n     * @public\n     * @example\n     * map.setItemTtl('myKey', 86400)\n     *   .then(function() {\n     *     console.log('Map setItemTtl() successful');\n     *   })\n     *   .catch(function(error) {\n     *     console.error('Map setItemTtl() failed', error);\n     *   });\n     */\n    async setItemTtl(key, ttl) {\n        this.ensureNotClosed();\n        return this.syncMapImpl.setItemTtl(key, ttl);\n    }\n    /**\n     * Delete this map. It will be impossible to restore it.\n     * @return {Promise<void>} A promise that resolves when the map has been deleted.\n     * @public\n     * @example\n     * map.removeMap()\n     *   .then(function() {\n     *     console.log('Map removeMap() successful');\n     *   })\n     *   .catch(function(error) {\n     *     console.error('Map removeMap() failed', error);\n     *   });\n     */\n    async removeMap() {\n        this.ensureNotClosed();\n        await this.syncMapImpl.removeMap();\n    }\n    /**\n     * Conclude work with the map instance and remove all event listeners attached to it.\n     * Any subsequent operation on this object will be rejected with error.\n     * Other local copies of this map will continue operating and receiving events normally.\n     * @public\n     * @example\n     * map.close();\n     */\n    close() {\n        super.close();\n        this.syncMapImpl.detach(this.listenerUuid);\n    }\n}\nexports.SyncMap = SyncMap;\nexports.default = SyncMap;\n/**\n * Contains Map Item metadata.\n * @typedef {Object} Map#ItemMetadata\n * @property {Number} [ttl] Specifies the time-to-live in seconds after which the map item is subject to automatic deletion.\n * The value 0 means infinity.\n */\n/**\n * Applies a transformation to the item value. May be called multiple times on the\n * same datum in case of collisions with remote code.\n * @callback Map~Mutator\n * @param {Object} currentValue The current value of the item in the cloud.\n * @return {Object} The desired new value for the item or <code>null</code> to gracefully cancel the mutation.\n */\n/**\n * Fired when a new item appears in the map, whether its creator was local or remote.\n * @event Map#itemAdded\n * @param {Object} args Arguments provided with the event.\n * @param {MapItem} args.item Added item.\n * @param {Boolean} args.isLocal Equals 'true' if item was added by local actor, 'false' otherwise.\n * @example\n * map.on('itemAdded', function(args) {\n *   console.log('Map item ' + args.item.key + ' was added');\n *   console.log('args.item.value:', args.item.value);\n *   console.log('args.isLocal:', args.isLocal);\n * });\n */\n/**\n * Fired when a map item is updated (not added or removed, but changed), whether the updater was local or remote.\n * @event Map#itemUpdated\n * @param {Object} args Arguments provided with the event.\n * @param {MapItem} args.item Updated item.\n * @param {Boolean} args.isLocal Equals 'true' if item was updated by local actor, 'false' otherwise.\n * @example\n * map.on('itemUpdated', function(args) {\n *   console.log('Map item ' + args.item.key + ' was updated');\n *   console.log('args.item.value:', args.item.value);\n *   console.log('args.isLocal:', args.isLocal);\n * });\n */\n/**\n * Fired when a map item is removed, whether the remover was local or remote.\n * @event Map#itemRemoved\n * @param {Object} args Arguments provided with the event.\n * @param {String} args.key The key of the removed item.\n * @param {Boolean} args.isLocal Equals 'true' if item was removed by local actor, 'false' otherwise.\n * @param {Object} args.value In case item was removed by a remote actor, contains a snapshot of item data before removal.\n * @example\n * map.on('itemRemoved', function(args) {\n *   console.log('Map item ' + args.key + ' was removed');\n *   console.log('args.value:', args.value);\n *   console.log('args.isLocal:', args.isLocal);\n * });\n */\n/**\n * Fired when a map is deleted entirely, by any actor local or remote.\n * @event Map#removed\n * @param {Object} args Arguments provided with the event.\n * @param {Boolean} args.isLocal Equals 'true' if map was removed by local actor, 'false' otherwise.\n * @example\n * map.on('removed', function(args) {\n *   console.log('Map ' + map.sid + ' was removed');\n *   console.log('args.isLocal:', args.isLocal);\n * });\n */\n"]},"metadata":{},"sourceType":"script"}