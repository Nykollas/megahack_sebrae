{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst logger_1 = require(\"./logger\");\n\nfunction byteLength(s) {\n  let escstr = encodeURIComponent(s);\n  let binstr = escstr.replace(/%([0-9A-F]{2})/g, (match, p1) => String.fromCharCode('0x' + p1));\n  return binstr.length;\n}\n\nfunction stringToUint8Array(s) {\n  let escstr = encodeURIComponent(s);\n  let binstr = escstr.replace(/%([0-9A-F]{2})/g, (match, p1) => String.fromCharCode('0x' + p1));\n  let ua = new Uint8Array(binstr.length);\n  Array.prototype.forEach.call(binstr, (ch, i) => {\n    ua[i] = ch.charCodeAt(0);\n  });\n  return ua;\n}\n\nfunction uint8ArrayToString(ua) {\n  let binstr = Array.prototype.map.call(ua, ch => String.fromCharCode(ch)).join('');\n  let escstr = binstr.replace(/(.)/g, (m, p) => {\n    let code = p.charCodeAt(0).toString(16).toUpperCase();\n\n    if (code.length < 2) {\n      code = '0' + code;\n    }\n\n    return '%' + code;\n  });\n  return decodeURIComponent(escstr);\n}\n\nfunction getJsonObject(array) {\n  return JSON.parse(uint8ArrayToString(array));\n}\n\nfunction getMagic(buffer) {\n  let strMagic = '';\n  let idx = 0;\n\n  for (; idx < buffer.length; ++idx) {\n    const chr = String.fromCharCode(buffer[idx]);\n    strMagic += chr;\n\n    if (chr === '\\r') {\n      idx += 2;\n      break;\n    }\n  }\n\n  const magics = strMagic.split(' ');\n  return {\n    size: idx,\n    protocol: magics[0],\n    version: magics[1],\n    headerSize: Number(magics[2])\n  };\n}\n\nclass Parser {\n  constructor() {}\n\n  static parse(message) {\n    const fieldMargin = 2;\n    const dataView = new Uint8Array(message);\n    const magic = getMagic(dataView);\n\n    if (magic.protocol !== 'TWILSOCK' || magic.version !== 'V3.0') {\n      logger_1.log.error(`unsupported protocol: ${magic.protocol} ver ${magic.version}`); //throw new Error('Unsupported protocol');\n      //this.fsm.unsupportedProtocol();\n\n      return;\n    }\n\n    let header = null;\n\n    try {\n      header = getJsonObject(dataView.subarray(magic.size, magic.size + magic.headerSize));\n    } catch (e) {\n      logger_1.log.error('failed to parse message header', e, message); //throw new Error('Failed to parse message');\n      //this.fsm.protocolError();\n\n      return;\n    }\n\n    logger_1.log.debug('message received: ', header.method);\n    logger_1.log.trace('message received: ', header);\n    let payload = null;\n\n    if (header.payload_size > 0) {\n      const payloadOffset = fieldMargin + magic.size + magic.headerSize;\n      const payloadSize = header.payload_size;\n\n      if (!header.hasOwnProperty('payload_type') || header.payload_type.indexOf('application/json') === 0) {\n        try {\n          payload = getJsonObject(dataView.subarray(payloadOffset, payloadOffset + payloadSize));\n        } catch (e) {\n          logger_1.log.error('failed to parse message body', e, message); //this.fsm.protocolError();\n\n          return;\n        }\n      } else if (header.payload_type.indexOf('text/plain') === 0) {\n        payload = uint8ArrayToString(dataView.subarray(payloadOffset, payloadOffset + payloadSize));\n      }\n    }\n\n    return {\n      method: header.method,\n      header,\n      payload\n    };\n  }\n\n  static createPacket(header, payloadString = '') {\n    header.payload_size = byteLength(payloadString); // eslint-disable-line camelcase\n\n    let headerString = JSON.stringify(header) + '\\r\\n';\n    let magicString = 'TWILSOCK V3.0 ' + (byteLength(headerString) - 2) + '\\r\\n';\n    logger_1.log.debug('send request:', magicString + headerString + payloadString);\n    let message = stringToUint8Array(magicString + headerString + payloadString);\n    return message.buffer;\n  }\n\n}\n\nexports.Parser = Parser;","map":{"version":3,"sources":["/home/ascencion/sebrae_megahack/node_modules/twilsock/lib/parser.js"],"names":["Object","defineProperty","exports","value","logger_1","require","byteLength","s","escstr","encodeURIComponent","binstr","replace","match","p1","String","fromCharCode","length","stringToUint8Array","ua","Uint8Array","Array","prototype","forEach","call","ch","i","charCodeAt","uint8ArrayToString","map","join","m","p","code","toString","toUpperCase","decodeURIComponent","getJsonObject","array","JSON","parse","getMagic","buffer","strMagic","idx","chr","magics","split","size","protocol","version","headerSize","Number","Parser","constructor","message","fieldMargin","dataView","magic","log","error","header","subarray","e","debug","method","trace","payload","payload_size","payloadOffset","payloadSize","hasOwnProperty","payload_type","indexOf","createPacket","payloadString","headerString","stringify","magicString"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst logger_1 = require(\"./logger\");\nfunction byteLength(s) {\n    let escstr = encodeURIComponent(s);\n    let binstr = escstr.replace(/%([0-9A-F]{2})/g, (match, p1) => String.fromCharCode('0x' + p1));\n    return binstr.length;\n}\nfunction stringToUint8Array(s) {\n    let escstr = encodeURIComponent(s);\n    let binstr = escstr.replace(/%([0-9A-F]{2})/g, (match, p1) => String.fromCharCode('0x' + p1));\n    let ua = new Uint8Array(binstr.length);\n    Array.prototype.forEach.call(binstr, (ch, i) => { ua[i] = ch.charCodeAt(0); });\n    return ua;\n}\nfunction uint8ArrayToString(ua) {\n    let binstr = Array.prototype.map.call(ua, ch => String.fromCharCode(ch)).join('');\n    let escstr = binstr.replace(/(.)/g, (m, p) => {\n        let code = p.charCodeAt(0).toString(16).toUpperCase();\n        if (code.length < 2) {\n            code = '0' + code;\n        }\n        return '%' + code;\n    });\n    return decodeURIComponent(escstr);\n}\nfunction getJsonObject(array) {\n    return JSON.parse(uint8ArrayToString(array));\n}\nfunction getMagic(buffer) {\n    let strMagic = '';\n    let idx = 0;\n    for (; idx < buffer.length; ++idx) {\n        const chr = String.fromCharCode(buffer[idx]);\n        strMagic += chr;\n        if (chr === '\\r') {\n            idx += 2;\n            break;\n        }\n    }\n    const magics = strMagic.split(' ');\n    return {\n        size: idx,\n        protocol: magics[0],\n        version: magics[1],\n        headerSize: Number(magics[2])\n    };\n}\nclass Parser {\n    constructor() { }\n    static parse(message) {\n        const fieldMargin = 2;\n        const dataView = new Uint8Array(message);\n        const magic = getMagic(dataView);\n        if (magic.protocol !== 'TWILSOCK' || magic.version !== 'V3.0') {\n            logger_1.log.error(`unsupported protocol: ${magic.protocol} ver ${magic.version}`);\n            //throw new Error('Unsupported protocol');\n            //this.fsm.unsupportedProtocol();\n            return;\n        }\n        let header = null;\n        try {\n            header = getJsonObject(dataView.subarray(magic.size, magic.size + magic.headerSize));\n        }\n        catch (e) {\n            logger_1.log.error('failed to parse message header', e, message);\n            //throw new Error('Failed to parse message');\n            //this.fsm.protocolError();\n            return;\n        }\n        logger_1.log.debug('message received: ', header.method);\n        logger_1.log.trace('message received: ', header);\n        let payload = null;\n        if (header.payload_size > 0) {\n            const payloadOffset = fieldMargin + magic.size + magic.headerSize;\n            const payloadSize = header.payload_size;\n            if (!header.hasOwnProperty('payload_type') || header.payload_type.indexOf('application/json') === 0) {\n                try {\n                    payload = getJsonObject(dataView.subarray(payloadOffset, payloadOffset + payloadSize));\n                }\n                catch (e) {\n                    logger_1.log.error('failed to parse message body', e, message);\n                    //this.fsm.protocolError();\n                    return;\n                }\n            }\n            else if (header.payload_type.indexOf('text/plain') === 0) {\n                payload = uint8ArrayToString(dataView.subarray(payloadOffset, payloadOffset + payloadSize));\n            }\n        }\n        return { method: header.method, header, payload };\n    }\n    static createPacket(header, payloadString = '') {\n        header.payload_size = byteLength(payloadString); // eslint-disable-line camelcase\n        let headerString = JSON.stringify(header) + '\\r\\n';\n        let magicString = 'TWILSOCK V3.0 ' + (byteLength(headerString) - 2) + '\\r\\n';\n        logger_1.log.debug('send request:', magicString + headerString + payloadString);\n        let message = stringToUint8Array(magicString + headerString + payloadString);\n        return message.buffer;\n    }\n}\nexports.Parser = Parser;\n"]},"metadata":{},"sourceType":"script"}