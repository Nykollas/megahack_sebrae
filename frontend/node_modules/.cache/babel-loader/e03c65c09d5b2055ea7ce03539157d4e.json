{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst events_1 = require(\"events\");\n\nconst StateMachine = require(\"javascript-state-machine\");\n\nconst logger_1 = require(\"./logger\");\n\nconst Messages = require(\"./protocol/messages\");\n\nconst parser_1 = require(\"./parser\");\n\nconst twilsockreplyerror_1 = require(\"./error/twilsockreplyerror\");\n\nconst backoffretrier_1 = require(\"./backoffretrier\");\n\nconst DISCONNECTING_TIMEOUT = 3000; // Wraps asynchronous rescheduling\n// Just makes it simpler to find these hacks over the code\n\nfunction trampoline(f) {\n  setTimeout(f, 0);\n}\n/**\n * Makes sure that body is properly stringified\n */\n\n\nfunction preparePayload(payload) {\n  switch (typeof payload) {\n    case 'undefined':\n      return '';\n\n    case 'object':\n      return JSON.stringify(payload);\n\n    default:\n      return payload;\n  }\n}\n\nclass Request {}\n\nclass Response {}\n\nexports.Response = Response;\n/**\n * Twilsock channel level protocol implementation\n */\n\nclass TwilsockChannel extends events_1.EventEmitter {\n  constructor(websocket, transport, config) {\n    super();\n    this.terminalStates = ['disconnected', 'rejected'];\n    this.lastEmittedState = undefined;\n    this.tokenExpiredSasCode = 20104;\n    this.terminationReason = 'Connection is not initialized';\n    this.websocket = websocket;\n    this.websocket.on('connected', () => this.fsm.socketConnected());\n    this.websocket.on('disconnected', e => this.fsm.socketClosed());\n    this.websocket.on('message', message => this.onIncomingMessage(message));\n    this.websocket.on('socketError', e => this.emit('connectionError', {\n      terminal: false,\n      message: e.message,\n      httpStatusCode: null,\n      errorCode: null\n    }));\n    this.transport = transport;\n    this.config = config;\n    this.retrier = new backoffretrier_1.BackoffRetrier(config.retryPolicy);\n    this.retrier.on('attempt', () => this.retry());\n    this.retrier.on('failed', err => {\n      logger_1.log.warn(`Retrying failed: ${err.message}`);\n      this.disconnect();\n    });\n\n    if (typeof window !== 'undefined' && typeof window.addEventListener !== 'undefined') {\n      window.addEventListener('online', () => {\n        logger_1.log.debug('Browser reported connectivity state: online');\n        this.fsm.systemOnline();\n      });\n      window.addEventListener('offline', () => {\n        logger_1.log.debug('Browser reported connectivity state: offline');\n        this.websocket.close();\n        this.fsm.socketClosed();\n      });\n    }\n\n    this.fsm = new StateMachine({\n      init: 'disconnected',\n      transitions: [{\n        name: 'userConnect',\n        from: ['disconnected', 'rejected'],\n        to: 'connecting'\n      }, {\n        name: 'userConnect',\n        from: ['connecting', 'connected']\n      }, {\n        name: 'userDisconnect',\n        from: ['connecting', 'initialising', 'connected', 'updating', 'retrying', 'rejected', 'waitSocketClosed', 'waitOffloadSocketClosed'],\n        to: 'disconnecting'\n      }, {\n        name: 'userRetry',\n        from: ['retrying'],\n        to: 'connecting'\n      }, {\n        name: 'socketConnected',\n        from: ['connecting'],\n        to: 'initialising'\n      }, {\n        name: 'socketClosed',\n        from: ['connecting', 'initialising', 'connected', 'updating', 'error', 'waitOffloadSocketClosed'],\n        to: 'retrying'\n      }, {\n        name: 'socketClosed',\n        from: ['disconnecting'],\n        to: 'disconnected'\n      }, {\n        name: 'socketClosed',\n        from: ['waitSocketClosed'],\n        to: 'disconnected'\n      }, {\n        name: 'socketClosed',\n        from: ['rejected'],\n        to: 'rejected'\n      }, {\n        name: 'initSuccess',\n        from: ['initialising'],\n        to: 'connected'\n      }, {\n        name: 'initError',\n        from: ['initialising'],\n        to: 'error'\n      }, {\n        name: 'tokenRejected',\n        from: ['initialising', 'updating'],\n        to: 'rejected'\n      }, {\n        name: 'protocolError',\n        from: ['initialising', 'connected', 'updating'],\n        to: 'error'\n      }, {\n        name: 'receiveClose',\n        from: ['initialising', 'connected', 'updating'],\n        to: 'waitSocketClosed'\n      }, {\n        name: 'receiveOffload',\n        from: ['initialising', 'connected', 'updating'],\n        to: 'waitOffloadSocketClosed'\n      }, {\n        name: 'unsupportedProtocol',\n        from: ['initialising', 'connected', 'updating'],\n        to: 'unsupported'\n      }, {\n        name: 'receiveFatalClose',\n        from: ['initialising', 'connected', 'updating'],\n        to: 'unsupported'\n      }, {\n        name: 'userUpdateToken',\n        from: ['disconnected', 'rejected', 'connecting', 'retrying'],\n        to: 'connecting'\n      }, {\n        name: 'userUpdateToken',\n        from: ['connected'],\n        to: 'updating'\n      }, {\n        name: 'updateSuccess',\n        from: ['updating'],\n        to: 'connected'\n      }, {\n        name: 'updateError',\n        from: ['updating'],\n        to: 'error'\n      }, {\n        name: 'userSend',\n        from: ['connected'],\n        to: 'connected'\n      }, {\n        name: 'systemOnline',\n        from: ['retrying'],\n        to: 'connecting'\n      }],\n      methods: {\n        onConnecting: () => {\n          this.setupSocket();\n          this.emit('connecting');\n        },\n        onEnterInitialising: () => {\n          this.sendInit();\n        },\n        onLeaveInitialising: () => {\n          this.cancelInit();\n        },\n        onEnterUpdating: () => {\n          this.sendUpdate();\n        },\n        onLeaveUpdating: () => {\n          this.cancelUpdate();\n        },\n        onEnterRetrying: () => {\n          this.initRetry();\n          this.emit('connecting');\n        },\n        onEnterConnected: () => {\n          this.resetBackoff();\n          this.onConnected();\n        },\n        onUserUpdateToken: () => {\n          this.resetBackoff();\n        },\n        onTokenRejected: () => {\n          this.resetBackoff();\n          this.closeSocket(true);\n          this.finalizeSocket();\n        },\n        onUserDisconnect: () => {\n          this.closeSocket(true);\n        },\n        onEnterDisconnecting: () => {\n          this.startDisconnectTimer();\n        },\n        onLeaveDisconnecting: () => {\n          this.cancelDisconnectTimer();\n        },\n        onEnterWaitSocketClosed: () => {\n          this.startDisconnectTimer();\n        },\n        onLeaveWaitSocketClosed: () => {\n          this.cancelDisconnectTimer();\n        },\n        onEnterWaitOffloadSocketClosed: () => {\n          this.startDisconnectTimer();\n        },\n        onLeaveWaitOffloadSocketClosed: () => {\n          this.cancelDisconnectTimer();\n        },\n        onDisconnected: () => {\n          this.resetBackoff();\n          this.finalizeSocket();\n        },\n        onReceiveClose: (event, args) => {\n          this.onCloseReceived(args);\n        },\n        onReceiveOffload: (event, args) => {\n          logger_1.log.debug('onreceiveoffload: ', args);\n          this.modifyBackoff(args.body);\n          this.onCloseReceived(args.status);\n        },\n        onUnsupported: () => {\n          this.closeSocket(true);\n          this.finalizeSocket();\n        },\n        onError: (lifecycle, graceful) => {\n          this.closeSocket(graceful);\n          this.finalizeSocket();\n        },\n        onEnterState: event => {\n          if (event.from !== 'none') {\n            this.changeState(event);\n          }\n        },\n        onInvalidTransition: (transition, from, to) => {\n          logger_1.log.warn('FSM: unexpected transition', from, to);\n        }\n      }\n    });\n  }\n\n  changeState(event) {\n    logger_1.log.debug(`FSM: ${event.transition}: ${event.from} --> ${event.to}`);\n\n    if (this.lastEmittedState !== this.state) {\n      this.lastEmittedState = this.state;\n      this.emit('stateChanged', this.state);\n    }\n  }\n\n  resetBackoff() {\n    logger_1.log.trace('resetBackoff');\n    this.retrier.stop();\n  }\n\n  modifyBackoff(body) {\n    logger_1.log.trace('modifyBackoff', body);\n    let backoffPolicy = body ? body.backoff_policy : null;\n\n    if (backoffPolicy && typeof backoffPolicy.reconnect_min_ms === 'number') {\n      this.retrier.modifyBackoff(backoffPolicy.reconnect_min_ms);\n    }\n  }\n\n  startDisconnectTimer() {\n    logger_1.log.trace('startDisconnectTimer');\n\n    if (this.disconnectingTimer) {\n      clearTimeout(this.disconnectingTimer);\n      this.disconnectingTimer = null;\n    }\n\n    this.disconnectingTimer = setTimeout(() => {\n      logger_1.log.debug('disconnecting is timed out');\n      this.closeSocket(true);\n    }, DISCONNECTING_TIMEOUT);\n  }\n\n  cancelDisconnectTimer() {\n    logger_1.log.trace('cancelDisconnectTimer');\n\n    if (this.disconnectingTimer) {\n      clearTimeout(this.disconnectingTimer);\n      this.disconnectingTimer = null;\n    }\n  }\n\n  get isConnected() {\n    return this.state === 'connected' && this.websocket.isConnected;\n  }\n\n  get state() {\n    switch (this.fsm.state) {\n      case 'connecting':\n      case 'initialising':\n      case 'retrying':\n      case 'error':\n        return 'connecting';\n\n      case 'updating':\n      case 'connected':\n        return 'connected';\n\n      case 'rejected':\n        return 'rejected';\n\n      case 'disconnecting':\n      case 'waitSocketClosed':\n      case 'waitOffloadSocketClosed':\n        return 'disconnecting';\n\n      case 'disconnected':\n      default:\n        return 'disconnected';\n    }\n  }\n\n  initRetry() {\n    logger_1.log.debug('initRetry');\n\n    if (this.retrier.inProgress) {\n      this.retrier.attemptFailed();\n    } else {\n      this.retrier.start();\n    }\n  }\n\n  retry() {\n    if (this.fsm.state != 'connecting') {\n      logger_1.log.trace('retry');\n      this.websocket.close();\n      this.fsm.userRetry();\n    } else {\n      logger_1.log.trace('can\\t retry as already connecting');\n    }\n  }\n\n  onConnected() {\n    this.emit('connected');\n  }\n\n  finalizeSocket() {\n    logger_1.log.trace('finalizeSocket');\n    this.websocket.close();\n    this.emit('disconnected');\n\n    if (this.disconnectedPromiseResolve) {\n      this.disconnectedPromiseResolve();\n      this.disconnectedPromiseResolve = null;\n    }\n  }\n\n  setupSocket() {\n    logger_1.log.trace('setupSocket:', this.config.token);\n    this.websocket.connect();\n  }\n\n  onIncomingMessage(message) {\n    let {\n      method,\n      header,\n      payload\n    } = parser_1.Parser.parse(message);\n\n    if (method !== 'reply') {\n      this.confirmReceiving(header);\n    }\n\n    if (method === 'notification') {\n      this.emit('message', header.message_type, payload);\n    } else if (header.method === 'reply') {\n      this.transport.processReply({\n        id: header.id,\n        status: header.status,\n        header: header,\n        body: payload\n      });\n    } else if (header.method === 'client_update') {\n      if (header.client_update_type === 'token_about_to_expire') {\n        this.emit('tokenAboutToExpire');\n      }\n    } else if (header.method === 'close') {\n      if (header.status.code === 308) {\n        logger_1.log.debug('Connection has been offloaded');\n        this.fsm.receiveOffload({\n          status: header.status.status,\n          body: payload\n        });\n      } else if (header.status.code === 406) {\n        // Not acceptable message\n        const message = `Server closed connection because can't parse protocol: ${JSON.stringify(header.status)}`;\n        this.emitReplyConnectionError(message, header, true);\n        logger_1.log.error(message);\n        this.fsm.receiveFatalClose();\n      } else if (header.status.code === 417) {\n        // Protocol error\n        logger_1.log.error(`Server closed connection because can't parse client reply: ${JSON.stringify(header.status)}`);\n        this.fsm.receiveFatalClose(header.status.status);\n      } else if (header.status.code === 410) {\n        // Expired token\n        logger_1.log.warn(`Server closed connection: ${JSON.stringify(header.status)}`);\n        this.fsm.receiveClose(header.status.status);\n        this.emit('tokenExpired');\n      } else if (header.status.code === 401) {\n        // Authentication fail\n        logger_1.log.error(`Server closed connection: ${JSON.stringify(header.status)}`);\n        this.fsm.receiveClose(header.status.status);\n      } else {\n        logger_1.log.warn('unexpected message: ', header.status); // Try to reconnect\n\n        this.fsm.receiveOffload({\n          status: header.status.status,\n          body: null\n        });\n      }\n    }\n  }\n\n  async sendInit() {\n    logger_1.log.trace('sendInit');\n\n    try {\n      let reply = await this.transport.sendInit();\n      this.config.updateContinuationToken(reply.continuationToken);\n      this.fsm.initSuccess(reply);\n      this.emit('initialized', reply);\n      this.emit('tokenUpdated');\n    } catch (ex) {\n      if (ex instanceof twilsockreplyerror_1.TwilsockReplyError) {\n        let isTerminalError = false;\n        logger_1.log.warn(`Init rejected by server: ${JSON.stringify(ex.reply.status)}`);\n\n        if (ex.reply.status.code === 401 || ex.reply.status.code === 403) {\n          isTerminalError = true;\n          this.fsm.tokenRejected(ex.reply.status);\n\n          if (ex.reply.status.errorCode === this.tokenExpiredSasCode) {\n            this.emit('tokenExpired');\n          }\n        } else if (ex.reply.status.code === 429) {\n          this.modifyBackoff(ex.reply.body);\n          this.fsm.initError(true);\n        } else if (ex.reply.status.code === 500) {\n          this.fsm.initError(false);\n        } else {\n          this.fsm.initError(true);\n        }\n\n        this.emitReplyConnectionError(ex.message, ex.reply, isTerminalError);\n      } else {\n        this.terminationReason = ex.message;\n        this.emit('connectionError', {\n          terminal: true,\n          message: ex.message,\n          httpStatusCode: null,\n          errorCode: null\n        });\n        this.fsm.initError(true);\n      }\n\n      this.emit('tokenUpdated', ex);\n    }\n  }\n\n  async sendUpdate() {\n    logger_1.log.trace('sendUpdate');\n    let message = new Messages.Update(this.config.token);\n\n    try {\n      let reply = await this.transport.sendWithReply(message);\n      this.fsm.updateSuccess(reply.body);\n      this.emit('tokenUpdated');\n    } catch (ex) {\n      if (ex instanceof twilsockreplyerror_1.TwilsockReplyError) {\n        let isTerminalError = false;\n        logger_1.log.warn(`Token update rejected by server: ${JSON.stringify(ex.reply.status)}`);\n\n        if (ex.reply.status.code === 401 || ex.reply.status.code === 403) {\n          isTerminalError = true;\n          this.fsm.tokenRejected(ex.reply.status);\n\n          if (ex.reply.status.errorCode === this.tokenExpiredSasCode) {\n            this.emit('tokenExpired');\n          }\n        } else if (ex.reply.status.code === 429) {\n          this.modifyBackoff(ex.reply.body);\n          this.fsm.updateError(ex.reply.status);\n        } else {\n          this.fsm.updateError(ex.reply.status);\n        }\n\n        this.emitReplyConnectionError(ex.message, ex.reply, isTerminalError);\n      } else {\n        this.emit('error', false, ex.message, null, null);\n        this.fsm.updateError(ex);\n      }\n\n      this.emit('tokenUpdated', ex);\n    }\n  }\n\n  emitReplyConnectionError(message, header, terminal) {\n    const description = header.status && header.status.description ? header.status.description : message;\n    const httpStatusCode = header.status.code;\n    const errorCode = header.status && header.status.errorCode ? header.status.errorCode : null;\n\n    if (terminal) {\n      this.terminationReason = description;\n    }\n\n    this.emit('connectionError', {\n      terminal: terminal,\n      message: description,\n      httpStatusCode: httpStatusCode,\n      errorCode: errorCode\n    });\n  }\n\n  cancelInit() {\n    logger_1.log.trace('cancelInit'); // TODO: implement\n  }\n\n  cancelUpdate() {\n    logger_1.log.trace('cancelUpdate'); // TODO: implement\n  }\n  /**\n   * Should be called for each message to confirm it received\n   */\n\n\n  confirmReceiving(messageHeader) {\n    logger_1.log.trace('confirmReceiving');\n\n    try {\n      this.transport.send(new Messages.Reply(messageHeader.id));\n    } catch (e) {\n      logger_1.log.debug('failed to confirm packet receiving', e);\n    }\n  }\n  /**\n   * Shutdown connection\n   */\n\n\n  closeSocket(graceful) {\n    logger_1.log.trace(`closeSocket (graceful: ${graceful})`);\n\n    if (graceful && this.transport.isConnected) {\n      this.transport.sendClose();\n    }\n\n    this.websocket.close();\n    trampoline(() => this.fsm.socketClosed());\n  }\n  /**\n   * Initiate the twilsock connection\n   * If already connected, it does nothing\n   */\n\n\n  connect() {\n    logger_1.log.trace('connect');\n    this.fsm.userConnect();\n  }\n  /**\n   * Close twilsock connection\n   * If already disconnected, it does nothing\n   */\n\n\n  disconnect() {\n    logger_1.log.trace('disconnect');\n\n    if (this.fsm.is('disconnected')) {\n      return Promise.resolve();\n    }\n\n    return new Promise(resolve => {\n      this.disconnectedPromiseResolve = resolve;\n      this.fsm.userDisconnect();\n    });\n  }\n  /**\n   * Update fpa token for twilsock connection\n   */\n\n\n  updateToken(token) {\n    logger_1.log.trace('updateToken:', token);\n    return new Promise((resolve, reject) => {\n      this.once('tokenUpdated', e => {\n        if (e) {\n          reject(e);\n        } else {\n          resolve();\n        }\n      });\n      this.fsm.userUpdateToken();\n    });\n  }\n\n  get isTerminalState() {\n    return this.terminalStates.indexOf(this.fsm.state) !== -1;\n  }\n\n  get getTerminationReason() {\n    return this.terminationReason;\n  }\n\n  onCloseReceived(reason) {\n    this.websocket.close();\n  }\n\n}\n\nexports.TwilsockChannel = TwilsockChannel;\nexports.TwilsockImpl = TwilsockChannel;","map":{"version":3,"sources":["/home/ascencion/sebrae_megahack/node_modules/twilsock/lib/twilsock.js"],"names":["Object","defineProperty","exports","value","events_1","require","StateMachine","logger_1","Messages","parser_1","twilsockreplyerror_1","backoffretrier_1","DISCONNECTING_TIMEOUT","trampoline","f","setTimeout","preparePayload","payload","JSON","stringify","Request","Response","TwilsockChannel","EventEmitter","constructor","websocket","transport","config","terminalStates","lastEmittedState","undefined","tokenExpiredSasCode","terminationReason","on","fsm","socketConnected","e","socketClosed","message","onIncomingMessage","emit","terminal","httpStatusCode","errorCode","retrier","BackoffRetrier","retryPolicy","retry","err","log","warn","disconnect","window","addEventListener","debug","systemOnline","close","init","transitions","name","from","to","methods","onConnecting","setupSocket","onEnterInitialising","sendInit","onLeaveInitialising","cancelInit","onEnterUpdating","sendUpdate","onLeaveUpdating","cancelUpdate","onEnterRetrying","initRetry","onEnterConnected","resetBackoff","onConnected","onUserUpdateToken","onTokenRejected","closeSocket","finalizeSocket","onUserDisconnect","onEnterDisconnecting","startDisconnectTimer","onLeaveDisconnecting","cancelDisconnectTimer","onEnterWaitSocketClosed","onLeaveWaitSocketClosed","onEnterWaitOffloadSocketClosed","onLeaveWaitOffloadSocketClosed","onDisconnected","onReceiveClose","event","args","onCloseReceived","onReceiveOffload","modifyBackoff","body","status","onUnsupported","onError","lifecycle","graceful","onEnterState","changeState","onInvalidTransition","transition","state","trace","stop","backoffPolicy","backoff_policy","reconnect_min_ms","disconnectingTimer","clearTimeout","isConnected","inProgress","attemptFailed","start","userRetry","disconnectedPromiseResolve","token","connect","method","header","Parser","parse","confirmReceiving","message_type","processReply","id","client_update_type","code","receiveOffload","emitReplyConnectionError","error","receiveFatalClose","receiveClose","reply","updateContinuationToken","continuationToken","initSuccess","ex","TwilsockReplyError","isTerminalError","tokenRejected","initError","Update","sendWithReply","updateSuccess","updateError","description","messageHeader","send","Reply","sendClose","userConnect","is","Promise","resolve","userDisconnect","updateToken","reject","once","userUpdateToken","isTerminalState","indexOf","getTerminationReason","reason","TwilsockImpl"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst events_1 = require(\"events\");\nconst StateMachine = require(\"javascript-state-machine\");\nconst logger_1 = require(\"./logger\");\nconst Messages = require(\"./protocol/messages\");\nconst parser_1 = require(\"./parser\");\nconst twilsockreplyerror_1 = require(\"./error/twilsockreplyerror\");\nconst backoffretrier_1 = require(\"./backoffretrier\");\nconst DISCONNECTING_TIMEOUT = 3000;\n// Wraps asynchronous rescheduling\n// Just makes it simpler to find these hacks over the code\nfunction trampoline(f) {\n    setTimeout(f, 0);\n}\n/**\n * Makes sure that body is properly stringified\n */\nfunction preparePayload(payload) {\n    switch (typeof payload) {\n        case 'undefined':\n            return '';\n        case 'object':\n            return JSON.stringify(payload);\n        default:\n            return payload;\n    }\n}\nclass Request {\n}\nclass Response {\n}\nexports.Response = Response;\n/**\n * Twilsock channel level protocol implementation\n */\nclass TwilsockChannel extends events_1.EventEmitter {\n    constructor(websocket, transport, config) {\n        super();\n        this.terminalStates = ['disconnected', 'rejected'];\n        this.lastEmittedState = undefined;\n        this.tokenExpiredSasCode = 20104;\n        this.terminationReason = 'Connection is not initialized';\n        this.websocket = websocket;\n        this.websocket.on('connected', () => this.fsm.socketConnected());\n        this.websocket.on('disconnected', (e) => this.fsm.socketClosed());\n        this.websocket.on('message', (message) => this.onIncomingMessage(message));\n        this.websocket.on('socketError', e => this.emit('connectionError', { terminal: false, message: e.message, httpStatusCode: null, errorCode: null }));\n        this.transport = transport;\n        this.config = config;\n        this.retrier = new backoffretrier_1.BackoffRetrier(config.retryPolicy);\n        this.retrier.on('attempt', () => this.retry());\n        this.retrier.on('failed', err => {\n            logger_1.log.warn(`Retrying failed: ${err.message}`);\n            this.disconnect();\n        });\n        if (typeof window !== 'undefined' && typeof window.addEventListener !== 'undefined') {\n            window.addEventListener('online', () => {\n                logger_1.log.debug('Browser reported connectivity state: online');\n                this.fsm.systemOnline();\n            });\n            window.addEventListener('offline', () => {\n                logger_1.log.debug('Browser reported connectivity state: offline');\n                this.websocket.close();\n                this.fsm.socketClosed();\n            });\n        }\n        this.fsm = new StateMachine({\n            init: 'disconnected',\n            transitions: [\n                { name: 'userConnect', from: ['disconnected', 'rejected'], to: 'connecting' },\n                { name: 'userConnect', from: ['connecting', 'connected'] },\n                { name: 'userDisconnect', from: ['connecting', 'initialising', 'connected', 'updating', 'retrying', 'rejected',\n                        'waitSocketClosed', 'waitOffloadSocketClosed'], to: 'disconnecting' },\n                { name: 'userRetry', from: ['retrying'], to: 'connecting' },\n                { name: 'socketConnected', from: ['connecting'], to: 'initialising' },\n                { name: 'socketClosed', from: ['connecting', 'initialising', 'connected', 'updating', 'error',\n                        'waitOffloadSocketClosed'], to: 'retrying' },\n                { name: 'socketClosed', from: ['disconnecting'], to: 'disconnected' },\n                { name: 'socketClosed', from: ['waitSocketClosed'], to: 'disconnected' },\n                { name: 'socketClosed', from: ['rejected'], to: 'rejected' },\n                { name: 'initSuccess', from: ['initialising'], to: 'connected' },\n                { name: 'initError', from: ['initialising'], to: 'error' },\n                { name: 'tokenRejected', from: ['initialising', 'updating'], to: 'rejected' },\n                { name: 'protocolError', from: ['initialising', 'connected', 'updating'], to: 'error' },\n                { name: 'receiveClose', from: ['initialising', 'connected', 'updating'], to: 'waitSocketClosed' },\n                { name: 'receiveOffload', from: ['initialising', 'connected', 'updating'], to: 'waitOffloadSocketClosed' },\n                { name: 'unsupportedProtocol', from: ['initialising', 'connected', 'updating'], to: 'unsupported' },\n                { name: 'receiveFatalClose', from: ['initialising', 'connected', 'updating'], to: 'unsupported' },\n                { name: 'userUpdateToken', from: ['disconnected', 'rejected', 'connecting', 'retrying'], to: 'connecting' },\n                { name: 'userUpdateToken', from: ['connected'], to: 'updating' },\n                { name: 'updateSuccess', from: ['updating'], to: 'connected' },\n                { name: 'updateError', from: ['updating'], to: 'error' },\n                { name: 'userSend', from: ['connected'], to: 'connected' },\n                { name: 'systemOnline', from: ['retrying'], to: 'connecting' }\n            ],\n            methods: {\n                onConnecting: () => {\n                    this.setupSocket();\n                    this.emit('connecting');\n                },\n                onEnterInitialising: () => {\n                    this.sendInit();\n                },\n                onLeaveInitialising: () => {\n                    this.cancelInit();\n                },\n                onEnterUpdating: () => {\n                    this.sendUpdate();\n                },\n                onLeaveUpdating: () => {\n                    this.cancelUpdate();\n                },\n                onEnterRetrying: () => {\n                    this.initRetry();\n                    this.emit('connecting');\n                },\n                onEnterConnected: () => {\n                    this.resetBackoff();\n                    this.onConnected();\n                },\n                onUserUpdateToken: () => {\n                    this.resetBackoff();\n                },\n                onTokenRejected: () => {\n                    this.resetBackoff();\n                    this.closeSocket(true);\n                    this.finalizeSocket();\n                },\n                onUserDisconnect: () => {\n                    this.closeSocket(true);\n                },\n                onEnterDisconnecting: () => {\n                    this.startDisconnectTimer();\n                },\n                onLeaveDisconnecting: () => {\n                    this.cancelDisconnectTimer();\n                },\n                onEnterWaitSocketClosed: () => {\n                    this.startDisconnectTimer();\n                },\n                onLeaveWaitSocketClosed: () => {\n                    this.cancelDisconnectTimer();\n                },\n                onEnterWaitOffloadSocketClosed: () => {\n                    this.startDisconnectTimer();\n                },\n                onLeaveWaitOffloadSocketClosed: () => {\n                    this.cancelDisconnectTimer();\n                },\n                onDisconnected: () => {\n                    this.resetBackoff();\n                    this.finalizeSocket();\n                },\n                onReceiveClose: (event, args) => {\n                    this.onCloseReceived(args);\n                },\n                onReceiveOffload: (event, args) => {\n                    logger_1.log.debug('onreceiveoffload: ', args);\n                    this.modifyBackoff(args.body);\n                    this.onCloseReceived(args.status);\n                },\n                onUnsupported: () => {\n                    this.closeSocket(true);\n                    this.finalizeSocket();\n                },\n                onError: (lifecycle, graceful) => {\n                    this.closeSocket(graceful);\n                    this.finalizeSocket();\n                },\n                onEnterState: event => {\n                    if (event.from !== 'none') {\n                        this.changeState(event);\n                    }\n                },\n                onInvalidTransition: (transition, from, to) => {\n                    logger_1.log.warn('FSM: unexpected transition', from, to);\n                }\n            }\n        });\n    }\n    changeState(event) {\n        logger_1.log.debug(`FSM: ${event.transition}: ${event.from} --> ${event.to}`);\n        if (this.lastEmittedState !== this.state) {\n            this.lastEmittedState = this.state;\n            this.emit('stateChanged', this.state);\n        }\n    }\n    resetBackoff() {\n        logger_1.log.trace('resetBackoff');\n        this.retrier.stop();\n    }\n    modifyBackoff(body) {\n        logger_1.log.trace('modifyBackoff', body);\n        let backoffPolicy = body ? body.backoff_policy : null;\n        if (backoffPolicy && typeof backoffPolicy.reconnect_min_ms === 'number') {\n            this.retrier.modifyBackoff(backoffPolicy.reconnect_min_ms);\n        }\n    }\n    startDisconnectTimer() {\n        logger_1.log.trace('startDisconnectTimer');\n        if (this.disconnectingTimer) {\n            clearTimeout(this.disconnectingTimer);\n            this.disconnectingTimer = null;\n        }\n        this.disconnectingTimer = setTimeout(() => {\n            logger_1.log.debug('disconnecting is timed out');\n            this.closeSocket(true);\n        }, DISCONNECTING_TIMEOUT);\n    }\n    cancelDisconnectTimer() {\n        logger_1.log.trace('cancelDisconnectTimer');\n        if (this.disconnectingTimer) {\n            clearTimeout(this.disconnectingTimer);\n            this.disconnectingTimer = null;\n        }\n    }\n    get isConnected() {\n        return this.state === 'connected' && this.websocket.isConnected;\n    }\n    get state() {\n        switch (this.fsm.state) {\n            case 'connecting':\n            case 'initialising':\n            case 'retrying':\n            case 'error':\n                return 'connecting';\n            case 'updating':\n            case 'connected':\n                return 'connected';\n            case 'rejected':\n                return 'rejected';\n            case 'disconnecting':\n            case 'waitSocketClosed':\n            case 'waitOffloadSocketClosed':\n                return 'disconnecting';\n            case 'disconnected':\n            default:\n                return 'disconnected';\n        }\n    }\n    initRetry() {\n        logger_1.log.debug('initRetry');\n        if (this.retrier.inProgress) {\n            this.retrier.attemptFailed();\n        }\n        else {\n            this.retrier.start();\n        }\n    }\n    retry() {\n        if (this.fsm.state != 'connecting') {\n            logger_1.log.trace('retry');\n            this.websocket.close();\n            this.fsm.userRetry();\n        }\n        else {\n            logger_1.log.trace('can\\t retry as already connecting');\n        }\n    }\n    onConnected() {\n        this.emit('connected');\n    }\n    finalizeSocket() {\n        logger_1.log.trace('finalizeSocket');\n        this.websocket.close();\n        this.emit('disconnected');\n        if (this.disconnectedPromiseResolve) {\n            this.disconnectedPromiseResolve();\n            this.disconnectedPromiseResolve = null;\n        }\n    }\n    setupSocket() {\n        logger_1.log.trace('setupSocket:', this.config.token);\n        this.websocket.connect();\n    }\n    onIncomingMessage(message) {\n        let { method, header, payload } = parser_1.Parser.parse(message);\n        if (method !== 'reply') {\n            this.confirmReceiving(header);\n        }\n        if (method === 'notification') {\n            this.emit('message', header.message_type, payload);\n        }\n        else if (header.method === 'reply') {\n            this.transport.processReply({\n                id: header.id,\n                status: header.status,\n                header: header,\n                body: payload\n            });\n        }\n        else if (header.method === 'client_update') {\n            if (header.client_update_type === 'token_about_to_expire') {\n                this.emit('tokenAboutToExpire');\n            }\n        }\n        else if (header.method === 'close') {\n            if (header.status.code === 308) {\n                logger_1.log.debug('Connection has been offloaded');\n                this.fsm.receiveOffload({ status: header.status.status, body: payload });\n            }\n            else if (header.status.code === 406) { // Not acceptable message\n                const message = `Server closed connection because can't parse protocol: ${JSON.stringify(header.status)}`;\n                this.emitReplyConnectionError(message, header, true);\n                logger_1.log.error(message);\n                this.fsm.receiveFatalClose();\n            }\n            else if (header.status.code === 417) { // Protocol error\n                logger_1.log.error(`Server closed connection because can't parse client reply: ${JSON.stringify(header.status)}`);\n                this.fsm.receiveFatalClose(header.status.status);\n            }\n            else if (header.status.code === 410) { // Expired token\n                logger_1.log.warn(`Server closed connection: ${JSON.stringify(header.status)}`);\n                this.fsm.receiveClose(header.status.status);\n                this.emit('tokenExpired');\n            }\n            else if (header.status.code === 401) { // Authentication fail\n                logger_1.log.error(`Server closed connection: ${JSON.stringify(header.status)}`);\n                this.fsm.receiveClose(header.status.status);\n            }\n            else {\n                logger_1.log.warn('unexpected message: ', header.status);\n                // Try to reconnect\n                this.fsm.receiveOffload({ status: header.status.status, body: null });\n            }\n        }\n    }\n    async sendInit() {\n        logger_1.log.trace('sendInit');\n        try {\n            let reply = await this.transport.sendInit();\n            this.config.updateContinuationToken(reply.continuationToken);\n            this.fsm.initSuccess(reply);\n            this.emit('initialized', reply);\n            this.emit('tokenUpdated');\n        }\n        catch (ex) {\n            if (ex instanceof twilsockreplyerror_1.TwilsockReplyError) {\n                let isTerminalError = false;\n                logger_1.log.warn(`Init rejected by server: ${JSON.stringify(ex.reply.status)}`);\n                if (ex.reply.status.code === 401 || ex.reply.status.code === 403) {\n                    isTerminalError = true;\n                    this.fsm.tokenRejected(ex.reply.status);\n                    if (ex.reply.status.errorCode === this.tokenExpiredSasCode) {\n                        this.emit('tokenExpired');\n                    }\n                }\n                else if (ex.reply.status.code === 429) {\n                    this.modifyBackoff(ex.reply.body);\n                    this.fsm.initError(true);\n                }\n                else if (ex.reply.status.code === 500) {\n                    this.fsm.initError(false);\n                }\n                else {\n                    this.fsm.initError(true);\n                }\n                this.emitReplyConnectionError(ex.message, ex.reply, isTerminalError);\n            }\n            else {\n                this.terminationReason = ex.message;\n                this.emit('connectionError', { terminal: true, message: ex.message, httpStatusCode: null, errorCode: null });\n                this.fsm.initError(true);\n            }\n            this.emit('tokenUpdated', ex);\n        }\n    }\n    async sendUpdate() {\n        logger_1.log.trace('sendUpdate');\n        let message = new Messages.Update(this.config.token);\n        try {\n            let reply = await this.transport.sendWithReply(message);\n            this.fsm.updateSuccess(reply.body);\n            this.emit('tokenUpdated');\n        }\n        catch (ex) {\n            if (ex instanceof twilsockreplyerror_1.TwilsockReplyError) {\n                let isTerminalError = false;\n                logger_1.log.warn(`Token update rejected by server: ${JSON.stringify(ex.reply.status)}`);\n                if (ex.reply.status.code === 401 || ex.reply.status.code === 403) {\n                    isTerminalError = true;\n                    this.fsm.tokenRejected(ex.reply.status);\n                    if (ex.reply.status.errorCode === this.tokenExpiredSasCode) {\n                        this.emit('tokenExpired');\n                    }\n                }\n                else if (ex.reply.status.code === 429) {\n                    this.modifyBackoff(ex.reply.body);\n                    this.fsm.updateError(ex.reply.status);\n                }\n                else {\n                    this.fsm.updateError(ex.reply.status);\n                }\n                this.emitReplyConnectionError(ex.message, ex.reply, isTerminalError);\n            }\n            else {\n                this.emit('error', false, ex.message, null, null);\n                this.fsm.updateError(ex);\n            }\n            this.emit('tokenUpdated', ex);\n        }\n    }\n    emitReplyConnectionError(message, header, terminal) {\n        const description = header.status && header.status.description\n            ? header.status.description\n            : message;\n        const httpStatusCode = header.status.code;\n        const errorCode = header.status && header.status.errorCode\n            ? header.status.errorCode\n            : null;\n        if (terminal) {\n            this.terminationReason = description;\n        }\n        this.emit('connectionError', { terminal: terminal, message: description, httpStatusCode: httpStatusCode, errorCode: errorCode });\n    }\n    cancelInit() {\n        logger_1.log.trace('cancelInit');\n        // TODO: implement\n    }\n    cancelUpdate() {\n        logger_1.log.trace('cancelUpdate');\n        // TODO: implement\n    }\n    /**\n     * Should be called for each message to confirm it received\n     */\n    confirmReceiving(messageHeader) {\n        logger_1.log.trace('confirmReceiving');\n        try {\n            this.transport.send(new Messages.Reply(messageHeader.id));\n        }\n        catch (e) {\n            logger_1.log.debug('failed to confirm packet receiving', e);\n        }\n    }\n    /**\n     * Shutdown connection\n     */\n    closeSocket(graceful) {\n        logger_1.log.trace(`closeSocket (graceful: ${graceful})`);\n        if (graceful && this.transport.isConnected) {\n            this.transport.sendClose();\n        }\n        this.websocket.close();\n        trampoline(() => this.fsm.socketClosed());\n    }\n    /**\n     * Initiate the twilsock connection\n     * If already connected, it does nothing\n     */\n    connect() {\n        logger_1.log.trace('connect');\n        this.fsm.userConnect();\n    }\n    /**\n     * Close twilsock connection\n     * If already disconnected, it does nothing\n     */\n    disconnect() {\n        logger_1.log.trace('disconnect');\n        if (this.fsm.is('disconnected')) {\n            return Promise.resolve();\n        }\n        return new Promise((resolve) => {\n            this.disconnectedPromiseResolve = resolve;\n            this.fsm.userDisconnect();\n        });\n    }\n    /**\n     * Update fpa token for twilsock connection\n     */\n    updateToken(token) {\n        logger_1.log.trace('updateToken:', token);\n        return new Promise((resolve, reject) => {\n            this.once('tokenUpdated', e => {\n                if (e) {\n                    reject(e);\n                }\n                else {\n                    resolve();\n                }\n            });\n            this.fsm.userUpdateToken();\n        });\n    }\n    get isTerminalState() {\n        return this.terminalStates.indexOf(this.fsm.state) !== -1;\n    }\n    get getTerminationReason() {\n        return this.terminationReason;\n    }\n    onCloseReceived(reason) {\n        this.websocket.close();\n    }\n}\nexports.TwilsockChannel = TwilsockChannel;\nexports.TwilsockImpl = TwilsockChannel;\n"]},"metadata":{},"sourceType":"script"}