{"ast":null,"code":"'use strict';\n\nvar _slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"]) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }\n  };\n}();\n\nvar difference = require('../').difference;\n\nvar flatMap = require('../').flatMap;\n\nvar setSimulcastInMediaSection = require('./simulcast');\n\nvar ptToFixedBitrateAudioCodecName = {\n  0: 'PCMU',\n  8: 'PCMA'\n};\n/**\n * A payload type\n * @typedef {number} PT\n */\n\n/**\n * An {@link AudioCodec} or {@link VideoCodec}\n * @typedef {AudioCodec|VideoCodec} Codec\n */\n// NOTE(mmalavalli): This value is derived from the IETF spec\n// for JSEP, and it is used to convert a 'b=TIAS' value in bps\n// to a 'b=AS' value in kbps.\n// Spec: https://tools.ietf.org/html/draft-ietf-rtcweb-jsep-21#section-5.9\n\nvar RTCP_BITRATE = 16000;\n/**\n * Construct a b= line string for the given max bitrate in bps. If the modifier\n * is 'AS', then the max bitrate will be converted to kbps using the formula\n * specified in the IETF spec for JSEP mentioned above.\n * @param {string} modifier - 'AS' | 'TIAS'\n * @param {?number} maxBitrate - Max outgoing bitrate (bps)\n * @returns {?string} - If \"maxBitrate\" is null, then returns null;\n *   otherwise return the constructed b= line string\n */\n\nfunction createBLine(modifier, maxBitrate) {\n  if (!maxBitrate) {\n    return null;\n  }\n\n  return '\\r\\nb=' + modifier + ':' + (modifier === 'AS' ? Math.round((maxBitrate + RTCP_BITRATE) / 950) : maxBitrate);\n}\n/**\n * Create a Codec Map for the given m= section.\n * @param {string} section - The given m= section\n * @returns {Map<Codec, Array<PT>>}\n */\n\n\nfunction createCodecMapForMediaSection(section) {\n  return Array.from(createPtToCodecName(section)).reduce(function (codecMap, pair) {\n    var pt = pair[0];\n    var codecName = pair[1];\n    var pts = codecMap.get(codecName) || [];\n    return codecMap.set(codecName, pts.concat(pt));\n  }, new Map());\n}\n/**\n * Create a Map of MIDs to m= sections for the given SDP.\n * @param {string} sdp\n * @returns {Map<string, string>}\n */\n\n\nfunction createMidToMediaSectionMap(sdp) {\n  return getMediaSections(sdp).reduce(function (midsToMediaSections, mediaSection) {\n    var mid = getMidForMediaSection(mediaSection);\n    return mid ? midsToMediaSections.set(mid, mediaSection) : midsToMediaSections;\n  }, new Map());\n}\n/**\n * Create a Map from PTs to codec names for the given m= section.\n * @param {string} mediaSection - The given m= section.\n * @returns {Map<PT, Codec>} ptToCodecName\n */\n\n\nfunction createPtToCodecName(mediaSection) {\n  return getPayloadTypesInMediaSection(mediaSection).reduce(function (ptToCodecName, pt) {\n    var rtpmapPattern = new RegExp('a=rtpmap:' + pt + ' ([^/]+)');\n    var matches = mediaSection.match(rtpmapPattern);\n    var codecName = matches ? matches[1].toLowerCase() : ptToFixedBitrateAudioCodecName[pt] ? ptToFixedBitrateAudioCodecName[pt].toLowerCase() : '';\n    return ptToCodecName.set(pt, codecName);\n  }, new Map());\n}\n/**\n * Get the associated fmtp attributes for the given Payload Type in an m= section.\n * @param {PT} pt\n * @param {string} mediaSection\n * @returns {?object}\n */\n\n\nfunction getFmtpAttributesForPt(pt, mediaSection) {\n  // In \"a=fmtp:<pt> <name>=<value>[;<name>=<value>]*\", the regex matches the codec\n  // profile parameters expressed as name/value pairs separated by \";\".\n  var fmtpRegex = new RegExp('^a=fmtp:' + pt + ' (.+)$', 'm');\n  var matches = mediaSection.match(fmtpRegex);\n  return matches && matches[1].split(';').reduce(function (attrs, nvPair) {\n    var _nvPair$split = nvPair.split('='),\n        _nvPair$split2 = _slicedToArray(_nvPair$split, 2),\n        name = _nvPair$split2[0],\n        value = _nvPair$split2[1];\n\n    attrs[name] = isNaN(value) ? value : parseInt(value, 10);\n    return attrs;\n  }, {});\n}\n/**\n * Get the MID for the given m= section.\n * @param {string} mediaSection\n * @return {?string}\n */\n\n\nfunction getMidForMediaSection(mediaSection) {\n  // In \"a=mid:<mid>\", the regex matches <mid>.\n  var midMatches = mediaSection.match(/^a=mid:(.+)$/m);\n  return midMatches && midMatches[1];\n}\n/**\n * Get the m= sections of a particular kind and direction from an sdp.\n * @param {string} sdp - SDP string\n * @param {string} [kind] - Pattern for matching kind\n * @param {string} [direction] - Pattern for matching direction\n * @returns {Array<string>} mediaSections\n */\n\n\nfunction getMediaSections(sdp, kind, direction) {\n  return sdp.replace(/\\r\\n\\r\\n$/, '\\r\\n').split('\\r\\nm=').slice(1).map(function (mediaSection) {\n    return 'm=' + mediaSection;\n  }).filter(function (mediaSection) {\n    var kindPattern = new RegExp('m=' + (kind || '.*'), 'gm');\n    var directionPattern = new RegExp('a=' + (direction || '.*'), 'gm');\n    return kindPattern.test(mediaSection) && directionPattern.test(mediaSection);\n  });\n}\n/**\n * Get the Codec Payload Types present in the first line of the given m= section\n * @param {string} section - The m= section\n * @returns {Array<PT>} Payload Types\n */\n\n\nfunction getPayloadTypesInMediaSection(section) {\n  var mLine = section.split('\\r\\n')[0]; // In \"m=<kind> <port> <proto> <payload_type_1> <payload_type_2> ... <payload_type_n>\",\n  // the regex matches <port> and the Payload Types.\n\n  var matches = mLine.match(/([0-9]+)/g); // This should not happen, but in case there are no Payload Types in\n  // the m= line, return an empty array.\n\n  if (!matches) {\n    return [];\n  } // Since only the Payload Types are needed, we discard the <port>.\n\n\n  return matches.slice(1).map(function (match) {\n    return parseInt(match, 10);\n  });\n}\n/**\n * Create the reordered Codec Payload Types based on the preferred Codec Names.\n * @param {Map<Codec, Array<PT>>} codecMap - Codec Map\n * @param {Array<Codec>} preferredCodecs - Preferred Codec Names\n * @returns {Array<PT>} Reordered Payload Types\n */\n\n\nfunction getReorderedPayloadTypes(codecMap, preferredCodecs) {\n  preferredCodecs = preferredCodecs.map(function (codecName) {\n    return codecName.toLowerCase();\n  });\n  var preferredPayloadTypes = flatMap(preferredCodecs, function (codecName) {\n    return codecMap.get(codecName) || [];\n  });\n  var remainingCodecs = difference(Array.from(codecMap.keys()), preferredCodecs);\n  var remainingPayloadTypes = flatMap(remainingCodecs, function (codecName) {\n    return codecMap.get(codecName);\n  });\n  return preferredPayloadTypes.concat(remainingPayloadTypes);\n}\n/**\n * Set the specified max bitrate in the given m= section.\n * @param {string} modifier - 'AS' | 'TIAS'\n * @param {?number} maxBitrate - Max outgoing bitrate (bps)\n * @param {string} section - m= section string\n * @returns {string} The updated m= section\n */\n\n\nfunction setBitrateInMediaSection(modifier, maxBitrate, section) {\n  var bLine = createBLine(modifier, maxBitrate) || '';\n  var bLinePattern = /\\r\\nb=(AS|TIAS):([0-9]+)/;\n  var bLineMatched = section.match(bLinePattern);\n\n  if (!bLineMatched) {\n    return section.replace(/(\\r\\n)?$/, bLine + '$1');\n  }\n\n  var maxBitrateMatched = parseInt(bLineMatched[2], 10);\n  maxBitrate = maxBitrate || Infinity;\n  bLine = createBLine(modifier, Math.min(maxBitrateMatched, maxBitrate));\n  return section.replace(bLinePattern, bLine);\n}\n/**\n * Set maximum bitrates to the media sections in a given sdp.\n * @param {string} sdp - sdp string\n * @param {string} modifier - 'AS' | 'TIAS\"\n * @param {?number} maxAudioBitrate - Max outgoing audio bitrate (bps), null\n *   if no limit is to be applied\n * @param {?number} maxVideoBitrate - Max outgoing video bitrate (bps), null\n *   if no limit is to be applied\n * @returns {string} - The updated sdp string\n */\n\n\nfunction setBitrateParameters(sdp, modifier, maxAudioBitrate, maxVideoBitrate) {\n  var mediaSections = getMediaSections(sdp);\n  var session = sdp.split('\\r\\nm=')[0];\n  return [session].concat(mediaSections.map(function (section) {\n    // Bitrate parameters should not be applied to m=application sections\n    // or to m=(audio|video) sections that do not receive media.\n    if (!/^m=(audio|video)/.test(section) || !/a=(recvonly|sendrecv)/.test(section)) {\n      return section;\n    }\n\n    var kind = section.match(/^m=(audio|video)/)[1];\n    var maxBitrate = kind === 'audio' ? maxAudioBitrate : maxVideoBitrate;\n    return setBitrateInMediaSection(modifier, maxBitrate, section);\n  })).join('\\r\\n');\n}\n/**\n * Set the given Codec Payload Types in the first line of the given m= section.\n * @param {Array<PT>} payloadTypes - Payload Types\n * @param {string} section - Given m= section\n * @returns {string} - Updated m= section\n */\n\n\nfunction setPayloadTypesInMediaSection(payloadTypes, section) {\n  var lines = section.split('\\r\\n');\n  var mLine = lines[0];\n  var otherLines = lines.slice(1);\n  mLine = mLine.replace(/([0-9]+\\s?)+$/, payloadTypes.join(' '));\n  return [mLine].concat(otherLines).join('\\r\\n');\n}\n/**\n * Return a new SDP string with the re-ordered codec preferences.\n * @param {string} sdp\n * @param {Array<AudioCodec>} preferredAudioCodecs - If empty, the existing order\n *   of audio codecs is preserved\n * @param {Array<VideoCodecSettings>} preferredVideoCodecs - If empty, the\n *   existing order of video codecs is preserved\n * @returns {string} Updated SDP string\n */\n\n\nfunction setCodecPreferences(sdp, preferredAudioCodecs, preferredVideoCodecs) {\n  var mediaSections = getMediaSections(sdp);\n  var session = sdp.split('\\r\\nm=')[0];\n  return [session].concat(mediaSections.map(function (section) {\n    // Codec preferences should not be applied to m=application sections.\n    if (!/^m=(audio|video)/.test(section)) {\n      return section;\n    }\n\n    var kind = section.match(/^m=(audio|video)/)[1];\n    var codecMap = createCodecMapForMediaSection(section);\n    var preferredCodecs = kind === 'audio' ? preferredAudioCodecs : preferredVideoCodecs.map(function (codec) {\n      return codec.codec;\n    });\n    var payloadTypes = getReorderedPayloadTypes(codecMap, preferredCodecs);\n    var newSection = setPayloadTypesInMediaSection(payloadTypes, section);\n    var pcmaPayloadTypes = codecMap.get('pcma') || [];\n    var pcmuPayloadTypes = codecMap.get('pcmu') || [];\n    var fixedBitratePayloadTypes = kind === 'audio' ? new Set(pcmaPayloadTypes.concat(pcmuPayloadTypes)) : new Set();\n    return fixedBitratePayloadTypes.has(payloadTypes[0]) ? newSection.replace(/\\r\\nb=(AS|TIAS):([0-9]+)/g, '') : newSection;\n  })).join('\\r\\n');\n}\n/**\n * Return a new SDP string with simulcast settings.\n * @param {string} sdp\n * @param {'planb' | 'unified'} sdpFormat\n * @param {Map<Track.ID, TrackAttributes>} trackIdsToAttributes\n * @returns {string} Updated SDP string\n */\n\n\nfunction setSimulcast(sdp, sdpFormat, trackIdsToAttributes) {\n  var mediaSections = getMediaSections(sdp);\n  var session = sdp.split('\\r\\nm=')[0];\n  return [session].concat(mediaSections.map(function (section) {\n    section = section.replace(/\\r\\n$/, '');\n\n    if (!/^m=video/.test(section)) {\n      return section;\n    }\n\n    var codecMap = createCodecMapForMediaSection(section);\n    var payloadTypes = getPayloadTypesInMediaSection(section);\n    var vp8PayloadTypes = new Set(codecMap.get('vp8') || []);\n    var hasVP8PayloadType = payloadTypes.some(function (payloadType) {\n      return vp8PayloadTypes.has(payloadType);\n    });\n    return hasVP8PayloadType ? setSimulcastInMediaSection(section, sdpFormat, trackIdsToAttributes) : section;\n  })).concat('').join('\\r\\n');\n}\n/**\n * Get the matching Payload Types in a unified plan local m= section for a particular remote codec.\n * @param {Codec} remoteCodec\n * @param {PT} remotePt\n * @param {Map<Codec, PT>} localCodecsToPts\n * @param {string} localSection\n * @param {string} remoteSection\n * @returns {Array<PT>}\n */\n\n\nfunction unifiedPlanGetMatchingLocalPayloadTypes(remoteCodec, remotePt, localCodecsToPts, localSection, remoteSection) {\n  // If there is at most one local Payload Type that matches the remote codec, retain it.\n  var matchingLocalPts = localCodecsToPts.get(remoteCodec) || [];\n\n  if (matchingLocalPts.length <= 1) {\n    return matchingLocalPts;\n  } // If there are no fmtp attributes for the codec in the remote m= section,\n  // then we cannot get a match in the local m= section. In that case, retain\n  // all matching local Payload Types.\n\n\n  var remoteFmtpAttrs = getFmtpAttributesForPt(remotePt, remoteSection);\n\n  if (!remoteFmtpAttrs) {\n    return matchingLocalPts;\n  } // Among the matched local Payload Types, find the one that matches the remote\n  // fmtp attributes.\n\n\n  var matchinglocalPt = matchingLocalPts.find(function (localPt) {\n    var localFmtpAttrs = getFmtpAttributesForPt(localPt, localSection);\n    return localFmtpAttrs && Object.keys(remoteFmtpAttrs).every(function (attr) {\n      return remoteFmtpAttrs[attr] === localFmtpAttrs[attr];\n    });\n  }); // If none of the matched local Payload Types also have matching fmtp attributes,\n  // then retain all of them, otherwise retain only the local Payload Type that\n  // matches the remote fmtp attributes.\n\n  return typeof matchinglocalPt === 'number' ? [matchinglocalPt] : matchingLocalPts;\n}\n/**\n * Filter codecs in a local unified plan m= section based on its equivalent remote m= section.\n * @param {string} localSection\n * @param {Map<string, string>} remoteMidsToMediaSections\n * @returns {string}\n */\n\n\nfunction unifiedPlanFilterCodecsInLocalMediaSection(localSection, remoteMidsToMediaSections) {\n  // Do nothing if the local m= section represents neither audio nor video.\n  if (!/^m=(audio|video)/.test(localSection)) {\n    return localSection;\n  } // Do nothing if the local m= section does not have an equivalent remote m= section.\n\n\n  var localMid = getMidForMediaSection(localSection);\n  var remoteSection = localMid && remoteMidsToMediaSections.get(localMid);\n\n  if (!remoteSection) {\n    return localSection;\n  } // Construct a Map of the remote Payload Types to their codec names.\n\n\n  var remotePtToCodecs = createPtToCodecName(remoteSection); // Construct a Map of the local codec names to their Payload Types.\n\n  var localCodecsToPts = createCodecMapForMediaSection(localSection); // Maintain a list of local non-rtx Payload Types to retain.\n\n  var localPts = flatMap(Array.from(remotePtToCodecs), function (_ref) {\n    var _ref2 = _slicedToArray(_ref, 2),\n        remotePt = _ref2[0],\n        remoteCodec = _ref2[1];\n\n    return remoteCodec !== 'rtx' ? unifiedPlanGetMatchingLocalPayloadTypes(remoteCodec, remotePt, localCodecsToPts, localSection, remoteSection) : [];\n  }); // For each local Payload Type that will be retained, retain their\n  // corresponding rtx Payload Type if present.\n\n  var localRtxPts = localCodecsToPts.get('rtx') || []; // In \"a=fmtp:<rtxPt> apt=<apt>\", extract the codec PT <apt> associated with rtxPt.\n\n  localPts = localPts.concat(localRtxPts.filter(function (rtxPt) {\n    var fmtpAttrs = getFmtpAttributesForPt(rtxPt, localSection);\n    return fmtpAttrs && localPts.includes(fmtpAttrs.apt);\n  })); // Filter out the below mentioned attribute lines in the local m= section that\n  // do not belong to one of the local Payload Types that are to be retained.\n  // 1. \"a=rtpmap:<pt> <codec>\"\n  // 2. \"a=rtcp-fb:<pt> <attr>[ <attr>]*\"\n  // 3. \"a=fmtp:<pt> <name>=<value>[;<name>=<value>]*\"\n\n  var lines = localSection.split('\\r\\n').filter(function (line) {\n    var ptMatches = line.match(/^a=(rtpmap|fmtp|rtcp-fb):(.+) .+$/);\n    var pt = ptMatches && ptMatches[2];\n    return !ptMatches || pt && localPts.includes(parseInt(pt, 10));\n  }); // Filter the list of Payload Types in the first line of the m= section.\n\n  var orderedLocalPts = getPayloadTypesInMediaSection(localSection).filter(function (pt) {\n    return localPts.includes(pt);\n  });\n  return setPayloadTypesInMediaSection(orderedLocalPts, lines.join('\\r\\n'));\n}\n/**\n * Filter local codecs based on the remote unified plan SDP.\n * @param {string} localSdp\n * @param {string} remoteSdp\n * @returns {string} - Updated local SDP\n */\n\n\nfunction unifiedPlanFilterLocalCodecs(localSdp, remoteSdp) {\n  var localMediaSections = getMediaSections(localSdp);\n  var localSession = localSdp.split('\\r\\nm=')[0];\n  var remoteMidsToMediaSections = createMidToMediaSectionMap(remoteSdp);\n  return [localSession].concat(localMediaSections.map(function (localSection) {\n    return unifiedPlanFilterCodecsInLocalMediaSection(localSection, remoteMidsToMediaSections);\n  })).join('\\r\\n');\n}\n/**\n * Return a new SDP string after reverting simulcast for non vp8 sections in remote sdp.\n * @param localSdp - simulcast enabled local sdp\n * @param localSdpWithoutSimulcast - local sdp before simulcast was set\n * @param remoteSdp - remote sdp\n * @return {string} Updated SDP string\n */\n\n\nfunction revertSimulcastForNonVP8MediaSections(localSdp, localSdpWithoutSimulcast, remoteSdp) {\n  var remoteMidToMediaSections = createMidToMediaSectionMap(remoteSdp);\n  var localMidToMediaSectionsWithoutSimulcast = createMidToMediaSectionMap(localSdpWithoutSimulcast);\n  var mediaSections = getMediaSections(localSdp);\n  var session = localSdp.split('\\r\\nm=')[0];\n  return [session].concat(mediaSections.map(function (section) {\n    section = section.replace(/\\r\\n$/, '');\n\n    if (!/^m=video/.test(section)) {\n      return section;\n    }\n\n    var midMatches = section.match(/^a=mid:(.+)$/m);\n    var mid = midMatches && midMatches[1];\n\n    if (!mid) {\n      return section;\n    }\n\n    var remoteSection = remoteMidToMediaSections.get(mid);\n    var remotePtToCodecs = createPtToCodecName(remoteSection);\n    var remotePayloadTypes = getPayloadTypesInMediaSection(remoteSection);\n    var isVP8ThePreferredCodec = remotePayloadTypes.length && remotePtToCodecs.get(remotePayloadTypes[0]) === 'vp8';\n    return isVP8ThePreferredCodec ? section : localMidToMediaSectionsWithoutSimulcast.get(mid).replace(/\\r\\n$/, '');\n  })).concat('').join('\\r\\n');\n}\n/**\n * Add or rewrite MSIDs for new m= sections in the given Unified Plan SDP with their\n * corresponding local MediaStreamTrack IDs. These can be different when previously\n * removed MediaStreamTracks are added back (or Track IDs may not be present in the\n * SDPs at all once browsers implement the latest WebRTC spec).\n * @param {string} sdp\n * @param {Map<string, Track.ID>} activeMidsToTrackIds\n * @param {Map<Track.Kind, Array<Track.ID>>} trackIdsByKind\n * @returns {string}\n */\n\n\nfunction unifiedPlanAddOrRewriteNewTrackIds(sdp, activeMidsToTrackIds, trackIdsByKind) {\n  // NOTE(mmalavalli): The m= sections for the new MediaStreamTracks are usually\n  // present after the m= sections for the existing MediaStreamTracks, in order\n  // of addition.\n  var newMidsToTrackIds = Array.from(trackIdsByKind).reduce(function (midsToTrackIds, _ref3) {\n    var _ref4 = _slicedToArray(_ref3, 2),\n        kind = _ref4[0],\n        trackIds = _ref4[1];\n\n    var mediaSections = getMediaSections(sdp, kind, 'send(only|recv)');\n    var newMids = mediaSections.map(getMidForMediaSection).filter(function (mid) {\n      return !activeMidsToTrackIds.has(mid);\n    });\n    newMids.forEach(function (mid, i) {\n      return midsToTrackIds.set(mid, trackIds[i]);\n    });\n    return midsToTrackIds;\n  }, new Map());\n  return unifiedPlanAddOrRewriteTrackIds(sdp, newMidsToTrackIds);\n}\n/**\n * Add or rewrite MSIDs in the given Unified Plan SDP with their corresponding local\n * MediaStreamTrack IDs. These IDs need not be the same (or Track IDs may not be\n * present in the SDPs at all once browsers implement the latest WebRTC spec).\n * @param {string} sdp\n * @param {Map<string, Track.ID>} midsToTrackIds\n * @returns {string}\n */\n\n\nfunction unifiedPlanAddOrRewriteTrackIds(sdp, midsToTrackIds) {\n  var mediaSections = getMediaSections(sdp);\n  var session = sdp.split('\\r\\nm=')[0];\n  return [session].concat(mediaSections.map(function (mediaSection) {\n    // Do nothing if the m= section represents neither audio nor video.\n    if (!/^m=(audio|video)/.test(mediaSection)) {\n      return mediaSection;\n    } // This shouldn't happen, but in case there is no MID for the m= section, do nothing.\n\n\n    var mid = getMidForMediaSection(mediaSection);\n\n    if (!mid) {\n      return mediaSection;\n    } // In case there is no Track ID for the given MID in the map, do nothing.\n\n\n    var trackId = midsToTrackIds.get(mid);\n\n    if (!trackId) {\n      return mediaSection;\n    } // This shouldn't happen, but in case there is no a=msid: line, do nothing.\n\n\n    var attributes = (mediaSection.match(/^a=msid:(.+)$/m) || [])[1];\n\n    if (!attributes) {\n      return mediaSection;\n    } // If the a=msid: line contains the \"appdata\" field, then replace it with the Track ID,\n    // otherwise append the Track ID.\n\n\n    var _attributes$split = attributes.split(' '),\n        _attributes$split2 = _slicedToArray(_attributes$split, 2),\n        msid = _attributes$split2[0],\n        trackIdToRewrite = _attributes$split2[1];\n\n    var msidRegex = new RegExp('msid:' + msid + (trackIdToRewrite ? ' ' + trackIdToRewrite : '') + '$', 'gm');\n    return mediaSection.replace(msidRegex, 'msid:' + msid + ' ' + trackId);\n  })).join('\\r\\n');\n}\n\nexports.createCodecMapForMediaSection = createCodecMapForMediaSection;\nexports.createPtToCodecName = createPtToCodecName;\nexports.getMediaSections = getMediaSections;\nexports.revertSimulcastForNonVP8MediaSections = revertSimulcastForNonVP8MediaSections;\nexports.setBitrateParameters = setBitrateParameters;\nexports.setCodecPreferences = setCodecPreferences;\nexports.setSimulcast = setSimulcast;\nexports.unifiedPlanFilterLocalCodecs = unifiedPlanFilterLocalCodecs;\nexports.unifiedPlanAddOrRewriteNewTrackIds = unifiedPlanAddOrRewriteNewTrackIds;\nexports.unifiedPlanAddOrRewriteTrackIds = unifiedPlanAddOrRewriteTrackIds;","map":{"version":3,"sources":["/home/ascencion/sebrae_megahack/node_modules/twilio-video/es5/util/sdp/index.js"],"names":["_slicedToArray","sliceIterator","arr","i","_arr","_n","_d","_e","undefined","_i","Symbol","iterator","_s","next","done","push","value","length","err","Array","isArray","Object","TypeError","difference","require","flatMap","setSimulcastInMediaSection","ptToFixedBitrateAudioCodecName","RTCP_BITRATE","createBLine","modifier","maxBitrate","Math","round","createCodecMapForMediaSection","section","from","createPtToCodecName","reduce","codecMap","pair","pt","codecName","pts","get","set","concat","Map","createMidToMediaSectionMap","sdp","getMediaSections","midsToMediaSections","mediaSection","mid","getMidForMediaSection","getPayloadTypesInMediaSection","ptToCodecName","rtpmapPattern","RegExp","matches","match","toLowerCase","getFmtpAttributesForPt","fmtpRegex","split","attrs","nvPair","_nvPair$split","_nvPair$split2","name","isNaN","parseInt","midMatches","kind","direction","replace","slice","map","filter","kindPattern","directionPattern","test","mLine","getReorderedPayloadTypes","preferredCodecs","preferredPayloadTypes","remainingCodecs","keys","remainingPayloadTypes","setBitrateInMediaSection","bLine","bLinePattern","bLineMatched","maxBitrateMatched","Infinity","min","setBitrateParameters","maxAudioBitrate","maxVideoBitrate","mediaSections","session","join","setPayloadTypesInMediaSection","payloadTypes","lines","otherLines","setCodecPreferences","preferredAudioCodecs","preferredVideoCodecs","codec","newSection","pcmaPayloadTypes","pcmuPayloadTypes","fixedBitratePayloadTypes","Set","has","setSimulcast","sdpFormat","trackIdsToAttributes","vp8PayloadTypes","hasVP8PayloadType","some","payloadType","unifiedPlanGetMatchingLocalPayloadTypes","remoteCodec","remotePt","localCodecsToPts","localSection","remoteSection","matchingLocalPts","remoteFmtpAttrs","matchinglocalPt","find","localPt","localFmtpAttrs","every","attr","unifiedPlanFilterCodecsInLocalMediaSection","remoteMidsToMediaSections","localMid","remotePtToCodecs","localPts","_ref","_ref2","localRtxPts","rtxPt","fmtpAttrs","includes","apt","line","ptMatches","orderedLocalPts","unifiedPlanFilterLocalCodecs","localSdp","remoteSdp","localMediaSections","localSession","revertSimulcastForNonVP8MediaSections","localSdpWithoutSimulcast","remoteMidToMediaSections","localMidToMediaSectionsWithoutSimulcast","remotePayloadTypes","isVP8ThePreferredCodec","unifiedPlanAddOrRewriteNewTrackIds","activeMidsToTrackIds","trackIdsByKind","newMidsToTrackIds","midsToTrackIds","_ref3","_ref4","trackIds","newMids","forEach","unifiedPlanAddOrRewriteTrackIds","trackId","attributes","_attributes$split","_attributes$split2","msid","trackIdToRewrite","msidRegex","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar difference = require('../').difference;\nvar flatMap = require('../').flatMap;\nvar setSimulcastInMediaSection = require('./simulcast');\n\nvar ptToFixedBitrateAudioCodecName = {\n  0: 'PCMU',\n  8: 'PCMA'\n};\n\n/**\n * A payload type\n * @typedef {number} PT\n */\n\n/**\n * An {@link AudioCodec} or {@link VideoCodec}\n * @typedef {AudioCodec|VideoCodec} Codec\n */\n\n// NOTE(mmalavalli): This value is derived from the IETF spec\n// for JSEP, and it is used to convert a 'b=TIAS' value in bps\n// to a 'b=AS' value in kbps.\n// Spec: https://tools.ietf.org/html/draft-ietf-rtcweb-jsep-21#section-5.9\nvar RTCP_BITRATE = 16000;\n\n/**\n * Construct a b= line string for the given max bitrate in bps. If the modifier\n * is 'AS', then the max bitrate will be converted to kbps using the formula\n * specified in the IETF spec for JSEP mentioned above.\n * @param {string} modifier - 'AS' | 'TIAS'\n * @param {?number} maxBitrate - Max outgoing bitrate (bps)\n * @returns {?string} - If \"maxBitrate\" is null, then returns null;\n *   otherwise return the constructed b= line string\n */\nfunction createBLine(modifier, maxBitrate) {\n  if (!maxBitrate) {\n    return null;\n  }\n  return '\\r\\nb=' + modifier + ':' + (modifier === 'AS' ? Math.round((maxBitrate + RTCP_BITRATE) / 950) : maxBitrate);\n}\n\n/**\n * Create a Codec Map for the given m= section.\n * @param {string} section - The given m= section\n * @returns {Map<Codec, Array<PT>>}\n */\nfunction createCodecMapForMediaSection(section) {\n  return Array.from(createPtToCodecName(section)).reduce(function (codecMap, pair) {\n    var pt = pair[0];\n    var codecName = pair[1];\n    var pts = codecMap.get(codecName) || [];\n    return codecMap.set(codecName, pts.concat(pt));\n  }, new Map());\n}\n\n/**\n * Create a Map of MIDs to m= sections for the given SDP.\n * @param {string} sdp\n * @returns {Map<string, string>}\n */\nfunction createMidToMediaSectionMap(sdp) {\n  return getMediaSections(sdp).reduce(function (midsToMediaSections, mediaSection) {\n    var mid = getMidForMediaSection(mediaSection);\n    return mid ? midsToMediaSections.set(mid, mediaSection) : midsToMediaSections;\n  }, new Map());\n}\n\n/**\n * Create a Map from PTs to codec names for the given m= section.\n * @param {string} mediaSection - The given m= section.\n * @returns {Map<PT, Codec>} ptToCodecName\n */\nfunction createPtToCodecName(mediaSection) {\n  return getPayloadTypesInMediaSection(mediaSection).reduce(function (ptToCodecName, pt) {\n    var rtpmapPattern = new RegExp('a=rtpmap:' + pt + ' ([^/]+)');\n    var matches = mediaSection.match(rtpmapPattern);\n    var codecName = matches ? matches[1].toLowerCase() : ptToFixedBitrateAudioCodecName[pt] ? ptToFixedBitrateAudioCodecName[pt].toLowerCase() : '';\n    return ptToCodecName.set(pt, codecName);\n  }, new Map());\n}\n\n/**\n * Get the associated fmtp attributes for the given Payload Type in an m= section.\n * @param {PT} pt\n * @param {string} mediaSection\n * @returns {?object}\n */\nfunction getFmtpAttributesForPt(pt, mediaSection) {\n  // In \"a=fmtp:<pt> <name>=<value>[;<name>=<value>]*\", the regex matches the codec\n  // profile parameters expressed as name/value pairs separated by \";\".\n  var fmtpRegex = new RegExp('^a=fmtp:' + pt + ' (.+)$', 'm');\n  var matches = mediaSection.match(fmtpRegex);\n  return matches && matches[1].split(';').reduce(function (attrs, nvPair) {\n    var _nvPair$split = nvPair.split('='),\n        _nvPair$split2 = _slicedToArray(_nvPair$split, 2),\n        name = _nvPair$split2[0],\n        value = _nvPair$split2[1];\n\n    attrs[name] = isNaN(value) ? value : parseInt(value, 10);\n    return attrs;\n  }, {});\n}\n\n/**\n * Get the MID for the given m= section.\n * @param {string} mediaSection\n * @return {?string}\n */\nfunction getMidForMediaSection(mediaSection) {\n  // In \"a=mid:<mid>\", the regex matches <mid>.\n  var midMatches = mediaSection.match(/^a=mid:(.+)$/m);\n  return midMatches && midMatches[1];\n}\n\n/**\n * Get the m= sections of a particular kind and direction from an sdp.\n * @param {string} sdp - SDP string\n * @param {string} [kind] - Pattern for matching kind\n * @param {string} [direction] - Pattern for matching direction\n * @returns {Array<string>} mediaSections\n */\nfunction getMediaSections(sdp, kind, direction) {\n  return sdp.replace(/\\r\\n\\r\\n$/, '\\r\\n').split('\\r\\nm=').slice(1).map(function (mediaSection) {\n    return 'm=' + mediaSection;\n  }).filter(function (mediaSection) {\n    var kindPattern = new RegExp('m=' + (kind || '.*'), 'gm');\n    var directionPattern = new RegExp('a=' + (direction || '.*'), 'gm');\n    return kindPattern.test(mediaSection) && directionPattern.test(mediaSection);\n  });\n}\n\n/**\n * Get the Codec Payload Types present in the first line of the given m= section\n * @param {string} section - The m= section\n * @returns {Array<PT>} Payload Types\n */\nfunction getPayloadTypesInMediaSection(section) {\n  var mLine = section.split('\\r\\n')[0];\n\n  // In \"m=<kind> <port> <proto> <payload_type_1> <payload_type_2> ... <payload_type_n>\",\n  // the regex matches <port> and the Payload Types.\n  var matches = mLine.match(/([0-9]+)/g);\n\n  // This should not happen, but in case there are no Payload Types in\n  // the m= line, return an empty array.\n  if (!matches) {\n    return [];\n  }\n\n  // Since only the Payload Types are needed, we discard the <port>.\n  return matches.slice(1).map(function (match) {\n    return parseInt(match, 10);\n  });\n}\n\n/**\n * Create the reordered Codec Payload Types based on the preferred Codec Names.\n * @param {Map<Codec, Array<PT>>} codecMap - Codec Map\n * @param {Array<Codec>} preferredCodecs - Preferred Codec Names\n * @returns {Array<PT>} Reordered Payload Types\n */\nfunction getReorderedPayloadTypes(codecMap, preferredCodecs) {\n  preferredCodecs = preferredCodecs.map(function (codecName) {\n    return codecName.toLowerCase();\n  });\n\n  var preferredPayloadTypes = flatMap(preferredCodecs, function (codecName) {\n    return codecMap.get(codecName) || [];\n  });\n\n  var remainingCodecs = difference(Array.from(codecMap.keys()), preferredCodecs);\n  var remainingPayloadTypes = flatMap(remainingCodecs, function (codecName) {\n    return codecMap.get(codecName);\n  });\n\n  return preferredPayloadTypes.concat(remainingPayloadTypes);\n}\n\n/**\n * Set the specified max bitrate in the given m= section.\n * @param {string} modifier - 'AS' | 'TIAS'\n * @param {?number} maxBitrate - Max outgoing bitrate (bps)\n * @param {string} section - m= section string\n * @returns {string} The updated m= section\n */\nfunction setBitrateInMediaSection(modifier, maxBitrate, section) {\n  var bLine = createBLine(modifier, maxBitrate) || '';\n  var bLinePattern = /\\r\\nb=(AS|TIAS):([0-9]+)/;\n  var bLineMatched = section.match(bLinePattern);\n\n  if (!bLineMatched) {\n    return section.replace(/(\\r\\n)?$/, bLine + '$1');\n  }\n\n  var maxBitrateMatched = parseInt(bLineMatched[2], 10);\n  maxBitrate = maxBitrate || Infinity;\n  bLine = createBLine(modifier, Math.min(maxBitrateMatched, maxBitrate));\n  return section.replace(bLinePattern, bLine);\n}\n\n/**\n * Set maximum bitrates to the media sections in a given sdp.\n * @param {string} sdp - sdp string\n * @param {string} modifier - 'AS' | 'TIAS\"\n * @param {?number} maxAudioBitrate - Max outgoing audio bitrate (bps), null\n *   if no limit is to be applied\n * @param {?number} maxVideoBitrate - Max outgoing video bitrate (bps), null\n *   if no limit is to be applied\n * @returns {string} - The updated sdp string\n */\nfunction setBitrateParameters(sdp, modifier, maxAudioBitrate, maxVideoBitrate) {\n  var mediaSections = getMediaSections(sdp);\n  var session = sdp.split('\\r\\nm=')[0];\n  return [session].concat(mediaSections.map(function (section) {\n    // Bitrate parameters should not be applied to m=application sections\n    // or to m=(audio|video) sections that do not receive media.\n    if (!/^m=(audio|video)/.test(section) || !/a=(recvonly|sendrecv)/.test(section)) {\n      return section;\n    }\n    var kind = section.match(/^m=(audio|video)/)[1];\n    var maxBitrate = kind === 'audio' ? maxAudioBitrate : maxVideoBitrate;\n    return setBitrateInMediaSection(modifier, maxBitrate, section);\n  })).join('\\r\\n');\n}\n\n/**\n * Set the given Codec Payload Types in the first line of the given m= section.\n * @param {Array<PT>} payloadTypes - Payload Types\n * @param {string} section - Given m= section\n * @returns {string} - Updated m= section\n */\nfunction setPayloadTypesInMediaSection(payloadTypes, section) {\n  var lines = section.split('\\r\\n');\n  var mLine = lines[0];\n  var otherLines = lines.slice(1);\n  mLine = mLine.replace(/([0-9]+\\s?)+$/, payloadTypes.join(' '));\n  return [mLine].concat(otherLines).join('\\r\\n');\n}\n\n/**\n * Return a new SDP string with the re-ordered codec preferences.\n * @param {string} sdp\n * @param {Array<AudioCodec>} preferredAudioCodecs - If empty, the existing order\n *   of audio codecs is preserved\n * @param {Array<VideoCodecSettings>} preferredVideoCodecs - If empty, the\n *   existing order of video codecs is preserved\n * @returns {string} Updated SDP string\n */\nfunction setCodecPreferences(sdp, preferredAudioCodecs, preferredVideoCodecs) {\n  var mediaSections = getMediaSections(sdp);\n  var session = sdp.split('\\r\\nm=')[0];\n  return [session].concat(mediaSections.map(function (section) {\n    // Codec preferences should not be applied to m=application sections.\n    if (!/^m=(audio|video)/.test(section)) {\n      return section;\n    }\n    var kind = section.match(/^m=(audio|video)/)[1];\n    var codecMap = createCodecMapForMediaSection(section);\n    var preferredCodecs = kind === 'audio' ? preferredAudioCodecs : preferredVideoCodecs.map(function (codec) {\n      return codec.codec;\n    });\n    var payloadTypes = getReorderedPayloadTypes(codecMap, preferredCodecs);\n    var newSection = setPayloadTypesInMediaSection(payloadTypes, section);\n\n    var pcmaPayloadTypes = codecMap.get('pcma') || [];\n    var pcmuPayloadTypes = codecMap.get('pcmu') || [];\n    var fixedBitratePayloadTypes = kind === 'audio' ? new Set(pcmaPayloadTypes.concat(pcmuPayloadTypes)) : new Set();\n\n    return fixedBitratePayloadTypes.has(payloadTypes[0]) ? newSection.replace(/\\r\\nb=(AS|TIAS):([0-9]+)/g, '') : newSection;\n  })).join('\\r\\n');\n}\n\n/**\n * Return a new SDP string with simulcast settings.\n * @param {string} sdp\n * @param {'planb' | 'unified'} sdpFormat\n * @param {Map<Track.ID, TrackAttributes>} trackIdsToAttributes\n * @returns {string} Updated SDP string\n */\nfunction setSimulcast(sdp, sdpFormat, trackIdsToAttributes) {\n  var mediaSections = getMediaSections(sdp);\n  var session = sdp.split('\\r\\nm=')[0];\n  return [session].concat(mediaSections.map(function (section) {\n    section = section.replace(/\\r\\n$/, '');\n    if (!/^m=video/.test(section)) {\n      return section;\n    }\n    var codecMap = createCodecMapForMediaSection(section);\n    var payloadTypes = getPayloadTypesInMediaSection(section);\n    var vp8PayloadTypes = new Set(codecMap.get('vp8') || []);\n\n    var hasVP8PayloadType = payloadTypes.some(function (payloadType) {\n      return vp8PayloadTypes.has(payloadType);\n    });\n    return hasVP8PayloadType ? setSimulcastInMediaSection(section, sdpFormat, trackIdsToAttributes) : section;\n  })).concat('').join('\\r\\n');\n}\n\n/**\n * Get the matching Payload Types in a unified plan local m= section for a particular remote codec.\n * @param {Codec} remoteCodec\n * @param {PT} remotePt\n * @param {Map<Codec, PT>} localCodecsToPts\n * @param {string} localSection\n * @param {string} remoteSection\n * @returns {Array<PT>}\n */\nfunction unifiedPlanGetMatchingLocalPayloadTypes(remoteCodec, remotePt, localCodecsToPts, localSection, remoteSection) {\n  // If there is at most one local Payload Type that matches the remote codec, retain it.\n  var matchingLocalPts = localCodecsToPts.get(remoteCodec) || [];\n  if (matchingLocalPts.length <= 1) {\n    return matchingLocalPts;\n  }\n\n  // If there are no fmtp attributes for the codec in the remote m= section,\n  // then we cannot get a match in the local m= section. In that case, retain\n  // all matching local Payload Types.\n  var remoteFmtpAttrs = getFmtpAttributesForPt(remotePt, remoteSection);\n  if (!remoteFmtpAttrs) {\n    return matchingLocalPts;\n  }\n\n  // Among the matched local Payload Types, find the one that matches the remote\n  // fmtp attributes.\n  var matchinglocalPt = matchingLocalPts.find(function (localPt) {\n    var localFmtpAttrs = getFmtpAttributesForPt(localPt, localSection);\n    return localFmtpAttrs && Object.keys(remoteFmtpAttrs).every(function (attr) {\n      return remoteFmtpAttrs[attr] === localFmtpAttrs[attr];\n    });\n  });\n\n  // If none of the matched local Payload Types also have matching fmtp attributes,\n  // then retain all of them, otherwise retain only the local Payload Type that\n  // matches the remote fmtp attributes.\n  return typeof matchinglocalPt === 'number' ? [matchinglocalPt] : matchingLocalPts;\n}\n\n/**\n * Filter codecs in a local unified plan m= section based on its equivalent remote m= section.\n * @param {string} localSection\n * @param {Map<string, string>} remoteMidsToMediaSections\n * @returns {string}\n */\nfunction unifiedPlanFilterCodecsInLocalMediaSection(localSection, remoteMidsToMediaSections) {\n  // Do nothing if the local m= section represents neither audio nor video.\n  if (!/^m=(audio|video)/.test(localSection)) {\n    return localSection;\n  }\n\n  // Do nothing if the local m= section does not have an equivalent remote m= section.\n  var localMid = getMidForMediaSection(localSection);\n  var remoteSection = localMid && remoteMidsToMediaSections.get(localMid);\n  if (!remoteSection) {\n    return localSection;\n  }\n\n  // Construct a Map of the remote Payload Types to their codec names.\n  var remotePtToCodecs = createPtToCodecName(remoteSection);\n  // Construct a Map of the local codec names to their Payload Types.\n  var localCodecsToPts = createCodecMapForMediaSection(localSection);\n  // Maintain a list of local non-rtx Payload Types to retain.\n  var localPts = flatMap(Array.from(remotePtToCodecs), function (_ref) {\n    var _ref2 = _slicedToArray(_ref, 2),\n        remotePt = _ref2[0],\n        remoteCodec = _ref2[1];\n\n    return remoteCodec !== 'rtx' ? unifiedPlanGetMatchingLocalPayloadTypes(remoteCodec, remotePt, localCodecsToPts, localSection, remoteSection) : [];\n  });\n\n  // For each local Payload Type that will be retained, retain their\n  // corresponding rtx Payload Type if present.\n  var localRtxPts = localCodecsToPts.get('rtx') || [];\n  // In \"a=fmtp:<rtxPt> apt=<apt>\", extract the codec PT <apt> associated with rtxPt.\n  localPts = localPts.concat(localRtxPts.filter(function (rtxPt) {\n    var fmtpAttrs = getFmtpAttributesForPt(rtxPt, localSection);\n    return fmtpAttrs && localPts.includes(fmtpAttrs.apt);\n  }));\n\n  // Filter out the below mentioned attribute lines in the local m= section that\n  // do not belong to one of the local Payload Types that are to be retained.\n  // 1. \"a=rtpmap:<pt> <codec>\"\n  // 2. \"a=rtcp-fb:<pt> <attr>[ <attr>]*\"\n  // 3. \"a=fmtp:<pt> <name>=<value>[;<name>=<value>]*\"\n  var lines = localSection.split('\\r\\n').filter(function (line) {\n    var ptMatches = line.match(/^a=(rtpmap|fmtp|rtcp-fb):(.+) .+$/);\n    var pt = ptMatches && ptMatches[2];\n    return !ptMatches || pt && localPts.includes(parseInt(pt, 10));\n  });\n\n  // Filter the list of Payload Types in the first line of the m= section.\n  var orderedLocalPts = getPayloadTypesInMediaSection(localSection).filter(function (pt) {\n    return localPts.includes(pt);\n  });\n  return setPayloadTypesInMediaSection(orderedLocalPts, lines.join('\\r\\n'));\n}\n\n/**\n * Filter local codecs based on the remote unified plan SDP.\n * @param {string} localSdp\n * @param {string} remoteSdp\n * @returns {string} - Updated local SDP\n */\nfunction unifiedPlanFilterLocalCodecs(localSdp, remoteSdp) {\n  var localMediaSections = getMediaSections(localSdp);\n  var localSession = localSdp.split('\\r\\nm=')[0];\n  var remoteMidsToMediaSections = createMidToMediaSectionMap(remoteSdp);\n  return [localSession].concat(localMediaSections.map(function (localSection) {\n    return unifiedPlanFilterCodecsInLocalMediaSection(localSection, remoteMidsToMediaSections);\n  })).join('\\r\\n');\n}\n\n/**\n * Return a new SDP string after reverting simulcast for non vp8 sections in remote sdp.\n * @param localSdp - simulcast enabled local sdp\n * @param localSdpWithoutSimulcast - local sdp before simulcast was set\n * @param remoteSdp - remote sdp\n * @return {string} Updated SDP string\n */\nfunction revertSimulcastForNonVP8MediaSections(localSdp, localSdpWithoutSimulcast, remoteSdp) {\n  var remoteMidToMediaSections = createMidToMediaSectionMap(remoteSdp);\n  var localMidToMediaSectionsWithoutSimulcast = createMidToMediaSectionMap(localSdpWithoutSimulcast);\n  var mediaSections = getMediaSections(localSdp);\n  var session = localSdp.split('\\r\\nm=')[0];\n  return [session].concat(mediaSections.map(function (section) {\n    section = section.replace(/\\r\\n$/, '');\n    if (!/^m=video/.test(section)) {\n      return section;\n    }\n    var midMatches = section.match(/^a=mid:(.+)$/m);\n    var mid = midMatches && midMatches[1];\n    if (!mid) {\n      return section;\n    }\n\n    var remoteSection = remoteMidToMediaSections.get(mid);\n    var remotePtToCodecs = createPtToCodecName(remoteSection);\n    var remotePayloadTypes = getPayloadTypesInMediaSection(remoteSection);\n\n    var isVP8ThePreferredCodec = remotePayloadTypes.length && remotePtToCodecs.get(remotePayloadTypes[0]) === 'vp8';\n    return isVP8ThePreferredCodec ? section : localMidToMediaSectionsWithoutSimulcast.get(mid).replace(/\\r\\n$/, '');\n  })).concat('').join('\\r\\n');\n}\n\n/**\n * Add or rewrite MSIDs for new m= sections in the given Unified Plan SDP with their\n * corresponding local MediaStreamTrack IDs. These can be different when previously\n * removed MediaStreamTracks are added back (or Track IDs may not be present in the\n * SDPs at all once browsers implement the latest WebRTC spec).\n * @param {string} sdp\n * @param {Map<string, Track.ID>} activeMidsToTrackIds\n * @param {Map<Track.Kind, Array<Track.ID>>} trackIdsByKind\n * @returns {string}\n */\nfunction unifiedPlanAddOrRewriteNewTrackIds(sdp, activeMidsToTrackIds, trackIdsByKind) {\n  // NOTE(mmalavalli): The m= sections for the new MediaStreamTracks are usually\n  // present after the m= sections for the existing MediaStreamTracks, in order\n  // of addition.\n  var newMidsToTrackIds = Array.from(trackIdsByKind).reduce(function (midsToTrackIds, _ref3) {\n    var _ref4 = _slicedToArray(_ref3, 2),\n        kind = _ref4[0],\n        trackIds = _ref4[1];\n\n    var mediaSections = getMediaSections(sdp, kind, 'send(only|recv)');\n    var newMids = mediaSections.map(getMidForMediaSection).filter(function (mid) {\n      return !activeMidsToTrackIds.has(mid);\n    });\n    newMids.forEach(function (mid, i) {\n      return midsToTrackIds.set(mid, trackIds[i]);\n    });\n    return midsToTrackIds;\n  }, new Map());\n  return unifiedPlanAddOrRewriteTrackIds(sdp, newMidsToTrackIds);\n}\n\n/**\n * Add or rewrite MSIDs in the given Unified Plan SDP with their corresponding local\n * MediaStreamTrack IDs. These IDs need not be the same (or Track IDs may not be\n * present in the SDPs at all once browsers implement the latest WebRTC spec).\n * @param {string} sdp\n * @param {Map<string, Track.ID>} midsToTrackIds\n * @returns {string}\n */\nfunction unifiedPlanAddOrRewriteTrackIds(sdp, midsToTrackIds) {\n  var mediaSections = getMediaSections(sdp);\n  var session = sdp.split('\\r\\nm=')[0];\n  return [session].concat(mediaSections.map(function (mediaSection) {\n    // Do nothing if the m= section represents neither audio nor video.\n    if (!/^m=(audio|video)/.test(mediaSection)) {\n      return mediaSection;\n    }\n    // This shouldn't happen, but in case there is no MID for the m= section, do nothing.\n    var mid = getMidForMediaSection(mediaSection);\n    if (!mid) {\n      return mediaSection;\n    }\n    // In case there is no Track ID for the given MID in the map, do nothing.\n    var trackId = midsToTrackIds.get(mid);\n    if (!trackId) {\n      return mediaSection;\n    }\n    // This shouldn't happen, but in case there is no a=msid: line, do nothing.\n    var attributes = (mediaSection.match(/^a=msid:(.+)$/m) || [])[1];\n    if (!attributes) {\n      return mediaSection;\n    }\n    // If the a=msid: line contains the \"appdata\" field, then replace it with the Track ID,\n    // otherwise append the Track ID.\n\n    var _attributes$split = attributes.split(' '),\n        _attributes$split2 = _slicedToArray(_attributes$split, 2),\n        msid = _attributes$split2[0],\n        trackIdToRewrite = _attributes$split2[1];\n\n    var msidRegex = new RegExp('msid:' + msid + (trackIdToRewrite ? ' ' + trackIdToRewrite : '') + '$', 'gm');\n    return mediaSection.replace(msidRegex, 'msid:' + msid + ' ' + trackId);\n  })).join('\\r\\n');\n}\n\nexports.createCodecMapForMediaSection = createCodecMapForMediaSection;\nexports.createPtToCodecName = createPtToCodecName;\nexports.getMediaSections = getMediaSections;\nexports.revertSimulcastForNonVP8MediaSections = revertSimulcastForNonVP8MediaSections;\nexports.setBitrateParameters = setBitrateParameters;\nexports.setCodecPreferences = setCodecPreferences;\nexports.setSimulcast = setSimulcast;\nexports.unifiedPlanFilterLocalCodecs = unifiedPlanFilterLocalCodecs;\nexports.unifiedPlanAddOrRewriteNewTrackIds = unifiedPlanAddOrRewriteNewTrackIds;\nexports.unifiedPlanAddOrRewriteTrackIds = unifiedPlanAddOrRewriteTrackIds;"]},"metadata":{},"sourceType":"script"}