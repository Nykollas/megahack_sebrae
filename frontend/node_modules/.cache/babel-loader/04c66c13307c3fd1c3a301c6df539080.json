{"ast":null,"code":"'use strict';\n/**\n * Create a {@link Deferred}.\n * @returns {Deferred}\n */\n\nfunction defer() {\n  var deferred = {};\n  deferred.promise = new Promise(function (resolve, reject) {\n    deferred.resolve = resolve;\n    deferred.reject = reject;\n  });\n  return deferred;\n}\n/**\n * Copy a method from a `source` prototype onto a `wrapper` prototype. Invoking\n * the method on the `wrapper` prototype will invoke the corresponding method\n * on an instance accessed by `target`.\n * @param {object} source\n * @param {object} wrapper\n * @param {string} target\n * @param {string} methodName\n * @returns {undefined}\n */\n\n\nfunction delegateMethod(source, wrapper, target, methodName) {\n  if (methodName in wrapper) {\n    // Skip any methods already set.\n    return;\n  } else if (methodName.match(/^on[a-z]+$/)) {\n    // Skip EventHandlers (these are handled in the constructor).\n    return;\n  }\n\n  var type;\n\n  try {\n    type = typeof source[methodName];\n  } catch (error) {// NOTE(mroberts): Attempting to check the type of non-function members\n    // on the prototype throws an error for some types.\n  }\n\n  if (type !== 'function') {\n    // Skip non-function members.\n    return;\n  }\n  /* eslint no-loop-func:0 */\n\n\n  wrapper[methodName] = function () {\n    return this[target][methodName].apply(this[target], arguments);\n  };\n}\n/**\n * Copy methods from a `source` prototype onto a `wrapper` prototype. Invoking\n * the methods on the `wrapper` prototype will invoke the corresponding method\n * on an instance accessed by `target`.\n * @param {object} source\n * @param {object} wrapper\n * @param {string} target\n * @returns {undefined}\n */\n\n\nfunction delegateMethods(source, wrapper, target) {\n  for (var methodName in source) {\n    delegateMethod(source, wrapper, target, methodName);\n  }\n}\n/**\n * Finds the items in list1 that are not in list2.\n * @param {Array<*>|Map<*>|Set<*>} list1\n * @param {Array<*>|Map<*>|Set<*>} list2\n * @returns {Set}\n */\n\n\nfunction difference(list1, list2) {\n  list1 = Array.isArray(list1) ? new Set(list1) : new Set(list1.values());\n  list2 = Array.isArray(list2) ? new Set(list2) : new Set(list2.values());\n  var difference = new Set();\n  list1.forEach(function (item) {\n    if (!list2.has(item)) {\n      difference.add(item);\n    }\n  });\n  return difference;\n}\n/**\n * Map a list to an array of arrays, and return the flattened result.\n * @param {Array<*>|Set<*>|Map<*>} list\n * @param {function(*): Array<*>} mapFn\n * @returns Array<*>\n */\n\n\nfunction flatMap(list, mapFn) {\n  var listArray = list instanceof Map || list instanceof Set ? Array.from(list.values()) : list;\n  return listArray.reduce(function (flattened, item) {\n    var mapped = mapFn(item);\n    return flattened.concat(mapped);\n  }, []);\n}\n/**\n * Get the browser's user agent, if available.\n * @returns {?string}\n */\n\n\nfunction getUserAgent() {\n  return typeof navigator !== 'undefined' && typeof navigator.userAgent === 'string' ? navigator.userAgent : null;\n}\n/**\n * Guess the browser.\n * @param {string} [userAgent=navigator.userAgent]\n * @returns {?string} browser - \"chrome\", \"firefox\", \"safari\", or null\n */\n\n\nfunction guessBrowser(userAgent) {\n  if (typeof userAgent === 'undefined') {\n    userAgent = getUserAgent();\n  }\n\n  if (/Chrome|CriOS/.test(userAgent)) {\n    return 'chrome';\n  }\n\n  if (/Firefox|FxiOS/.test(userAgent)) {\n    return 'firefox';\n  }\n\n  if (/Safari/.test(userAgent)) {\n    return 'safari';\n  }\n\n  return null;\n}\n/**\n * Guess the browser version.\n * @param {string} [userAgent=navigator.userAgent]\n * @returns {?{major: number, minor: number}}\n */\n\n\nfunction guessBrowserVersion(userAgent) {\n  if (typeof userAgent === 'undefined') {\n    userAgent = getUserAgent();\n  }\n\n  var prefix = {\n    chrome: 'Chrome|CriOS',\n    firefox: 'Firefox|FxiOS',\n    safari: 'Version'\n  }[guessBrowser(userAgent)];\n\n  if (!prefix) {\n    return null;\n  }\n\n  var regex = new RegExp('(' + prefix + ')/([^\\\\s]+)');\n  var match = (userAgent.match(regex) || [])[2];\n\n  if (!match) {\n    return null;\n  }\n\n  var versions = match.split('.').map(Number);\n  return {\n    major: isNaN(versions[0]) ? null : versions[0],\n    minor: isNaN(versions[1]) ? null : versions[1]\n  };\n}\n/**\n * Intercept an event that might otherwise be proxied on an EventTarget.\n * @param {EventTarget} target\n * @param {string} type\n * @returns {void}\n */\n\n\nfunction interceptEvent(target, type) {\n  var currentListener = null;\n  Object.defineProperty(target, 'on' + type, {\n    get: function () {\n      return currentListener;\n    },\n    set: function (newListener) {\n      if (currentListener) {\n        this.removeEventListener(type, currentListener);\n      }\n\n      if (typeof newListener === 'function') {\n        currentListener = newListener;\n        this.addEventListener(type, currentListener);\n      } else {\n        currentListener = null;\n      }\n    }\n  });\n}\n/**\n * This is a function for turning a Promise into the kind referenced in the\n * Legacy Interface Extensions section of the WebRTC spec.\n * @param {Promise<*>} promise\n * @param {function<*>} onSuccess\n * @param {function<Error>} onFailure\n * @returns {Promise<undefined>}\n */\n\n\nfunction legacyPromise(promise, onSuccess, onFailure) {\n  if (onSuccess) {\n    return promise.then(function (result) {\n      onSuccess(result);\n    }, function (error) {\n      onFailure(error);\n    });\n  }\n\n  return promise;\n}\n/**\n * Make a unique ID.\n * @return {string}\n */\n\n\nfunction makeUUID() {\n  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n    var r = Math.random() * 16 | 0;\n    var v = c === 'x' ? r : r & 0x3 | 0x8;\n    return v.toString(16);\n  });\n}\n/**\n * For each property name on the `source` prototype, add getters and/or setters\n * to `wrapper` that proxy to `target`.\n * @param {object} source\n * @param {object} wrapper\n * @param {string} target\n * @returns {undefined}\n */\n\n\nfunction proxyProperties(source, wrapper, target) {\n  Object.getOwnPropertyNames(source).forEach(function (propertyName) {\n    proxyProperty(source, wrapper, target, propertyName);\n  });\n}\n/**\n * For the property name on the `source` prototype, add a getter and/or setter\n * to `wrapper` that proxies to `target`.\n * @param {object} source\n * @param {object} wrapper\n * @param {string} target\n * @param {string} propertyName\n * @returns {undefined}\n */\n\n\nfunction proxyProperty(source, wrapper, target, propertyName) {\n  if (propertyName in wrapper) {\n    // Skip any properties already set.\n    return;\n  } else if (propertyName.match(/^on[a-z]+$/)) {\n    Object.defineProperty(wrapper, propertyName, {\n      value: null,\n      writable: true\n    });\n    target.addEventListener(propertyName.slice(2), function () {\n      wrapper.dispatchEvent.apply(wrapper, arguments);\n    });\n    return;\n  }\n\n  Object.defineProperty(wrapper, propertyName, {\n    enumerable: true,\n    get: function () {\n      return target[propertyName];\n    }\n  });\n}\n/**\n * @typedef {object} Deferred\n * @property {Promise} promise\n * @property {function} reject\n * @property {function} resolve\n */\n\n\nexports.defer = defer;\nexports.delegateMethods = delegateMethods;\nexports.difference = difference;\nexports.flatMap = flatMap;\nexports.guessBrowser = guessBrowser;\nexports.guessBrowserVersion = guessBrowserVersion;\nexports.interceptEvent = interceptEvent;\nexports.legacyPromise = legacyPromise;\nexports.makeUUID = makeUUID;\nexports.proxyProperties = proxyProperties;","map":{"version":3,"sources":["/home/ascencion/sebrae_megahack/node_modules/@twilio/webrtc/lib/util/index.js"],"names":["defer","deferred","promise","Promise","resolve","reject","delegateMethod","source","wrapper","target","methodName","match","type","error","apply","arguments","delegateMethods","difference","list1","list2","Array","isArray","Set","values","forEach","item","has","add","flatMap","list","mapFn","listArray","Map","from","reduce","flattened","mapped","concat","getUserAgent","navigator","userAgent","guessBrowser","test","guessBrowserVersion","prefix","chrome","firefox","safari","regex","RegExp","versions","split","map","Number","major","isNaN","minor","interceptEvent","currentListener","Object","defineProperty","get","set","newListener","removeEventListener","addEventListener","legacyPromise","onSuccess","onFailure","then","result","makeUUID","replace","c","r","Math","random","v","toString","proxyProperties","getOwnPropertyNames","propertyName","proxyProperty","value","writable","slice","dispatchEvent","enumerable","exports"],"mappings":"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","sourcesContent":["'use strict';\n\n/**\n * Create a {@link Deferred}.\n * @returns {Deferred}\n */\nfunction defer() {\n  var deferred = {};\n  deferred.promise = new Promise(function(resolve, reject) {\n    deferred.resolve = resolve;\n    deferred.reject = reject;\n  });\n  return deferred;\n}\n\n/**\n * Copy a method from a `source` prototype onto a `wrapper` prototype. Invoking\n * the method on the `wrapper` prototype will invoke the corresponding method\n * on an instance accessed by `target`.\n * @param {object} source\n * @param {object} wrapper\n * @param {string} target\n * @param {string} methodName\n * @returns {undefined}\n */\nfunction delegateMethod(source, wrapper, target, methodName) {\n  if (methodName in wrapper) {\n    // Skip any methods already set.\n    return;\n  } else if (methodName.match(/^on[a-z]+$/)) {\n    // Skip EventHandlers (these are handled in the constructor).\n    return;\n  }\n\n  var type;\n  try {\n    type = typeof source[methodName];\n  } catch (error) {\n    // NOTE(mroberts): Attempting to check the type of non-function members\n    // on the prototype throws an error for some types.\n  }\n\n  if (type !== 'function') {\n    // Skip non-function members.\n    return;\n  }\n\n  /* eslint no-loop-func:0 */\n  wrapper[methodName] = function() {\n    return this[target][methodName].apply(this[target], arguments);\n  };\n}\n\n/**\n * Copy methods from a `source` prototype onto a `wrapper` prototype. Invoking\n * the methods on the `wrapper` prototype will invoke the corresponding method\n * on an instance accessed by `target`.\n * @param {object} source\n * @param {object} wrapper\n * @param {string} target\n * @returns {undefined}\n */\nfunction delegateMethods(source, wrapper, target) {\n  for (var methodName in source) {\n    delegateMethod(source, wrapper, target, methodName);\n  }\n}\n\n/**\n * Finds the items in list1 that are not in list2.\n * @param {Array<*>|Map<*>|Set<*>} list1\n * @param {Array<*>|Map<*>|Set<*>} list2\n * @returns {Set}\n */\nfunction difference(list1, list2) {\n  list1 = Array.isArray(list1) ? new Set(list1) : new Set(list1.values());\n  list2 = Array.isArray(list2) ? new Set(list2) : new Set(list2.values());\n\n  var difference = new Set();\n\n  list1.forEach(function(item) {\n    if (!list2.has(item)) {\n      difference.add(item);\n    }\n  });\n\n  return difference;\n}\n\n/**\n * Map a list to an array of arrays, and return the flattened result.\n * @param {Array<*>|Set<*>|Map<*>} list\n * @param {function(*): Array<*>} mapFn\n * @returns Array<*>\n */\nfunction flatMap(list, mapFn) {\n  var listArray = list instanceof Map || list instanceof Set\n    ? Array.from(list.values())\n    : list;\n\n  return listArray.reduce(function(flattened, item) {\n    var mapped = mapFn(item);\n    return flattened.concat(mapped);\n  }, []);\n}\n\n/**\n * Get the browser's user agent, if available.\n * @returns {?string}\n */\nfunction getUserAgent() {\n  return typeof navigator !== 'undefined' && typeof navigator.userAgent === 'string'\n    ? navigator.userAgent\n    : null;\n}\n\n/**\n * Guess the browser.\n * @param {string} [userAgent=navigator.userAgent]\n * @returns {?string} browser - \"chrome\", \"firefox\", \"safari\", or null\n */\nfunction guessBrowser(userAgent) {\n  if (typeof userAgent === 'undefined') {\n    userAgent = getUserAgent();\n  }\n  if (/Chrome|CriOS/.test(userAgent)) {\n    return 'chrome';\n  }\n  if (/Firefox|FxiOS/.test(userAgent)) {\n    return 'firefox';\n  }\n  if (/Safari/.test(userAgent)) {\n    return 'safari';\n  }\n  return null;\n}\n\n/**\n * Guess the browser version.\n * @param {string} [userAgent=navigator.userAgent]\n * @returns {?{major: number, minor: number}}\n */\nfunction guessBrowserVersion(userAgent) {\n  if (typeof userAgent === 'undefined') {\n    userAgent = getUserAgent();\n  }\n  var prefix = {\n    chrome: 'Chrome|CriOS',\n    firefox: 'Firefox|FxiOS',\n    safari: 'Version'\n  }[guessBrowser(userAgent)];\n\n  if (!prefix) {\n    return null;\n  }\n  var regex = new RegExp('(' + prefix + ')/([^\\\\s]+)');\n  var match = (userAgent.match(regex) || [])[2];\n\n  if (!match) {\n    return null;\n  }\n  var versions = match.split('.').map(Number);\n  return {\n    major: isNaN(versions[0]) ? null : versions[0],\n    minor: isNaN(versions[1]) ? null : versions[1]\n  };\n}\n\n/**\n * Intercept an event that might otherwise be proxied on an EventTarget.\n * @param {EventTarget} target\n * @param {string} type\n * @returns {void}\n */\nfunction interceptEvent(target, type) {\n  var currentListener = null;\n  Object.defineProperty(target, 'on' + type, {\n    get: function() {\n      return currentListener;\n    },\n    set: function(newListener) {\n      if (currentListener) {\n        this.removeEventListener(type, currentListener);\n      }\n\n      if (typeof newListener === 'function') {\n        currentListener = newListener;\n        this.addEventListener(type, currentListener);\n      } else {\n        currentListener = null;\n      }\n    }\n  });\n}\n\n/**\n * This is a function for turning a Promise into the kind referenced in the\n * Legacy Interface Extensions section of the WebRTC spec.\n * @param {Promise<*>} promise\n * @param {function<*>} onSuccess\n * @param {function<Error>} onFailure\n * @returns {Promise<undefined>}\n */\nfunction legacyPromise(promise, onSuccess, onFailure) {\n  if (onSuccess) {\n    return promise.then(function(result) {\n      onSuccess(result);\n    }, function(error) {\n      onFailure(error);\n    });\n  }\n  return promise;\n}\n\n/**\n * Make a unique ID.\n * @return {string}\n */\nfunction makeUUID() {\n  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {\n    var r = Math.random() * 16 | 0;\n    var v = c === 'x' ? r : (r & 0x3 | 0x8);\n    return v.toString(16);\n  });\n}\n\n/**\n * For each property name on the `source` prototype, add getters and/or setters\n * to `wrapper` that proxy to `target`.\n * @param {object} source\n * @param {object} wrapper\n * @param {string} target\n * @returns {undefined}\n */\nfunction proxyProperties(source, wrapper, target) {\n  Object.getOwnPropertyNames(source).forEach(function(propertyName) {\n    proxyProperty(source, wrapper, target, propertyName);\n  });\n}\n\n/**\n * For the property name on the `source` prototype, add a getter and/or setter\n * to `wrapper` that proxies to `target`.\n * @param {object} source\n * @param {object} wrapper\n * @param {string} target\n * @param {string} propertyName\n * @returns {undefined}\n */\nfunction proxyProperty(source, wrapper, target, propertyName) {\n  if (propertyName in wrapper) {\n    // Skip any properties already set.\n    return;\n  } else if (propertyName.match(/^on[a-z]+$/)) {\n    Object.defineProperty(wrapper, propertyName, {\n      value: null,\n      writable: true\n    });\n\n    target.addEventListener(propertyName.slice(2), function() {\n      wrapper.dispatchEvent.apply(wrapper, arguments);\n    });\n\n    return;\n  }\n\n  Object.defineProperty(wrapper, propertyName, {\n    enumerable: true,\n    get: function() {\n      return target[propertyName];\n    }\n  });\n}\n\n/**\n * @typedef {object} Deferred\n * @property {Promise} promise\n * @property {function} reject\n * @property {function} resolve\n */\n\nexports.defer = defer;\nexports.delegateMethods = delegateMethods;\nexports.difference = difference;\nexports.flatMap = flatMap;\nexports.guessBrowser = guessBrowser;\nexports.guessBrowserVersion = guessBrowserVersion;\nexports.interceptEvent = interceptEvent;\nexports.legacyPromise = legacyPromise;\nexports.makeUUID = makeUUID;\nexports.proxyProperties = proxyProperties;\n"]},"metadata":{},"sourceType":"script"}