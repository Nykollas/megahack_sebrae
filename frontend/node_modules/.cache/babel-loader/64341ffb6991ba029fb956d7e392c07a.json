{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nfunction objectType(object) {\n  if (object === undefined) {\n    return 'undefined';\n  }\n\n  if (object === null) {\n    return 'null';\n  }\n\n  if (Array.isArray(object)) {\n    return 'array';\n  }\n\n  return typeof object;\n}\n\nexports.objectType = objectType;\n/**\nEvaluate `left === right`, treating `left` and `right` as ordered lists.\n\n@returns true iff `left` and `right` have identical lengths, and every element\n         of `left` is equal to the corresponding element of `right`. Equality is\n         determined recursivly, via `compare`.\n*/\n\nfunction compareArrays(left, right) {\n  var length = left.length;\n\n  if (length !== right.length) {\n    return false;\n  }\n\n  for (var i = 0; i < length; i++) {\n    if (!compare(left[i], right[i])) {\n      return false;\n    }\n  }\n\n  return true;\n}\n/**\nEvaluate `left === right`, treating `left` and `right` as property maps.\n\n@returns true iff every property in `left` has a value equal to the value of the\n         corresponding property in `right`, and vice-versa, stopping as soon as\n         possible. Equality is determined recursivly, via `compare`.\n*/\n\n\nfunction compareObjects(left, right) {\n  var left_keys = Object.keys(left);\n  var right_keys = Object.keys(right);\n  var length = left_keys.length; // quick exit if the number of keys don't match up\n\n  if (length !== right_keys.length) {\n    return false;\n  } // we don't know for sure that Set(left_keys) is equal to Set(right_keys),\n  // much less that their values in left and right are equal, but if right\n  // contains each key in left, we know it can't have any additional keys\n\n\n  for (var i = 0; i < length; i++) {\n    var key = left_keys[i];\n\n    if (!hasOwnProperty.call(right, key) || !compare(left[key], right[key])) {\n      return false;\n    }\n  }\n\n  return true;\n}\n/**\n`compare()` returns true if `left` and `right` are materially equal\n(i.e., would produce equivalent JSON), false otherwise.\n\n> Here, \"equal\" means that the value at the target location and the\n> value conveyed by \"value\" are of the same JSON type, and that they\n> are considered equal by the following rules for that type:\n> o  strings: are considered equal if they contain the same number of\n>    Unicode characters and their code points are byte-by-byte equal.\n> o  numbers: are considered equal if their values are numerically\n>    equal.\n> o  arrays: are considered equal if they contain the same number of\n>    values, and if each value can be considered equal to the value at\n>    the corresponding position in the other array, using this list of\n>    type-specific rules.\n> o  objects: are considered equal if they contain the same number of\n>    members, and if each member can be considered equal to a member in\n>    the other object, by comparing their keys (as strings) and their\n>    values (using this list of type-specific rules).\n> o  literals (false, true, and null): are considered equal if they are\n>    the same.\n*/\n\n\nfunction compare(left, right) {\n  // strict equality handles literals, numbers, and strings (a sufficient but not necessary cause)\n  if (left === right) {\n    return true;\n  }\n\n  var left_type = objectType(left);\n  var right_type = objectType(right); // check arrays\n\n  if (left_type == 'array' && right_type == 'array') {\n    return compareArrays(left, right);\n  } // check objects\n\n\n  if (left_type == 'object' && right_type == 'object') {\n    return compareObjects(left, right);\n  } // mismatched arrays & objects, etc., are always inequal\n\n\n  return false;\n}\n\nexports.compare = compare;","map":{"version":3,"sources":["/home/ascencion/sebrae_megahack/node_modules/rfc6902/equal.js"],"names":["Object","defineProperty","exports","value","hasOwnProperty","prototype","objectType","object","undefined","Array","isArray","compareArrays","left","right","length","i","compare","compareObjects","left_keys","keys","right_keys","key","call","left_type","right_type"],"mappings":"AAAA;;AACAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;AACA,IAAIC,cAAc,GAAGJ,MAAM,CAACK,SAAP,CAAiBD,cAAtC;;AACA,SAASE,UAAT,CAAoBC,MAApB,EAA4B;AACxB,MAAIA,MAAM,KAAKC,SAAf,EAA0B;AACtB,WAAO,WAAP;AACH;;AACD,MAAID,MAAM,KAAK,IAAf,EAAqB;AACjB,WAAO,MAAP;AACH;;AACD,MAAIE,KAAK,CAACC,OAAN,CAAcH,MAAd,CAAJ,EAA2B;AACvB,WAAO,OAAP;AACH;;AACD,SAAO,OAAOA,MAAd;AACH;;AACDL,OAAO,CAACI,UAAR,GAAqBA,UAArB;AACA;;;;;;;;AAOA,SAASK,aAAT,CAAuBC,IAAvB,EAA6BC,KAA7B,EAAoC;AAChC,MAAIC,MAAM,GAAGF,IAAI,CAACE,MAAlB;;AACA,MAAIA,MAAM,KAAKD,KAAK,CAACC,MAArB,EAA6B;AACzB,WAAO,KAAP;AACH;;AACD,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGD,MAApB,EAA4BC,CAAC,EAA7B,EAAiC;AAC7B,QAAI,CAACC,OAAO,CAACJ,IAAI,CAACG,CAAD,CAAL,EAAUF,KAAK,CAACE,CAAD,CAAf,CAAZ,EAAiC;AAC7B,aAAO,KAAP;AACH;AACJ;;AACD,SAAO,IAAP;AACH;AACD;;;;;;;;;AAOA,SAASE,cAAT,CAAwBL,IAAxB,EAA8BC,KAA9B,EAAqC;AACjC,MAAIK,SAAS,GAAGlB,MAAM,CAACmB,IAAP,CAAYP,IAAZ,CAAhB;AACA,MAAIQ,UAAU,GAAGpB,MAAM,CAACmB,IAAP,CAAYN,KAAZ,CAAjB;AACA,MAAIC,MAAM,GAAGI,SAAS,CAACJ,MAAvB,CAHiC,CAIjC;;AACA,MAAIA,MAAM,KAAKM,UAAU,CAACN,MAA1B,EAAkC;AAC9B,WAAO,KAAP;AACH,GAPgC,CAQjC;AACA;AACA;;;AACA,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGD,MAApB,EAA4BC,CAAC,EAA7B,EAAiC;AAC7B,QAAIM,GAAG,GAAGH,SAAS,CAACH,CAAD,CAAnB;;AACA,QAAI,CAACX,cAAc,CAACkB,IAAf,CAAoBT,KAApB,EAA2BQ,GAA3B,CAAD,IAAoC,CAACL,OAAO,CAACJ,IAAI,CAACS,GAAD,CAAL,EAAYR,KAAK,CAACQ,GAAD,CAAjB,CAAhD,EAAyE;AACrE,aAAO,KAAP;AACH;AACJ;;AACD,SAAO,IAAP;AACH;AACD;;;;;;;;;;;;;;;;;;;;;;;;AAsBA,SAASL,OAAT,CAAiBJ,IAAjB,EAAuBC,KAAvB,EAA8B;AAC1B;AACA,MAAID,IAAI,KAAKC,KAAb,EAAoB;AAChB,WAAO,IAAP;AACH;;AACD,MAAIU,SAAS,GAAGjB,UAAU,CAACM,IAAD,CAA1B;AACA,MAAIY,UAAU,GAAGlB,UAAU,CAACO,KAAD,CAA3B,CAN0B,CAO1B;;AACA,MAAIU,SAAS,IAAI,OAAb,IAAwBC,UAAU,IAAI,OAA1C,EAAmD;AAC/C,WAAOb,aAAa,CAACC,IAAD,EAAOC,KAAP,CAApB;AACH,GAVyB,CAW1B;;;AACA,MAAIU,SAAS,IAAI,QAAb,IAAyBC,UAAU,IAAI,QAA3C,EAAqD;AACjD,WAAOP,cAAc,CAACL,IAAD,EAAOC,KAAP,CAArB;AACH,GAdyB,CAe1B;;;AACA,SAAO,KAAP;AACH;;AACDX,OAAO,CAACc,OAAR,GAAkBA,OAAlB","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nfunction objectType(object) {\n    if (object === undefined) {\n        return 'undefined';\n    }\n    if (object === null) {\n        return 'null';\n    }\n    if (Array.isArray(object)) {\n        return 'array';\n    }\n    return typeof object;\n}\nexports.objectType = objectType;\n/**\nEvaluate `left === right`, treating `left` and `right` as ordered lists.\n\n@returns true iff `left` and `right` have identical lengths, and every element\n         of `left` is equal to the corresponding element of `right`. Equality is\n         determined recursivly, via `compare`.\n*/\nfunction compareArrays(left, right) {\n    var length = left.length;\n    if (length !== right.length) {\n        return false;\n    }\n    for (var i = 0; i < length; i++) {\n        if (!compare(left[i], right[i])) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\nEvaluate `left === right`, treating `left` and `right` as property maps.\n\n@returns true iff every property in `left` has a value equal to the value of the\n         corresponding property in `right`, and vice-versa, stopping as soon as\n         possible. Equality is determined recursivly, via `compare`.\n*/\nfunction compareObjects(left, right) {\n    var left_keys = Object.keys(left);\n    var right_keys = Object.keys(right);\n    var length = left_keys.length;\n    // quick exit if the number of keys don't match up\n    if (length !== right_keys.length) {\n        return false;\n    }\n    // we don't know for sure that Set(left_keys) is equal to Set(right_keys),\n    // much less that their values in left and right are equal, but if right\n    // contains each key in left, we know it can't have any additional keys\n    for (var i = 0; i < length; i++) {\n        var key = left_keys[i];\n        if (!hasOwnProperty.call(right, key) || !compare(left[key], right[key])) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n`compare()` returns true if `left` and `right` are materially equal\n(i.e., would produce equivalent JSON), false otherwise.\n\n> Here, \"equal\" means that the value at the target location and the\n> value conveyed by \"value\" are of the same JSON type, and that they\n> are considered equal by the following rules for that type:\n> o  strings: are considered equal if they contain the same number of\n>    Unicode characters and their code points are byte-by-byte equal.\n> o  numbers: are considered equal if their values are numerically\n>    equal.\n> o  arrays: are considered equal if they contain the same number of\n>    values, and if each value can be considered equal to the value at\n>    the corresponding position in the other array, using this list of\n>    type-specific rules.\n> o  objects: are considered equal if they contain the same number of\n>    members, and if each member can be considered equal to a member in\n>    the other object, by comparing their keys (as strings) and their\n>    values (using this list of type-specific rules).\n> o  literals (false, true, and null): are considered equal if they are\n>    the same.\n*/\nfunction compare(left, right) {\n    // strict equality handles literals, numbers, and strings (a sufficient but not necessary cause)\n    if (left === right) {\n        return true;\n    }\n    var left_type = objectType(left);\n    var right_type = objectType(right);\n    // check arrays\n    if (left_type == 'array' && right_type == 'array') {\n        return compareArrays(left, right);\n    }\n    // check objects\n    if (left_type == 'object' && right_type == 'object') {\n        return compareObjects(left, right);\n    }\n    // mismatched arrays & objects, etc., are always inequal\n    return false;\n}\nexports.compare = compare;\n"]},"metadata":{},"sourceType":"script"}