{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst events_1 = require(\"events\");\n\nconst logger_1 = require(\"./logger\");\n\nconst configuration_1 = require(\"./configuration\");\n\nconst twilsock_1 = require(\"./twilsock\");\n\nconst packetinterface_1 = require(\"./packetinterface\");\n\nconst websocketchannel_1 = require(\"./websocketchannel\");\n\nconst registrations_1 = require(\"./services/registrations\");\n\nconst upstream_1 = require(\"./services/upstream\");\n\nconst deferred_1 = require(\"./deferred\");\n\nconst index_1 = require(\"./index\");\n\nconst offlinestorage_1 = require(\"./offlinestorage\");\n\nconst tokenStorage_1 = require(\"./tokenStorage\");\n/**\n * @alias Twilsock\n * @classdesc Client library for the Twilsock service\n * It allows to recevie service-generated updates as well as bi-directional transport\n * @fires Twilsock#message\n * @fires Twilsock#connected\n * @fires Twilsock#disconnected\n * @fires Twilsock#tokenAboutToExpire\n * @fires Twilsock#stateChanged\n * @fires Twilsock#connectionError\n */\n\n\nclass TwilsockClient extends events_1.EventEmitter {\n  /**\n   * @param {string} token Twilio access token\n   * @param {string} productId Product identifier. Should be the same as a grant name in token\n   */\n  constructor(token, productId, options = {}) {\n    super();\n    this.offlineStorageDeferred = new deferred_1.Deferred();\n    options.continuationToken = options.continuationToken ? options.continuationToken : tokenStorage_1.TokenStorage.getStoredToken(productId);\n    let config = this.config = new configuration_1.Configuration(token, productId, options);\n    logger_1.log.setLevel(config.logLevel);\n    let websocket = new websocketchannel_1.WebSocketChannel(config.url);\n    let transport = options.transport ? options.transport : new packetinterface_1.PacketInterface(websocket, config);\n    this.channel = options.channel ? options.channel : new twilsock_1.TwilsockImpl(websocket, transport, config);\n    this.registrations = options.registrations ? options.registrations : new registrations_1.Registrations(transport);\n    this.upstream = new upstream_1.Upstream(transport, this.channel, config);\n    this.registrations.on('registered', id => this.emit('registered', id));\n    this.channel.on('message', (type, message) => setTimeout(() => this.emit('message', type, message), 0));\n    this.channel.on('stateChanged', state => setTimeout(() => this.emit('stateChanged', state), 0));\n    this.channel.on('connectionError', connectionError => setTimeout(() => this.emit('connectionError', connectionError), 0));\n    this.channel.on('tokenAboutToExpire', () => setTimeout(() => this.emit('tokenAboutToExpire'), 0));\n    this.channel.on('tokenExpired', () => setTimeout(() => this.emit('tokenExpired'), 0));\n    this.channel.on('connected', () => this.registrations.updateRegistrations());\n    this.channel.on('connected', () => this.upstream.sendPendingMessages());\n    this.channel.on('connected', () => setTimeout(() => this.emit('connected'), 0));\n    this.channel.on('initialized', initReply => {\n      this.handleStorageId(productId, initReply);\n      tokenStorage_1.TokenStorage.storeToken(initReply.continuationToken, productId);\n      setTimeout(() => this.emit('initialized', initReply), 0);\n    });\n    this.channel.on('disconnected', () => setTimeout(() => this.emit('disconnected'), 0));\n    this.channel.on('disconnected', () => this.upstream.rejectPendingMessages());\n    this.channel.on('disconnected', () => this.offlineStorageDeferred.fail(new index_1.TwilsockError('Client disconnected')));\n    this.offlineStorageDeferred.promise.catch(() => {});\n  }\n\n  emit(event, ...args) {\n    logger_1.log.debug(`Emitting ${event.toString()}(${args.map(a => JSON.stringify(a)).join(', ')})`);\n    return super.emit(event, ...args);\n  }\n\n  handleStorageId(productId, initReply) {\n    if (!initReply.offlineStorage) {\n      this.offlineStorageDeferred.fail(new index_1.TwilsockError('No offline storage id'));\n    } else if (initReply.offlineStorage.hasOwnProperty(productId)) {\n      try {\n        this.offlineStorageDeferred.set(offlinestorage_1.OfflineProductStorage.create(initReply.offlineStorage[productId]));\n        logger_1.log.debug(`Offline storage for '${productId}' product: ${JSON.stringify(initReply.offlineStorage[productId])}.`);\n      } catch (e) {\n        this.offlineStorageDeferred.fail(new index_1.TwilsockError(`Failed to parse offline storage for ${productId} ${JSON.stringify(initReply.offlineStorage[productId])}. ${e}.`));\n      }\n    } else {\n      this.offlineStorageDeferred.fail(new index_1.TwilsockError(`No offline storage id for '${productId}' product: ${JSON.stringify(initReply.offlineStorage)}`));\n    }\n  }\n  /**\n   * Get offline storage ID\n   * @returns {Promise<OfflineProductStorage>}\n   */\n\n\n  storageId() {\n    return this.offlineStorageDeferred.promise;\n  }\n  /**\n   * Indicates if twilsock is connected now\n   * @returns {Boolean}\n   */\n\n\n  get isConnected() {\n    return this.channel.isConnected;\n  }\n  /**\n   * Current state\n   * @returns {String}\n   */\n\n\n  get state() {\n    return this.channel.state;\n  }\n  /**\n   * Update token\n   * @param {String} token\n   * @returns {Promise<void>}\n   */\n\n\n  async updateToken(token) {\n    logger_1.log.trace(`updating token '${token}'`);\n\n    if (this.config.token === token) {\n      return;\n    }\n\n    this.config.updateToken(token);\n    return this.channel.updateToken(token);\n  }\n  /**\n   * Updates notification context.\n   * This method shouldn't be used anyone except twilio notifications library\n   * @param contextId id of notification context\n   * @param context value of notification context\n   * @private\n   */\n\n\n  setNotificationsContext(contextId, context) {\n    this.registrations.setNotificationsContext(contextId, context);\n  }\n  /**\n   * Remove notification context.\n   * This method shouldn't be used anyone except twilio notifications library\n   * @param contextId id of notification context\n   * @private\n   */\n\n\n  removeNotificationsContext(contextId) {\n    this.registrations.removeNotificationsContext(contextId);\n  }\n  /**\n   * Connect to the server\n   * @fires Twilsock#connected\n   * @public\n   * @returns {Promise<void>}\n   */\n\n\n  connect() {\n    return this.channel.connect();\n  }\n  /**\n   * Disconnect from the server\n   * @fires Twilsock#disconnected\n   * @public\n   * @returns {Promise<void>}\n   */\n\n\n  disconnect() {\n    return this.channel.disconnect();\n  }\n  /**\n   * Get HTTP request to upstream service\n   * @param {string} url Upstream service url\n   * @param {headers} headers Set of custom headers\n   * @returns {Promise}\n   */\n\n\n  get(url, headers) {\n    return this.upstream.send('GET', url, headers);\n  }\n  /**\n   * Post HTTP request to upstream service\n   * @param {string} url Upstream service url\n   * @param {headers} headers Set of custom headers\n   * @param {body} body Body to send\n   * @returns {Promise}\n   */\n\n\n  post(url, headers, body) {\n    return this.upstream.send('POST', url, headers, body);\n  }\n  /**\n   * Put HTTP request to upstream service\n   * @param {string} url Upstream service url\n   * @param {headers} headers Set of custom headers\n   * @param {body} body Body to send\n   * @returns {Promise}\n   */\n\n\n  put(url, headers, body) {\n    return this.upstream.send('PUT', url, headers, body);\n  }\n  /**\n   * Delete HTTP request to upstream service\n   * @param {string} url Upstream service url\n   * @param {headers} headers Set of custom headers\n   * @returns {Promise}\n   */\n\n\n  delete(url, headers) {\n    return this.upstream.send('DELETE', url, headers);\n  }\n\n}\n\nexports.TwilsockClient = TwilsockClient;\nexports.Twilsock = TwilsockClient;\n/**\n * Twilsock destination address descriptor\n * @typedef {Object} Twilsock#Address\n * @property {String} method - HTTP method. (POST, PUT, etc)\n * @property {String} host - host name without path. (e.g. my.company.com)\n * @property {String} path - path on the host (e.g. /my/app/to/call.php)\n */\n\n/**\n * Twilsock upstream message\n * @typedef {Object} Twilsock#Message\n * @property {Twilsock#Address} to - destination address\n * @property {Object} headers - HTTP headers\n * @property {Object} body - Body\n */\n\n/**\n * Fired when new message received\n * @param {Twilsock#Message} message\n * @event Twilsock#message\n */\n\n/**\n * Fired when socket connected\n * @param {String} URI of endpoint\n * @event Twilsock#connected\n */\n\n/**\n * Fired when socket disconnected\n * @event Twilsock#disconnected\n */\n\n/**\n * Fired when token is about to expire and should be updated\n * @event Twilsock#tokenAboutToExpire\n */\n\n/**\n* Fired when socket connected\n* @param {('connecting'|'connected'|'rejected'|'disconnecting'|'disconnected')} state - general twilsock state\n* @event Twilsock#stateChanged\n*/\n\n/**\n * Fired when connection is interrupted by unexpected reason\n * @type {Object}\n * @property {Boolean} terminal - twilsock will stop connection attempts\n * @property {String} message - root cause\n * @property {Number} [httpStatusCode] - http status code if available\n * @property {Number} [errorCode] - Twilio public error code if available\n * @event Twilsock#connectionError\n */","map":{"version":3,"sources":["/home/ascencion/sebrae_megahack/node_modules/twilsock/lib/client.js"],"names":["Object","defineProperty","exports","value","events_1","require","logger_1","configuration_1","twilsock_1","packetinterface_1","websocketchannel_1","registrations_1","upstream_1","deferred_1","index_1","offlinestorage_1","tokenStorage_1","TwilsockClient","EventEmitter","constructor","token","productId","options","offlineStorageDeferred","Deferred","continuationToken","TokenStorage","getStoredToken","config","Configuration","log","setLevel","logLevel","websocket","WebSocketChannel","url","transport","PacketInterface","channel","TwilsockImpl","registrations","Registrations","upstream","Upstream","on","id","emit","type","message","setTimeout","state","connectionError","updateRegistrations","sendPendingMessages","initReply","handleStorageId","storeToken","rejectPendingMessages","fail","TwilsockError","promise","catch","event","args","debug","toString","map","a","JSON","stringify","join","offlineStorage","hasOwnProperty","set","OfflineProductStorage","create","e","storageId","isConnected","updateToken","trace","setNotificationsContext","contextId","context","removeNotificationsContext","connect","disconnect","get","headers","send","post","body","put","delete","Twilsock"],"mappings":"AAAA;;AACAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;;AACA,MAAMC,QAAQ,GAAGC,OAAO,CAAC,QAAD,CAAxB;;AACA,MAAMC,QAAQ,GAAGD,OAAO,CAAC,UAAD,CAAxB;;AACA,MAAME,eAAe,GAAGF,OAAO,CAAC,iBAAD,CAA/B;;AACA,MAAMG,UAAU,GAAGH,OAAO,CAAC,YAAD,CAA1B;;AACA,MAAMI,iBAAiB,GAAGJ,OAAO,CAAC,mBAAD,CAAjC;;AACA,MAAMK,kBAAkB,GAAGL,OAAO,CAAC,oBAAD,CAAlC;;AACA,MAAMM,eAAe,GAAGN,OAAO,CAAC,0BAAD,CAA/B;;AACA,MAAMO,UAAU,GAAGP,OAAO,CAAC,qBAAD,CAA1B;;AACA,MAAMQ,UAAU,GAAGR,OAAO,CAAC,YAAD,CAA1B;;AACA,MAAMS,OAAO,GAAGT,OAAO,CAAC,SAAD,CAAvB;;AACA,MAAMU,gBAAgB,GAAGV,OAAO,CAAC,kBAAD,CAAhC;;AACA,MAAMW,cAAc,GAAGX,OAAO,CAAC,gBAAD,CAA9B;AACA;;;;;;;;;;;;;AAWA,MAAMY,cAAN,SAA6Bb,QAAQ,CAACc,YAAtC,CAAmD;AAC/C;;;;AAIAC,EAAAA,WAAW,CAACC,KAAD,EAAQC,SAAR,EAAmBC,OAAO,GAAG,EAA7B,EAAiC;AACxC;AACA,SAAKC,sBAAL,GAA8B,IAAIV,UAAU,CAACW,QAAf,EAA9B;AACAF,IAAAA,OAAO,CAACG,iBAAR,GAA4BH,OAAO,CAACG,iBAAR,GAA4BH,OAAO,CAACG,iBAApC,GAAwDT,cAAc,CAACU,YAAf,CAA4BC,cAA5B,CAA2CN,SAA3C,CAApF;AACA,QAAIO,MAAM,GAAG,KAAKA,MAAL,GAAc,IAAIrB,eAAe,CAACsB,aAApB,CAAkCT,KAAlC,EAAyCC,SAAzC,EAAoDC,OAApD,CAA3B;AACAhB,IAAAA,QAAQ,CAACwB,GAAT,CAAaC,QAAb,CAAsBH,MAAM,CAACI,QAA7B;AACA,QAAIC,SAAS,GAAG,IAAIvB,kBAAkB,CAACwB,gBAAvB,CAAwCN,MAAM,CAACO,GAA/C,CAAhB;AACA,QAAIC,SAAS,GAAGd,OAAO,CAACc,SAAR,GACVd,OAAO,CAACc,SADE,GAEV,IAAI3B,iBAAiB,CAAC4B,eAAtB,CAAsCJ,SAAtC,EAAiDL,MAAjD,CAFN;AAGA,SAAKU,OAAL,GAAehB,OAAO,CAACgB,OAAR,GACThB,OAAO,CAACgB,OADC,GAET,IAAI9B,UAAU,CAAC+B,YAAf,CAA4BN,SAA5B,EAAuCG,SAAvC,EAAkDR,MAAlD,CAFN;AAGA,SAAKY,aAAL,GAAqBlB,OAAO,CAACkB,aAAR,GACflB,OAAO,CAACkB,aADO,GAEf,IAAI7B,eAAe,CAAC8B,aAApB,CAAkCL,SAAlC,CAFN;AAGA,SAAKM,QAAL,GAAgB,IAAI9B,UAAU,CAAC+B,QAAf,CAAwBP,SAAxB,EAAmC,KAAKE,OAAxC,EAAiDV,MAAjD,CAAhB;AACA,SAAKY,aAAL,CAAmBI,EAAnB,CAAsB,YAAtB,EAAqCC,EAAD,IAAQ,KAAKC,IAAL,CAAU,YAAV,EAAwBD,EAAxB,CAA5C;AACA,SAAKP,OAAL,CAAaM,EAAb,CAAgB,SAAhB,EAA2B,CAACG,IAAD,EAAOC,OAAP,KAAmBC,UAAU,CAAC,MAAM,KAAKH,IAAL,CAAU,SAAV,EAAqBC,IAArB,EAA2BC,OAA3B,CAAP,EAA4C,CAA5C,CAAxD;AACA,SAAKV,OAAL,CAAaM,EAAb,CAAgB,cAAhB,EAAgCM,KAAK,IAAID,UAAU,CAAC,MAAM,KAAKH,IAAL,CAAU,cAAV,EAA0BI,KAA1B,CAAP,EAAyC,CAAzC,CAAnD;AACA,SAAKZ,OAAL,CAAaM,EAAb,CAAgB,iBAAhB,EAAoCO,eAAD,IAAqBF,UAAU,CAAC,MAAM,KAAKH,IAAL,CAAU,iBAAV,EAA6BK,eAA7B,CAAP,EAAsD,CAAtD,CAAlE;AACA,SAAKb,OAAL,CAAaM,EAAb,CAAgB,oBAAhB,EAAsC,MAAMK,UAAU,CAAC,MAAM,KAAKH,IAAL,CAAU,oBAAV,CAAP,EAAwC,CAAxC,CAAtD;AACA,SAAKR,OAAL,CAAaM,EAAb,CAAgB,cAAhB,EAAgC,MAAMK,UAAU,CAAC,MAAM,KAAKH,IAAL,CAAU,cAAV,CAAP,EAAkC,CAAlC,CAAhD;AACA,SAAKR,OAAL,CAAaM,EAAb,CAAgB,WAAhB,EAA6B,MAAM,KAAKJ,aAAL,CAAmBY,mBAAnB,EAAnC;AACA,SAAKd,OAAL,CAAaM,EAAb,CAAgB,WAAhB,EAA6B,MAAM,KAAKF,QAAL,CAAcW,mBAAd,EAAnC;AACA,SAAKf,OAAL,CAAaM,EAAb,CAAgB,WAAhB,EAA6B,MAAMK,UAAU,CAAC,MAAM,KAAKH,IAAL,CAAU,WAAV,CAAP,EAA+B,CAA/B,CAA7C;AACA,SAAKR,OAAL,CAAaM,EAAb,CAAgB,aAAhB,EAAgCU,SAAD,IAAe;AAC1C,WAAKC,eAAL,CAAqBlC,SAArB,EAAgCiC,SAAhC;AACAtC,MAAAA,cAAc,CAACU,YAAf,CAA4B8B,UAA5B,CAAuCF,SAAS,CAAC7B,iBAAjD,EAAoEJ,SAApE;AACA4B,MAAAA,UAAU,CAAC,MAAM,KAAKH,IAAL,CAAU,aAAV,EAAyBQ,SAAzB,CAAP,EAA4C,CAA5C,CAAV;AACH,KAJD;AAKA,SAAKhB,OAAL,CAAaM,EAAb,CAAgB,cAAhB,EAAgC,MAAMK,UAAU,CAAC,MAAM,KAAKH,IAAL,CAAU,cAAV,CAAP,EAAkC,CAAlC,CAAhD;AACA,SAAKR,OAAL,CAAaM,EAAb,CAAgB,cAAhB,EAAgC,MAAM,KAAKF,QAAL,CAAce,qBAAd,EAAtC;AACA,SAAKnB,OAAL,CAAaM,EAAb,CAAgB,cAAhB,EAAgC,MAAM,KAAKrB,sBAAL,CAA4BmC,IAA5B,CAAiC,IAAI5C,OAAO,CAAC6C,aAAZ,CAA0B,qBAA1B,CAAjC,CAAtC;AACA,SAAKpC,sBAAL,CAA4BqC,OAA5B,CAAoCC,KAApC,CAA0C,MAAM,CAAG,CAAnD;AACH;;AACDf,EAAAA,IAAI,CAACgB,KAAD,EAAQ,GAAGC,IAAX,EAAiB;AACjBzD,IAAAA,QAAQ,CAACwB,GAAT,CAAakC,KAAb,CAAoB,YAAWF,KAAK,CAACG,QAAN,EAAiB,IAAGF,IAAI,CAACG,GAAL,CAASC,CAAC,IAAIC,IAAI,CAACC,SAAL,CAAeF,CAAf,CAAd,EAAiCG,IAAjC,CAAsC,IAAtC,CAA4C,GAA/F;AACA,WAAO,MAAMxB,IAAN,CAAWgB,KAAX,EAAkB,GAAGC,IAArB,CAAP;AACH;;AACDR,EAAAA,eAAe,CAAClC,SAAD,EAAYiC,SAAZ,EAAuB;AAClC,QAAI,CAACA,SAAS,CAACiB,cAAf,EAA+B;AAC3B,WAAKhD,sBAAL,CAA4BmC,IAA5B,CAAiC,IAAI5C,OAAO,CAAC6C,aAAZ,CAA0B,uBAA1B,CAAjC;AACH,KAFD,MAGK,IAAIL,SAAS,CAACiB,cAAV,CAAyBC,cAAzB,CAAwCnD,SAAxC,CAAJ,EAAwD;AACzD,UAAI;AACA,aAAKE,sBAAL,CAA4BkD,GAA5B,CAAgC1D,gBAAgB,CAAC2D,qBAAjB,CAAuCC,MAAvC,CAA8CrB,SAAS,CAACiB,cAAV,CAAyBlD,SAAzB,CAA9C,CAAhC;AACAf,QAAAA,QAAQ,CAACwB,GAAT,CAAakC,KAAb,CAAoB,wBAAuB3C,SAAU,cAAa+C,IAAI,CAACC,SAAL,CAAef,SAAS,CAACiB,cAAV,CAAyBlD,SAAzB,CAAf,CAAoD,GAAtH;AACH,OAHD,CAIA,OAAOuD,CAAP,EAAU;AACN,aAAKrD,sBAAL,CAA4BmC,IAA5B,CAAiC,IAAI5C,OAAO,CAAC6C,aAAZ,CAA2B,uCAAsCtC,SAAU,IAAG+C,IAAI,CAACC,SAAL,CAAef,SAAS,CAACiB,cAAV,CAAyBlD,SAAzB,CAAf,CAAoD,KAAIuD,CAAE,GAAxI,CAAjC;AACH;AACJ,KARI,MASA;AACD,WAAKrD,sBAAL,CAA4BmC,IAA5B,CAAiC,IAAI5C,OAAO,CAAC6C,aAAZ,CAA2B,8BAA6BtC,SAAU,cAAa+C,IAAI,CAACC,SAAL,CAAef,SAAS,CAACiB,cAAzB,CAAyC,EAAxH,CAAjC;AACH;AACJ;AACD;;;;;;AAIAM,EAAAA,SAAS,GAAG;AACR,WAAO,KAAKtD,sBAAL,CAA4BqC,OAAnC;AACH;AACD;;;;;;AAIA,MAAIkB,WAAJ,GAAkB;AACd,WAAO,KAAKxC,OAAL,CAAawC,WAApB;AACH;AACD;;;;;;AAIA,MAAI5B,KAAJ,GAAY;AACR,WAAO,KAAKZ,OAAL,CAAaY,KAApB;AACH;AACD;;;;;;;AAKA,QAAM6B,WAAN,CAAkB3D,KAAlB,EAAyB;AACrBd,IAAAA,QAAQ,CAACwB,GAAT,CAAakD,KAAb,CAAoB,mBAAkB5D,KAAM,GAA5C;;AACA,QAAI,KAAKQ,MAAL,CAAYR,KAAZ,KAAsBA,KAA1B,EAAiC;AAC7B;AACH;;AACD,SAAKQ,MAAL,CAAYmD,WAAZ,CAAwB3D,KAAxB;AACA,WAAO,KAAKkB,OAAL,CAAayC,WAAb,CAAyB3D,KAAzB,CAAP;AACH;AACD;;;;;;;;;AAOA6D,EAAAA,uBAAuB,CAACC,SAAD,EAAYC,OAAZ,EAAqB;AACxC,SAAK3C,aAAL,CAAmByC,uBAAnB,CAA2CC,SAA3C,EAAsDC,OAAtD;AACH;AACD;;;;;;;;AAMAC,EAAAA,0BAA0B,CAACF,SAAD,EAAY;AAClC,SAAK1C,aAAL,CAAmB4C,0BAAnB,CAA8CF,SAA9C;AACH;AACD;;;;;;;;AAMAG,EAAAA,OAAO,GAAG;AACN,WAAO,KAAK/C,OAAL,CAAa+C,OAAb,EAAP;AACH;AACD;;;;;;;;AAMAC,EAAAA,UAAU,GAAG;AACT,WAAO,KAAKhD,OAAL,CAAagD,UAAb,EAAP;AACH;AACD;;;;;;;;AAMAC,EAAAA,GAAG,CAACpD,GAAD,EAAMqD,OAAN,EAAe;AACd,WAAO,KAAK9C,QAAL,CAAc+C,IAAd,CAAmB,KAAnB,EAA0BtD,GAA1B,EAA+BqD,OAA/B,CAAP;AACH;AACD;;;;;;;;;AAOAE,EAAAA,IAAI,CAACvD,GAAD,EAAMqD,OAAN,EAAeG,IAAf,EAAqB;AACrB,WAAO,KAAKjD,QAAL,CAAc+C,IAAd,CAAmB,MAAnB,EAA2BtD,GAA3B,EAAgCqD,OAAhC,EAAyCG,IAAzC,CAAP;AACH;AACD;;;;;;;;;AAOAC,EAAAA,GAAG,CAACzD,GAAD,EAAMqD,OAAN,EAAeG,IAAf,EAAqB;AACpB,WAAO,KAAKjD,QAAL,CAAc+C,IAAd,CAAmB,KAAnB,EAA0BtD,GAA1B,EAA+BqD,OAA/B,EAAwCG,IAAxC,CAAP;AACH;AACD;;;;;;;;AAMAE,EAAAA,MAAM,CAAC1D,GAAD,EAAMqD,OAAN,EAAe;AACjB,WAAO,KAAK9C,QAAL,CAAc+C,IAAd,CAAmB,QAAnB,EAA6BtD,GAA7B,EAAkCqD,OAAlC,CAAP;AACH;;AA1K8C;;AA4KnDtF,OAAO,CAACe,cAAR,GAAyBA,cAAzB;AACAf,OAAO,CAAC4F,QAAR,GAAmB7E,cAAnB;AACA;;;;;;;;AAOA;;;;;;;;AAOA;;;;;;AAKA;;;;;;AAKA;;;;;AAIA;;;;;AAIA;;;;;;AAKA","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst events_1 = require(\"events\");\nconst logger_1 = require(\"./logger\");\nconst configuration_1 = require(\"./configuration\");\nconst twilsock_1 = require(\"./twilsock\");\nconst packetinterface_1 = require(\"./packetinterface\");\nconst websocketchannel_1 = require(\"./websocketchannel\");\nconst registrations_1 = require(\"./services/registrations\");\nconst upstream_1 = require(\"./services/upstream\");\nconst deferred_1 = require(\"./deferred\");\nconst index_1 = require(\"./index\");\nconst offlinestorage_1 = require(\"./offlinestorage\");\nconst tokenStorage_1 = require(\"./tokenStorage\");\n/**\n * @alias Twilsock\n * @classdesc Client library for the Twilsock service\n * It allows to recevie service-generated updates as well as bi-directional transport\n * @fires Twilsock#message\n * @fires Twilsock#connected\n * @fires Twilsock#disconnected\n * @fires Twilsock#tokenAboutToExpire\n * @fires Twilsock#stateChanged\n * @fires Twilsock#connectionError\n */\nclass TwilsockClient extends events_1.EventEmitter {\n    /**\n     * @param {string} token Twilio access token\n     * @param {string} productId Product identifier. Should be the same as a grant name in token\n     */\n    constructor(token, productId, options = {}) {\n        super();\n        this.offlineStorageDeferred = new deferred_1.Deferred();\n        options.continuationToken = options.continuationToken ? options.continuationToken : tokenStorage_1.TokenStorage.getStoredToken(productId);\n        let config = this.config = new configuration_1.Configuration(token, productId, options);\n        logger_1.log.setLevel(config.logLevel);\n        let websocket = new websocketchannel_1.WebSocketChannel(config.url);\n        let transport = options.transport\n            ? options.transport\n            : new packetinterface_1.PacketInterface(websocket, config);\n        this.channel = options.channel\n            ? options.channel\n            : new twilsock_1.TwilsockImpl(websocket, transport, config);\n        this.registrations = options.registrations\n            ? options.registrations\n            : new registrations_1.Registrations(transport);\n        this.upstream = new upstream_1.Upstream(transport, this.channel, config);\n        this.registrations.on('registered', (id) => this.emit('registered', id));\n        this.channel.on('message', (type, message) => setTimeout(() => this.emit('message', type, message), 0));\n        this.channel.on('stateChanged', state => setTimeout(() => this.emit('stateChanged', state), 0));\n        this.channel.on('connectionError', (connectionError) => setTimeout(() => this.emit('connectionError', connectionError), 0));\n        this.channel.on('tokenAboutToExpire', () => setTimeout(() => this.emit('tokenAboutToExpire'), 0));\n        this.channel.on('tokenExpired', () => setTimeout(() => this.emit('tokenExpired'), 0));\n        this.channel.on('connected', () => this.registrations.updateRegistrations());\n        this.channel.on('connected', () => this.upstream.sendPendingMessages());\n        this.channel.on('connected', () => setTimeout(() => this.emit('connected'), 0));\n        this.channel.on('initialized', (initReply) => {\n            this.handleStorageId(productId, initReply);\n            tokenStorage_1.TokenStorage.storeToken(initReply.continuationToken, productId);\n            setTimeout(() => this.emit('initialized', initReply), 0);\n        });\n        this.channel.on('disconnected', () => setTimeout(() => this.emit('disconnected'), 0));\n        this.channel.on('disconnected', () => this.upstream.rejectPendingMessages());\n        this.channel.on('disconnected', () => this.offlineStorageDeferred.fail(new index_1.TwilsockError('Client disconnected')));\n        this.offlineStorageDeferred.promise.catch(() => { });\n    }\n    emit(event, ...args) {\n        logger_1.log.debug(`Emitting ${event.toString()}(${args.map(a => JSON.stringify(a)).join(', ')})`);\n        return super.emit(event, ...args);\n    }\n    handleStorageId(productId, initReply) {\n        if (!initReply.offlineStorage) {\n            this.offlineStorageDeferred.fail(new index_1.TwilsockError('No offline storage id'));\n        }\n        else if (initReply.offlineStorage.hasOwnProperty(productId)) {\n            try {\n                this.offlineStorageDeferred.set(offlinestorage_1.OfflineProductStorage.create(initReply.offlineStorage[productId]));\n                logger_1.log.debug(`Offline storage for '${productId}' product: ${JSON.stringify(initReply.offlineStorage[productId])}.`);\n            }\n            catch (e) {\n                this.offlineStorageDeferred.fail(new index_1.TwilsockError(`Failed to parse offline storage for ${productId} ${JSON.stringify(initReply.offlineStorage[productId])}. ${e}.`));\n            }\n        }\n        else {\n            this.offlineStorageDeferred.fail(new index_1.TwilsockError(`No offline storage id for '${productId}' product: ${JSON.stringify(initReply.offlineStorage)}`));\n        }\n    }\n    /**\n     * Get offline storage ID\n     * @returns {Promise<OfflineProductStorage>}\n     */\n    storageId() {\n        return this.offlineStorageDeferred.promise;\n    }\n    /**\n     * Indicates if twilsock is connected now\n     * @returns {Boolean}\n     */\n    get isConnected() {\n        return this.channel.isConnected;\n    }\n    /**\n     * Current state\n     * @returns {String}\n     */\n    get state() {\n        return this.channel.state;\n    }\n    /**\n     * Update token\n     * @param {String} token\n     * @returns {Promise<void>}\n     */\n    async updateToken(token) {\n        logger_1.log.trace(`updating token '${token}'`);\n        if (this.config.token === token) {\n            return;\n        }\n        this.config.updateToken(token);\n        return this.channel.updateToken(token);\n    }\n    /**\n     * Updates notification context.\n     * This method shouldn't be used anyone except twilio notifications library\n     * @param contextId id of notification context\n     * @param context value of notification context\n     * @private\n     */\n    setNotificationsContext(contextId, context) {\n        this.registrations.setNotificationsContext(contextId, context);\n    }\n    /**\n     * Remove notification context.\n     * This method shouldn't be used anyone except twilio notifications library\n     * @param contextId id of notification context\n     * @private\n     */\n    removeNotificationsContext(contextId) {\n        this.registrations.removeNotificationsContext(contextId);\n    }\n    /**\n     * Connect to the server\n     * @fires Twilsock#connected\n     * @public\n     * @returns {Promise<void>}\n     */\n    connect() {\n        return this.channel.connect();\n    }\n    /**\n     * Disconnect from the server\n     * @fires Twilsock#disconnected\n     * @public\n     * @returns {Promise<void>}\n     */\n    disconnect() {\n        return this.channel.disconnect();\n    }\n    /**\n     * Get HTTP request to upstream service\n     * @param {string} url Upstream service url\n     * @param {headers} headers Set of custom headers\n     * @returns {Promise}\n     */\n    get(url, headers) {\n        return this.upstream.send('GET', url, headers);\n    }\n    /**\n     * Post HTTP request to upstream service\n     * @param {string} url Upstream service url\n     * @param {headers} headers Set of custom headers\n     * @param {body} body Body to send\n     * @returns {Promise}\n     */\n    post(url, headers, body) {\n        return this.upstream.send('POST', url, headers, body);\n    }\n    /**\n     * Put HTTP request to upstream service\n     * @param {string} url Upstream service url\n     * @param {headers} headers Set of custom headers\n     * @param {body} body Body to send\n     * @returns {Promise}\n     */\n    put(url, headers, body) {\n        return this.upstream.send('PUT', url, headers, body);\n    }\n    /**\n     * Delete HTTP request to upstream service\n     * @param {string} url Upstream service url\n     * @param {headers} headers Set of custom headers\n     * @returns {Promise}\n     */\n    delete(url, headers) {\n        return this.upstream.send('DELETE', url, headers);\n    }\n}\nexports.TwilsockClient = TwilsockClient;\nexports.Twilsock = TwilsockClient;\n/**\n * Twilsock destination address descriptor\n * @typedef {Object} Twilsock#Address\n * @property {String} method - HTTP method. (POST, PUT, etc)\n * @property {String} host - host name without path. (e.g. my.company.com)\n * @property {String} path - path on the host (e.g. /my/app/to/call.php)\n */\n/**\n * Twilsock upstream message\n * @typedef {Object} Twilsock#Message\n * @property {Twilsock#Address} to - destination address\n * @property {Object} headers - HTTP headers\n * @property {Object} body - Body\n */\n/**\n * Fired when new message received\n * @param {Twilsock#Message} message\n * @event Twilsock#message\n */\n/**\n * Fired when socket connected\n * @param {String} URI of endpoint\n * @event Twilsock#connected\n */\n/**\n * Fired when socket disconnected\n * @event Twilsock#disconnected\n */\n/**\n * Fired when token is about to expire and should be updated\n * @event Twilsock#tokenAboutToExpire\n */\n/**\n* Fired when socket connected\n* @param {('connecting'|'connected'|'rejected'|'disconnecting'|'disconnected')} state - general twilsock state\n* @event Twilsock#stateChanged\n*/\n/**\n * Fired when connection is interrupted by unexpected reason\n * @type {Object}\n * @property {Boolean} terminal - twilsock will stop connection attempts\n * @property {String} message - root cause\n * @property {Number} [httpStatusCode] - http status code if available\n * @property {Number} [errorCode] - Twilio public error code if available\n * @event Twilsock#connectionError\n */\n"]},"metadata":{},"sourceType":"script"}