{"ast":null,"code":"'use strict';\n/**\n * Return a Promise that resolves after `timeout` milliseconds.\n * @param {?number} [timeout=0]\n * @returns {Promise<void>}\n */\n\nfunction delay(timeout) {\n  timeout = typeof timeout === 'number' ? timeout : 0;\n  return new Promise(function (resolve) {\n    return setTimeout(resolve, timeout);\n  });\n}\n/**\n * Attempt to detect silence. The Promise returned by this function returns\n * false as soon as audio is detected or true after `timeout` milliseconds.\n * @param {AudioContext} audioContext\n * @param {MediaStream} stream\n * @param {?number} [timeout=250]\n * @returns {Promise<boolean>}\n */\n\n\nfunction detectSilence(audioContext, stream, timeout) {\n  timeout = typeof timeout === 'number' ? timeout : 250;\n  var source = audioContext.createMediaStreamSource(stream);\n  var analyser = audioContext.createAnalyser();\n  analyser.fftSize = 2048;\n  source.connect(analyser);\n  var samples = new Uint8Array(analyser.fftSize);\n  var timeoutDidFire = false;\n  setTimeout(function () {\n    timeoutDidFire = true;\n  }, timeout);\n  /**\n   * We can't use async/await yet, so I need to factor this out.\n   * @returns {Promise<boolean>}\n   */\n\n  function doDetectSilence() {\n    if (timeoutDidFire) {\n      return Promise.resolve(true);\n    }\n\n    analyser.getByteTimeDomainData(samples);\n    return samples.some(function (sample) {\n      return sample;\n    }) ? Promise.resolve(false) : delay().then(doDetectSilence);\n  }\n\n  return doDetectSilence().then(function (isSilent) {\n    source.disconnect();\n    return isSilent;\n  }, function (error) {\n    source.disconnect();\n    throw error;\n  });\n}\n\nmodule.exports = detectSilence;","map":{"version":3,"sources":["/home/ascencion/sebrae_megahack/node_modules/twilio-video/es5/webaudio/detectsilence.js"],"names":["delay","timeout","Promise","resolve","setTimeout","detectSilence","audioContext","stream","source","createMediaStreamSource","analyser","createAnalyser","fftSize","connect","samples","Uint8Array","timeoutDidFire","doDetectSilence","getByteTimeDomainData","some","sample","then","isSilent","disconnect","error","module","exports"],"mappings":"AAAA;AAEA;;;;;;AAMA,SAASA,KAAT,CAAeC,OAAf,EAAwB;AACtBA,EAAAA,OAAO,GAAG,OAAOA,OAAP,KAAmB,QAAnB,GAA8BA,OAA9B,GAAwC,CAAlD;AACA,SAAO,IAAIC,OAAJ,CAAY,UAAUC,OAAV,EAAmB;AACpC,WAAOC,UAAU,CAACD,OAAD,EAAUF,OAAV,CAAjB;AACD,GAFM,CAAP;AAGD;AAED;;;;;;;;;;AAQA,SAASI,aAAT,CAAuBC,YAAvB,EAAqCC,MAArC,EAA6CN,OAA7C,EAAsD;AACpDA,EAAAA,OAAO,GAAG,OAAOA,OAAP,KAAmB,QAAnB,GAA8BA,OAA9B,GAAwC,GAAlD;AAEA,MAAIO,MAAM,GAAGF,YAAY,CAACG,uBAAb,CAAqCF,MAArC,CAAb;AACA,MAAIG,QAAQ,GAAGJ,YAAY,CAACK,cAAb,EAAf;AACAD,EAAAA,QAAQ,CAACE,OAAT,GAAmB,IAAnB;AACAJ,EAAAA,MAAM,CAACK,OAAP,CAAeH,QAAf;AAEA,MAAII,OAAO,GAAG,IAAIC,UAAJ,CAAeL,QAAQ,CAACE,OAAxB,CAAd;AAEA,MAAII,cAAc,GAAG,KAArB;AACAZ,EAAAA,UAAU,CAAC,YAAY;AACrBY,IAAAA,cAAc,GAAG,IAAjB;AACD,GAFS,EAEPf,OAFO,CAAV;AAIA;;;;;AAIA,WAASgB,eAAT,GAA2B;AACzB,QAAID,cAAJ,EAAoB;AAClB,aAAOd,OAAO,CAACC,OAAR,CAAgB,IAAhB,CAAP;AACD;;AACDO,IAAAA,QAAQ,CAACQ,qBAAT,CAA+BJ,OAA/B;AACA,WAAOA,OAAO,CAACK,IAAR,CAAa,UAAUC,MAAV,EAAkB;AACpC,aAAOA,MAAP;AACD,KAFM,IAEFlB,OAAO,CAACC,OAAR,CAAgB,KAAhB,CAFE,GAEuBH,KAAK,GAAGqB,IAAR,CAAaJ,eAAb,CAF9B;AAGD;;AAED,SAAOA,eAAe,GAAGI,IAAlB,CAAuB,UAAUC,QAAV,EAAoB;AAChDd,IAAAA,MAAM,CAACe,UAAP;AACA,WAAOD,QAAP;AACD,GAHM,EAGJ,UAAUE,KAAV,EAAiB;AAClBhB,IAAAA,MAAM,CAACe,UAAP;AACA,UAAMC,KAAN;AACD,GANM,CAAP;AAOD;;AAEDC,MAAM,CAACC,OAAP,GAAiBrB,aAAjB","sourcesContent":["'use strict';\n\n/**\n * Return a Promise that resolves after `timeout` milliseconds.\n * @param {?number} [timeout=0]\n * @returns {Promise<void>}\n */\n\nfunction delay(timeout) {\n  timeout = typeof timeout === 'number' ? timeout : 0;\n  return new Promise(function (resolve) {\n    return setTimeout(resolve, timeout);\n  });\n}\n\n/**\n * Attempt to detect silence. The Promise returned by this function returns\n * false as soon as audio is detected or true after `timeout` milliseconds.\n * @param {AudioContext} audioContext\n * @param {MediaStream} stream\n * @param {?number} [timeout=250]\n * @returns {Promise<boolean>}\n */\nfunction detectSilence(audioContext, stream, timeout) {\n  timeout = typeof timeout === 'number' ? timeout : 250;\n\n  var source = audioContext.createMediaStreamSource(stream);\n  var analyser = audioContext.createAnalyser();\n  analyser.fftSize = 2048;\n  source.connect(analyser);\n\n  var samples = new Uint8Array(analyser.fftSize);\n\n  var timeoutDidFire = false;\n  setTimeout(function () {\n    timeoutDidFire = true;\n  }, timeout);\n\n  /**\n   * We can't use async/await yet, so I need to factor this out.\n   * @returns {Promise<boolean>}\n   */\n  function doDetectSilence() {\n    if (timeoutDidFire) {\n      return Promise.resolve(true);\n    }\n    analyser.getByteTimeDomainData(samples);\n    return samples.some(function (sample) {\n      return sample;\n    }) ? Promise.resolve(false) : delay().then(doDetectSilence);\n  }\n\n  return doDetectSilence().then(function (isSilent) {\n    source.disconnect();\n    return isSilent;\n  }, function (error) {\n    source.disconnect();\n    throw error;\n  });\n}\n\nmodule.exports = detectSilence;"]},"metadata":{},"sourceType":"script"}