{"ast":null,"code":"/* globals RTCPeerConnection */\n'use strict';\n\nvar EventTarget = require('../util/eventtarget');\n\nvar FirefoxRTCSessionDescription = require('../rtcsessiondescription/firefox');\n\nvar inherits = require('util').inherits;\n\nvar updateTracksToSSRCs = require('../util/sdp').updateUnifiedPlanTrackIdsToSSRCs;\n\nvar util = require('../util'); // NOTE(mroberts): This is a short-lived workaround. Checking the user agent\n// string might not fix every affected Firefox instance, but it should be good\n// enough for this bug.\n\n\nvar needsWorkaroundForBug1480277 = typeof navigator === 'object' && navigator.userAgent && (navigator.userAgent.match(/Firefox\\/61/) || navigator.userAgent.match(/Firefox\\/62/)); // NOTE(mroberts): This class wraps Firefox's RTCPeerConnection implementation.\n// It provides some functionality not currently present in Firefox, namely the\n// abilities to\n//\n//   1. Call setLocalDescription and setRemoteDescription with new offers in\n//      signalingStates \"have-local-offer\" and \"have-remote-offer\",\n//      respectively.\n//\n//   2. The ability to call createOffer in signalingState \"have-local-offer\".\n//\n// Both of these are implemented using rollbacks to workaround the following\n// bug:\n//\n//   https://bugzilla.mozilla.org/show_bug.cgi?id=1072388\n//\n// We also provide a workaround for a bug where Firefox may change the\n// previously-negotiated DTLS role in an answer, which breaks Chrome:\n//\n//     https://bugzilla.mozilla.org/show_bug.cgi?id=1240897\n//\n\nfunction FirefoxRTCPeerConnection(configuration) {\n  if (!(this instanceof FirefoxRTCPeerConnection)) {\n    return new FirefoxRTCPeerConnection(configuration);\n  }\n\n  EventTarget.call(this);\n  util.interceptEvent(this, 'signalingstatechange');\n  /* eslint new-cap:0 */\n\n  var peerConnection = new RTCPeerConnection(configuration);\n  Object.defineProperties(this, {\n    _initiallyNegotiatedDtlsRole: {\n      value: null,\n      writable: true\n    },\n    _isClosed: {\n      value: false,\n      writable: true\n    },\n    _peerConnection: {\n      value: peerConnection\n    },\n    _rollingBack: {\n      value: false,\n      writable: true\n    },\n    _tracksToSSRCs: {\n      value: new Map()\n    },\n    iceGatheringState: {\n      enumerable: true,\n      get: function () {\n        return this._isClosed ? 'complete' : this._peerConnection.iceGatheringState;\n      }\n    },\n    localDescription: {\n      enumerable: true,\n      get: function () {\n        return overwriteWithInitiallyNegotiatedDtlsRole(this._peerConnection.localDescription, this._initiallyNegotiatedDtlsRole);\n      }\n    },\n    signalingState: {\n      enumerable: true,\n      get: function () {\n        return this._isClosed ? 'closed' : this._peerConnection.signalingState;\n      }\n    }\n  });\n  var self = this;\n  var previousSignalingState;\n  peerConnection.addEventListener('signalingstatechange', function onsignalingstatechange() {\n    if (!self._rollingBack && self.signalingState !== previousSignalingState) {\n      previousSignalingState = self.signalingState; // NOTE(mmalavalli): In Firefox, 'signalingstatechange' event is\n      // triggered synchronously in the same tick after\n      // RTCPeerConnection#close() is called. So we mimic Chrome's behavior\n      // by triggering 'signalingstatechange' on the next tick.\n\n      var dispatchEventToSelf = self.dispatchEvent.apply.bind(self.dispatchEvent, self, arguments);\n\n      if (self._isClosed) {\n        setTimeout(dispatchEventToSelf);\n      } else {\n        dispatchEventToSelf();\n      }\n    }\n  });\n  util.proxyProperties(RTCPeerConnection.prototype, this, peerConnection);\n}\n\ninherits(FirefoxRTCPeerConnection, EventTarget); // NOTE(mmalavalli): Firefox throws a TypeError when the PeerConnection's\n// prototype's \"peerIdentity\" property is accessed. In order to overcome\n// this, we ignore this property while delegating methods.\n// Reference: https://bugzilla.mozilla.org/show_bug.cgi?id=1363815\n\nObject.defineProperty(FirefoxRTCPeerConnection.prototype, 'peerIdentity', {\n  enumerable: true,\n  value: Promise.resolve({\n    idp: '',\n    name: ''\n  })\n});\n\nif (needsWorkaroundForBug1480277) {\n  FirefoxRTCPeerConnection.prototype.addTrack = function addTrack() {\n    var track = arguments[0];\n\n    var sender = this._peerConnection.addTrack.apply(this._peerConnection, arguments);\n\n    sender.replaceTrack(track);\n    return sender;\n  };\n}\n\nFirefoxRTCPeerConnection.prototype.createAnswer = function createAnswer() {\n  var args = [].slice.call(arguments);\n  var promise;\n  var self = this;\n  promise = this._peerConnection.createAnswer().then(function createAnswerSucceeded(answer) {\n    saveInitiallyNegotiatedDtlsRole(self, answer);\n    return overwriteWithInitiallyNegotiatedDtlsRole(answer, self._initiallyNegotiatedDtlsRole);\n  });\n  return typeof args[0] === 'function' ? util.legacyPromise(promise, args[0], args[1]) : promise;\n}; // NOTE(mroberts): The WebRTC spec allows you to call createOffer from any\n// signalingState other than \"closed\"; however, Firefox has not yet implemented\n// this (https://bugzilla.mozilla.org/show_bug.cgi?id=1072388). We workaround\n// this by rolling back if we are in state \"have-local-offer\" or\n// \"have-remote-offer\". This is acceptable for our use case because we will\n// apply the newly-created offer almost immediately; however, this may be\n// unacceptable for other use cases.\n\n\nFirefoxRTCPeerConnection.prototype.createOffer = function createOffer() {\n  var args = [].slice.call(arguments);\n  var options = (args.length > 1 ? args[2] : args[0]) || {};\n  var promise;\n  var self = this;\n\n  if (this.signalingState === 'have-local-offer' || this.signalingState === 'have-remote-offer') {\n    var local = this.signalingState === 'have-local-offer';\n    promise = rollback(this, local, function rollbackSucceeded() {\n      return self.createOffer(options);\n    });\n  } else {\n    promise = self._peerConnection.createOffer(options);\n  }\n\n  promise = promise.then(function (offer) {\n    return new FirefoxRTCSessionDescription({\n      type: offer.type,\n      sdp: updateTracksToSSRCs(self._tracksToSSRCs, offer.sdp)\n    });\n  });\n  return args.length > 1 ? util.legacyPromise(promise, args[0], args[1]) : promise;\n}; // NOTE(mroberts): While Firefox will reject the Promise returned by\n// setLocalDescription when called from signalingState \"have-local-offer\" with\n// an answer, it still updates the .localDescription property. We workaround\n// this by explicitly handling this case.\n\n\nFirefoxRTCPeerConnection.prototype.setLocalDescription = function setLocalDescription() {\n  var args = [].slice.call(arguments);\n  var description = args[0];\n  var promise;\n\n  if (description && description.type === 'answer' && this.signalingState === 'have-local-offer') {\n    promise = Promise.reject(new Error('Cannot set local answer in state have-local-offer'));\n  }\n\n  if (promise) {\n    return args.length > 1 ? util.legacyPromise(promise, args[1], args[2]) : promise;\n  }\n\n  return this._peerConnection.setLocalDescription.apply(this._peerConnection, args);\n}; // NOTE(mroberts): The WebRTC spec allows you to call setRemoteDescription with\n// an offer multiple times in signalingState \"have-remote-offer\"; however,\n// Firefox has not yet implemented this (https://bugzilla.mozilla.org/show_bug.cgi?id=1072388).\n// We workaround this by rolling back if we are in state \"have-remote-offer\".\n// This is acceptable for our use case; however, this may be unacceptable for\n// other use cases.\n//\n// While Firefox will reject the Promise returned by setRemoteDescription when\n// called from signalingState \"have-remote-offer\" with an answer, it sill\n// updates the .remoteDescription property. We workaround this by explicitly\n// handling this case.\n\n\nFirefoxRTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription() {\n  var args = [].slice.call(arguments);\n  var description = args[0];\n  var promise;\n  var self = this;\n\n  if (description && this.signalingState === 'have-remote-offer') {\n    if (description.type === 'answer') {\n      promise = Promise.reject(new Error('Cannot set remote answer in state have-remote-offer'));\n    } else if (description.type === 'offer') {\n      promise = rollback(this, false, function rollbackSucceeded() {\n        return self._peerConnection.setRemoteDescription(description);\n      });\n    }\n  }\n\n  if (!promise) {\n    promise = this._peerConnection.setRemoteDescription(description);\n  }\n\n  promise = promise.then(function setRemoteDescriptionSucceeded() {\n    saveInitiallyNegotiatedDtlsRole(self, description, true);\n  });\n  return args.length > 1 ? util.legacyPromise(promise, args[1], args[2]) : promise;\n}; // NOTE(mroberts): The WebRTC spec specifies that the PeerConnection's internal\n// isClosed slot should immediately be set to true; however, in Firefox it\n// occurs in the next tick. We workaround this by tracking isClosed manually.\n\n\nFirefoxRTCPeerConnection.prototype.close = function close() {\n  if (this.signalingState !== 'closed') {\n    this._isClosed = true;\n\n    this._peerConnection.close();\n  }\n};\n\nutil.delegateMethods(RTCPeerConnection.prototype, FirefoxRTCPeerConnection.prototype, '_peerConnection');\n\nfunction rollback(peerConnection, local, onceRolledBack) {\n  var setLocalDescription = local ? 'setLocalDescription' : 'setRemoteDescription';\n  peerConnection._rollingBack = true;\n  return peerConnection._peerConnection[setLocalDescription](new FirefoxRTCSessionDescription({\n    type: 'rollback'\n  })).then(onceRolledBack).then(function onceRolledBackSucceeded(result) {\n    peerConnection._rollingBack = false;\n    return result;\n  }, function rollbackOrOnceRolledBackFailed(error) {\n    peerConnection._rollingBack = false;\n    throw error;\n  });\n}\n/**\n * Extract the initially negotiated DTLS role out of an RTCSessionDescription's\n * sdp property and save it on the FirefoxRTCPeerConnection if and only if\n *\n *   1. A DTLS role was not already saved on the FirefoxRTCPeerConnection, and\n *   2. The description is an answer.\n *\n * @private\n * @param {FirefoxRTCPeerConnection} peerConnection\n * @param {RTCSessionDescription} description\n * @param {boolean} [remote=false] - if true, save the inverse of the DTLS role,\n *   e.g. \"active\" instead of \"passive\" and vice versa\n * @returns {undefined}\n */\n\n\nfunction saveInitiallyNegotiatedDtlsRole(peerConnection, description, remote) {\n  // NOTE(mroberts): JSEP specifies that offers always offer \"actpass\" as the\n  // DTLS role. We need to inspect answers to figure out the negotiated DTLS\n  // role.\n  if (peerConnection._initiallyNegotiatedDtlsRole || description.type === 'offer') {\n    return;\n  }\n\n  var match = description.sdp.match(/a=setup:([a-z]+)/);\n\n  if (!match) {\n    return;\n  }\n\n  var dtlsRole = match[1];\n  peerConnection._initiallyNegotiatedDtlsRole = remote ? {\n    active: 'passive',\n    passive: 'active'\n  }[dtlsRole] : dtlsRole;\n}\n/**\n * Overwrite the DTLS role in the sdp property of an RTCSessionDescription if\n * and only if\n *\n *   1. The description is an answer, and\n *   2. A DTLS role is provided.\n *\n * @private\n * @param {RTCSessionDescription} [description]\n * @param {string} [dtlsRole] - one of \"active\" or \"passive\"\n * @returns {?RTCSessionDescription} description\n */\n\n\nfunction overwriteWithInitiallyNegotiatedDtlsRole(description, dtlsRole) {\n  if (description && description.type === 'answer' && dtlsRole) {\n    return new FirefoxRTCSessionDescription({\n      type: description.type,\n      sdp: description.sdp.replace(/a=setup:[a-z]+/g, 'a=setup:' + dtlsRole)\n    });\n  }\n\n  return description;\n}\n\nmodule.exports = FirefoxRTCPeerConnection;","map":{"version":3,"sources":["/home/ascencion/sebrae_megahack/node_modules/@twilio/webrtc/lib/rtcpeerconnection/firefox.js"],"names":["EventTarget","require","FirefoxRTCSessionDescription","inherits","updateTracksToSSRCs","updateUnifiedPlanTrackIdsToSSRCs","util","needsWorkaroundForBug1480277","navigator","userAgent","match","FirefoxRTCPeerConnection","configuration","call","interceptEvent","peerConnection","RTCPeerConnection","Object","defineProperties","_initiallyNegotiatedDtlsRole","value","writable","_isClosed","_peerConnection","_rollingBack","_tracksToSSRCs","Map","iceGatheringState","enumerable","get","localDescription","overwriteWithInitiallyNegotiatedDtlsRole","signalingState","self","previousSignalingState","addEventListener","onsignalingstatechange","dispatchEventToSelf","dispatchEvent","apply","bind","arguments","setTimeout","proxyProperties","prototype","defineProperty","Promise","resolve","idp","name","addTrack","track","sender","replaceTrack","createAnswer","args","slice","promise","then","createAnswerSucceeded","answer","saveInitiallyNegotiatedDtlsRole","legacyPromise","createOffer","options","length","local","rollback","rollbackSucceeded","offer","type","sdp","setLocalDescription","description","reject","Error","setRemoteDescription","setRemoteDescriptionSucceeded","close","delegateMethods","onceRolledBack","onceRolledBackSucceeded","result","rollbackOrOnceRolledBackFailed","error","remote","dtlsRole","active","passive","replace","module","exports"],"mappings":"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","sourcesContent":["/* globals RTCPeerConnection */\n'use strict';\n\nvar EventTarget = require('../util/eventtarget');\nvar FirefoxRTCSessionDescription = require('../rtcsessiondescription/firefox');\nvar inherits = require('util').inherits;\nvar updateTracksToSSRCs = require('../util/sdp').updateUnifiedPlanTrackIdsToSSRCs;\nvar util = require('../util');\n\n// NOTE(mroberts): This is a short-lived workaround. Checking the user agent\n// string might not fix every affected Firefox instance, but it should be good\n// enough for this bug.\nvar needsWorkaroundForBug1480277 = typeof navigator === 'object'\n  && navigator.userAgent\n  && (navigator.userAgent.match(/Firefox\\/61/) || navigator.userAgent.match(/Firefox\\/62/));\n\n// NOTE(mroberts): This class wraps Firefox's RTCPeerConnection implementation.\n// It provides some functionality not currently present in Firefox, namely the\n// abilities to\n//\n//   1. Call setLocalDescription and setRemoteDescription with new offers in\n//      signalingStates \"have-local-offer\" and \"have-remote-offer\",\n//      respectively.\n//\n//   2. The ability to call createOffer in signalingState \"have-local-offer\".\n//\n// Both of these are implemented using rollbacks to workaround the following\n// bug:\n//\n//   https://bugzilla.mozilla.org/show_bug.cgi?id=1072388\n//\n// We also provide a workaround for a bug where Firefox may change the\n// previously-negotiated DTLS role in an answer, which breaks Chrome:\n//\n//     https://bugzilla.mozilla.org/show_bug.cgi?id=1240897\n//\nfunction FirefoxRTCPeerConnection(configuration) {\n  if (!(this instanceof FirefoxRTCPeerConnection)) {\n    return new FirefoxRTCPeerConnection(configuration);\n  }\n\n  EventTarget.call(this);\n\n  util.interceptEvent(this, 'signalingstatechange');\n\n  /* eslint new-cap:0 */\n  var peerConnection = new RTCPeerConnection(configuration);\n\n  Object.defineProperties(this, {\n    _initiallyNegotiatedDtlsRole: {\n      value: null,\n      writable: true\n    },\n    _isClosed: {\n      value: false,\n      writable: true\n    },\n    _peerConnection: {\n      value: peerConnection\n    },\n    _rollingBack: {\n      value: false,\n      writable: true\n    },\n    _tracksToSSRCs: {\n      value: new Map()\n    },\n    iceGatheringState: {\n      enumerable: true,\n      get: function() {\n        return this._isClosed ? 'complete' : this._peerConnection.iceGatheringState;\n      }\n    },\n    localDescription: {\n      enumerable: true,\n      get: function() {\n        return overwriteWithInitiallyNegotiatedDtlsRole(this._peerConnection.localDescription, this._initiallyNegotiatedDtlsRole);\n      }\n    },\n    signalingState: {\n      enumerable: true,\n      get: function() {\n        return this._isClosed ? 'closed' : this._peerConnection.signalingState;\n      }\n    }\n  });\n\n  var self = this;\n  var previousSignalingState;\n\n  peerConnection.addEventListener('signalingstatechange', function onsignalingstatechange() {\n    if (!self._rollingBack && self.signalingState !== previousSignalingState) {\n      previousSignalingState = self.signalingState;\n\n      // NOTE(mmalavalli): In Firefox, 'signalingstatechange' event is\n      // triggered synchronously in the same tick after\n      // RTCPeerConnection#close() is called. So we mimic Chrome's behavior\n      // by triggering 'signalingstatechange' on the next tick.\n      var dispatchEventToSelf = self.dispatchEvent.apply.bind(self.dispatchEvent, self, arguments);\n      if (self._isClosed) {\n        setTimeout(dispatchEventToSelf);\n      } else {\n        dispatchEventToSelf();\n      }\n    }\n  });\n\n  util.proxyProperties(RTCPeerConnection.prototype, this, peerConnection);\n}\n\ninherits(FirefoxRTCPeerConnection, EventTarget);\n\n// NOTE(mmalavalli): Firefox throws a TypeError when the PeerConnection's\n// prototype's \"peerIdentity\" property is accessed. In order to overcome\n// this, we ignore this property while delegating methods.\n// Reference: https://bugzilla.mozilla.org/show_bug.cgi?id=1363815\nObject.defineProperty(FirefoxRTCPeerConnection.prototype, 'peerIdentity', {\n  enumerable: true,\n  value: Promise.resolve({\n    idp: '',\n    name: ''\n  })\n});\n\nif (needsWorkaroundForBug1480277) {\n  FirefoxRTCPeerConnection.prototype.addTrack = function addTrack() {\n    var track = arguments[0];\n    var sender = this._peerConnection.addTrack.apply(this._peerConnection, arguments);\n    sender.replaceTrack(track);\n    return sender;\n  };\n}\n\nFirefoxRTCPeerConnection.prototype.createAnswer = function createAnswer() {\n  var args = [].slice.call(arguments);\n  var promise;\n  var self = this;\n\n  promise = this._peerConnection.createAnswer().then(function createAnswerSucceeded(answer) {\n    saveInitiallyNegotiatedDtlsRole(self, answer);\n    return overwriteWithInitiallyNegotiatedDtlsRole(answer, self._initiallyNegotiatedDtlsRole);\n  });\n\n  return typeof args[0] === 'function'\n    ? util.legacyPromise(promise, args[0], args[1])\n    : promise;\n};\n\n// NOTE(mroberts): The WebRTC spec allows you to call createOffer from any\n// signalingState other than \"closed\"; however, Firefox has not yet implemented\n// this (https://bugzilla.mozilla.org/show_bug.cgi?id=1072388). We workaround\n// this by rolling back if we are in state \"have-local-offer\" or\n// \"have-remote-offer\". This is acceptable for our use case because we will\n// apply the newly-created offer almost immediately; however, this may be\n// unacceptable for other use cases.\nFirefoxRTCPeerConnection.prototype.createOffer = function createOffer() {\n  var args = [].slice.call(arguments);\n  var options = (args.length > 1 ? args[2] : args[0]) || {};\n  var promise;\n  var self = this;\n\n  if (this.signalingState === 'have-local-offer' ||\n      this.signalingState === 'have-remote-offer') {\n    var local = this.signalingState === 'have-local-offer';\n    promise = rollback(this, local, function rollbackSucceeded() {\n      return self.createOffer(options);\n    });\n  } else {\n    promise = self._peerConnection.createOffer(options);\n  }\n\n  promise = promise.then(function(offer) {\n    return new FirefoxRTCSessionDescription({\n      type: offer.type,\n      sdp: updateTracksToSSRCs(self._tracksToSSRCs, offer.sdp)\n    });\n  });\n\n  return args.length > 1\n    ? util.legacyPromise(promise, args[0], args[1])\n    : promise;\n};\n\n// NOTE(mroberts): While Firefox will reject the Promise returned by\n// setLocalDescription when called from signalingState \"have-local-offer\" with\n// an answer, it still updates the .localDescription property. We workaround\n// this by explicitly handling this case.\nFirefoxRTCPeerConnection.prototype.setLocalDescription = function setLocalDescription() {\n  var args = [].slice.call(arguments);\n  var description = args[0];\n  var promise;\n\n  if (description && description.type === 'answer' && this.signalingState === 'have-local-offer') {\n    promise = Promise.reject(new Error('Cannot set local answer in state have-local-offer'));\n  }\n\n  if (promise) {\n    return args.length > 1\n      ? util.legacyPromise(promise, args[1], args[2])\n      : promise;\n  }\n\n  return this._peerConnection.setLocalDescription.apply(this._peerConnection, args);\n};\n\n// NOTE(mroberts): The WebRTC spec allows you to call setRemoteDescription with\n// an offer multiple times in signalingState \"have-remote-offer\"; however,\n// Firefox has not yet implemented this (https://bugzilla.mozilla.org/show_bug.cgi?id=1072388).\n// We workaround this by rolling back if we are in state \"have-remote-offer\".\n// This is acceptable for our use case; however, this may be unacceptable for\n// other use cases.\n//\n// While Firefox will reject the Promise returned by setRemoteDescription when\n// called from signalingState \"have-remote-offer\" with an answer, it sill\n// updates the .remoteDescription property. We workaround this by explicitly\n// handling this case.\nFirefoxRTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription() {\n  var args = [].slice.call(arguments);\n  var description = args[0];\n  var promise;\n  var self = this;\n\n  if (description && this.signalingState === 'have-remote-offer') {\n    if (description.type === 'answer') {\n      promise = Promise.reject(new Error('Cannot set remote answer in state have-remote-offer'));\n    } else if (description.type === 'offer') {\n      promise = rollback(this, false, function rollbackSucceeded() {\n        return self._peerConnection.setRemoteDescription(description);\n      });\n    }\n  }\n\n  if (!promise) {\n    promise = this._peerConnection.setRemoteDescription(description);\n  }\n\n  promise = promise.then(function setRemoteDescriptionSucceeded() {\n    saveInitiallyNegotiatedDtlsRole(self, description, true);\n  });\n\n  return args.length > 1\n    ? util.legacyPromise(promise, args[1], args[2])\n    : promise;\n};\n\n// NOTE(mroberts): The WebRTC spec specifies that the PeerConnection's internal\n// isClosed slot should immediately be set to true; however, in Firefox it\n// occurs in the next tick. We workaround this by tracking isClosed manually.\nFirefoxRTCPeerConnection.prototype.close = function close() {\n  if (this.signalingState !== 'closed') {\n    this._isClosed = true;\n    this._peerConnection.close();\n  }\n};\n\nutil.delegateMethods(\n  RTCPeerConnection.prototype,\n  FirefoxRTCPeerConnection.prototype,\n  '_peerConnection');\n\nfunction rollback(peerConnection, local, onceRolledBack) {\n  var setLocalDescription = local ? 'setLocalDescription' : 'setRemoteDescription';\n  peerConnection._rollingBack = true;\n  return peerConnection._peerConnection[setLocalDescription](new FirefoxRTCSessionDescription({\n    type: 'rollback'\n  })).then(onceRolledBack).then(function onceRolledBackSucceeded(result) {\n    peerConnection._rollingBack = false;\n    return result;\n  }, function rollbackOrOnceRolledBackFailed(error) {\n    peerConnection._rollingBack = false;\n    throw error;\n  });\n}\n\n/**\n * Extract the initially negotiated DTLS role out of an RTCSessionDescription's\n * sdp property and save it on the FirefoxRTCPeerConnection if and only if\n *\n *   1. A DTLS role was not already saved on the FirefoxRTCPeerConnection, and\n *   2. The description is an answer.\n *\n * @private\n * @param {FirefoxRTCPeerConnection} peerConnection\n * @param {RTCSessionDescription} description\n * @param {boolean} [remote=false] - if true, save the inverse of the DTLS role,\n *   e.g. \"active\" instead of \"passive\" and vice versa\n * @returns {undefined}\n */\nfunction saveInitiallyNegotiatedDtlsRole(peerConnection, description, remote) {\n  // NOTE(mroberts): JSEP specifies that offers always offer \"actpass\" as the\n  // DTLS role. We need to inspect answers to figure out the negotiated DTLS\n  // role.\n  if (peerConnection._initiallyNegotiatedDtlsRole || description.type === 'offer') {\n    return;\n  }\n\n  var match = description.sdp.match(/a=setup:([a-z]+)/);\n  if (!match) {\n    return;\n  }\n\n  var dtlsRole = match[1];\n  peerConnection._initiallyNegotiatedDtlsRole = remote ? {\n    active: 'passive',\n    passive: 'active'\n  }[dtlsRole] : dtlsRole;\n}\n\n/**\n * Overwrite the DTLS role in the sdp property of an RTCSessionDescription if\n * and only if\n *\n *   1. The description is an answer, and\n *   2. A DTLS role is provided.\n *\n * @private\n * @param {RTCSessionDescription} [description]\n * @param {string} [dtlsRole] - one of \"active\" or \"passive\"\n * @returns {?RTCSessionDescription} description\n */\nfunction overwriteWithInitiallyNegotiatedDtlsRole(description, dtlsRole) {\n  if (description && description.type === 'answer' && dtlsRole) {\n    return new FirefoxRTCSessionDescription({\n      type: description.type,\n      sdp: description.sdp.replace(/a=setup:[a-z]+/g, 'a=setup:' + dtlsRole)\n    });\n  }\n  return description;\n}\n\nmodule.exports = FirefoxRTCPeerConnection;\n"]},"metadata":{},"sourceType":"script"}