{"ast":null,"code":"/* globals RTCDataChannel, RTCPeerConnection, RTCSessionDescription */\n'use strict';\n\nvar ChromeRTCSessionDescription = require('../rtcsessiondescription/chrome');\n\nvar EventTarget = require('../util/eventtarget');\n\nvar inherits = require('util').inherits;\n\nvar Latch = require('../util/latch');\n\nvar MediaStream = require('../mediastream');\n\nvar RTCRtpSenderShim = require('../rtcrtpsender');\n\nvar sdpUtils = require('../util/sdp');\n\nvar util = require('../util'); // NOTE(mroberts): This class wraps Chrome's RTCPeerConnection implementation.\n// It provides some functionality not currently present in Chrome, namely the\n// abilities to\n//\n//   1. Rollback, per the workaround suggested here:\n//      https://bugs.chromium.org/p/webrtc/issues/detail?id=5738#c3\n//\n//   2. Listen for track events, per the adapter.js workaround.\n//\n//   3. Set iceTransportPolicy.\n//\n\n\nfunction ChromeRTCPeerConnection(configuration, constraints) {\n  if (!(this instanceof ChromeRTCPeerConnection)) {\n    return new ChromeRTCPeerConnection(configuration, constraints);\n  }\n\n  EventTarget.call(this);\n  configuration = configuration || {};\n  var newConfiguration = Object.assign(configuration.iceTransportPolicy ? {\n    iceTransports: configuration.iceTransportPolicy\n  } : {}, configuration);\n  util.interceptEvent(this, 'datachannel');\n  util.interceptEvent(this, 'signalingstatechange');\n  var sdpFormat = sdpUtils.getSdpFormat(newConfiguration.sdpSemantics);\n  var peerConnection = new RTCPeerConnection(newConfiguration, constraints);\n  Object.defineProperties(this, {\n    _appliedTracksToSSRCs: {\n      value: new Map(),\n      writable: true\n    },\n    _localStream: {\n      value: new MediaStream()\n    },\n    _peerConnection: {\n      value: peerConnection\n    },\n    _pendingLocalOffer: {\n      value: null,\n      writable: true\n    },\n    _pendingRemoteOffer: {\n      value: null,\n      writable: true\n    },\n    _rolledBackTracksToSSRCs: {\n      value: new Map(),\n      writable: true\n    },\n    _sdpFormat: {\n      value: sdpFormat\n    },\n    _senders: {\n      value: new Map()\n    },\n    _signalingStateLatch: {\n      value: new Latch()\n    },\n    _tracksToSSRCs: {\n      value: new Map(),\n      writable: true\n    },\n    localDescription: {\n      enumerable: true,\n      get: function () {\n        return this._pendingLocalOffer ? this._pendingLocalOffer : peerConnection.localDescription;\n      }\n    },\n    remoteDescription: {\n      enumerable: true,\n      get: function () {\n        return this._pendingRemoteOffer ? this._pendingRemoteOffer : peerConnection.remoteDescription;\n      }\n    },\n    signalingState: {\n      enumerable: true,\n      get: function () {\n        if (this._pendingLocalOffer) {\n          return 'have-local-offer';\n        } else if (this._pendingRemoteOffer) {\n          return 'have-remote-offer';\n        }\n\n        return peerConnection.signalingState;\n      }\n    }\n  });\n  var self = this;\n  peerConnection.addEventListener('datachannel', function ondatachannel(event) {\n    shimDataChannel(event.channel);\n    self.dispatchEvent(event);\n  });\n  peerConnection.addEventListener('signalingstatechange', function onsignalingstatechange() {\n    if (peerConnection.signalingState === 'stable') {\n      self._appliedTracksToSSRCs = new Map(self._tracksToSSRCs);\n    }\n\n    if (!self._pendingLocalOffer && !self._pendingRemoteOffer) {\n      self.dispatchEvent.apply(self, arguments);\n    }\n  });\n\n  peerConnection.ontrack = function ontrack() {// NOTE(mroberts): adapter.js's \"track\" event shim only kicks off if we set\n    // the ontrack property of the RTCPeerConnection.\n  };\n\n  if (typeof RTCPeerConnection.prototype.addTrack !== 'function') {\n    peerConnection.addStream(this._localStream);\n  }\n\n  util.proxyProperties(RTCPeerConnection.prototype, this, peerConnection);\n}\n\ninherits(ChromeRTCPeerConnection, EventTarget);\n\nif (typeof RTCPeerConnection.prototype.addTrack !== 'function') {\n  // NOTE(mmalavalli): This shim supports our limited case of adding\n  // all MediaStreamTracks to one MediaStream. It has been implemented this\n  // keeping in mind that this is to be maintained only until \"addTrack\" is\n  // supported natively in Chrome.\n  ChromeRTCPeerConnection.prototype.addTrack = function addTrack() {\n    var args = [].slice.call(arguments);\n    var track = args[0];\n\n    if (this._peerConnection.signalingState === 'closed') {\n      throw new Error('Cannot add MediaStreamTrack [' + track.id + ', ' + track.kind + ']: RTCPeerConnection is closed');\n    }\n\n    var sender = this._senders.get(track);\n\n    if (sender && sender.track) {\n      throw new Error('Cannot add MediaStreamTrack [' + track.id + ', ' + track.kind + ']: RTCPeerConnection already has it');\n    }\n\n    this._peerConnection.removeStream(this._localStream);\n\n    this._localStream.addTrack(track);\n\n    this._peerConnection.addStream(this._localStream);\n\n    sender = new RTCRtpSenderShim(track);\n\n    this._senders.set(track, sender);\n\n    return sender;\n  }; // NOTE(mmalavalli): This shim supports our limited case of removing\n  // MediaStreamTracks from one MediaStream. It has been implemented this\n  // keeping in mind that this is to be maintained only until \"removeTrack\" is\n  // supported natively in Chrome.\n\n\n  ChromeRTCPeerConnection.prototype.removeTrack = function removeTrack(sender) {\n    if (this._peerConnection.signalingState === 'closed') {\n      throw new Error('Cannot remove MediaStreamTrack: RTCPeerConnection is closed');\n    }\n\n    var track = sender.track;\n\n    if (!track) {\n      return;\n    }\n\n    sender = this._senders.get(track);\n\n    if (sender && sender.track) {\n      sender.track = null;\n\n      this._peerConnection.removeStream(this._localStream);\n\n      this._localStream.removeTrack(track);\n\n      this._peerConnection.addStream(this._localStream);\n    }\n  };\n\n  ChromeRTCPeerConnection.prototype.getSenders = function getSenders() {\n    return Array.from(this._senders.values());\n  };\n} else {\n  ChromeRTCPeerConnection.prototype.removeTrack = function removeTrack(sender) {\n    if (this._peerConnection.signalingState === 'closed') {\n      throw new Error('Cannot remove MediaStreamTrack: RTCPeerConnection is closed');\n    }\n\n    try {\n      this._peerConnection.removeTrack(sender);\n    } catch (e) {// NOTE(mhuynh): Do nothing. In Chrome, will throw if a 'sender was not\n      // created by this peer connection'. This behavior does not seem to be\n      // spec compliant, so a temporary shim is introduced. A bug has been filed,\n      // and is tracked here:\n      // https://bugs.chromium.org/p/chromium/issues/detail?id=860853\n    }\n  };\n}\n\nChromeRTCPeerConnection.prototype.addIceCandidate = function addIceCandidate(candidate) {\n  var args = [].slice.call(arguments);\n  var promise;\n  var self = this;\n\n  if (this.signalingState === 'have-remote-offer') {\n    // NOTE(mroberts): Because the ChromeRTCPeerConnection simulates the\n    // \"have-remote-offer\" signalingStates, we only want to invoke the true\n    // addIceCandidates method when the remote description has been applied.\n    promise = this._signalingStateLatch.when('low').then(function signalingStatesResolved() {\n      return self._peerConnection.addIceCandidate(candidate);\n    });\n  } else {\n    promise = this._peerConnection.addIceCandidate(candidate);\n  }\n\n  return args.length > 1 ? util.legacyPromise(promise, args[1], args[2]) : promise;\n}; // NOTE(mroberts): The WebRTC spec does not specify that close should throw an\n// Error; however, in Chrome it does. We workaround this by checking the\n// signalingState manually.\n\n\nChromeRTCPeerConnection.prototype.close = function close() {\n  if (this.signalingState !== 'closed') {\n    this._pendingLocalOffer = null;\n    this._pendingRemoteOffer = null;\n\n    this._peerConnection.close();\n  }\n}; // NOTE(mroberts): Because we workaround Chrome's lack of rollback support by\n// \"faking\" setRemoteDescription, we cannot create an answer until we actually\n// apply the remote description. This means, once you call createAnswer, you\n// can no longer rollback. This is acceptable for our use case because we will\n// apply the newly-created answer almost immediately; however, this may be\n// unacceptable for other use cases.\n\n\nChromeRTCPeerConnection.prototype.createAnswer = function createAnswer() {\n  var args = [].slice.call(arguments);\n  var promise;\n  var self = this;\n\n  if (this._pendingRemoteOffer) {\n    promise = this._peerConnection.setRemoteDescription(this._pendingRemoteOffer).then(function setRemoteDescriptionSucceeded() {\n      // NOTE(mroberts): The signalingStates between the ChromeRTCPeerConnection\n      // and the underlying RTCPeerConnection implementation have converged. We\n      // can unblock any pending calls to addIceCandidate now.\n      self._signalingStateLatch.lower();\n\n      return self._peerConnection.createAnswer();\n    }).then(function createAnswerSucceeded(answer) {\n      self._pendingRemoteOffer = null; // NOTE(mmalavalli): If createAnswer() is called immediately after rolling back, then we no\n      // longer need to retain the rolled back tracks to SSRCs Map.\n\n      self._rolledBackTracksToSSRCs.clear();\n\n      return new ChromeRTCSessionDescription({\n        type: 'answer',\n        sdp: updateTrackIdsToSSRCs(self._sdpFormat, self._tracksToSSRCs, answer.sdp)\n      });\n    }, function setRemoteDescriptionOrCreateAnswerFailed(error) {\n      self._pendingRemoteOffer = null;\n      throw error;\n    });\n  } else {\n    promise = this._peerConnection.createAnswer().then(function (answer) {\n      // NOTE(mmalavalli): If createAnswer() is called immediately after rolling back, then we no\n      // longer need to retain the rolled back tracks to SSRCs Map.\n      self._rolledBackTracksToSSRCs.clear();\n\n      return new ChromeRTCSessionDescription({\n        type: 'answer',\n        sdp: updateTrackIdsToSSRCs(self._sdpFormat, self._tracksToSSRCs, answer.sdp)\n      });\n    });\n  }\n\n  return args.length > 1 ? util.legacyPromise(promise, args[0], args[1]) : promise;\n};\n\nChromeRTCPeerConnection.prototype.createOffer = function createOffer() {\n  var args = [].slice.call(arguments);\n  var options = (args.length > 1 ? args[2] : args[0]) || {};\n  var self = this;\n\n  var promise = this._peerConnection.createOffer(options).then(function (offer) {\n    // NOTE(mmalavalli): If createOffer() is called immediately after rolling back, then we no\n    // longer need to retain the rolled back tracks to SSRCs Map.\n    self._rolledBackTracksToSSRCs.clear();\n\n    return new ChromeRTCSessionDescription({\n      type: offer.type,\n      sdp: updateTrackIdsToSSRCs(self._sdpFormat, self._tracksToSSRCs, offer.sdp)\n    });\n  });\n\n  return args.length > 1 ? util.legacyPromise(promise, args[0], args[1]) : promise;\n};\n\nChromeRTCPeerConnection.prototype.createDataChannel = function createDataChannel(label, dataChannelDict) {\n  dataChannelDict = shimDataChannelInit(dataChannelDict);\n\n  var dataChannel = this._peerConnection.createDataChannel(label, dataChannelDict);\n\n  shimDataChannel(dataChannel);\n  return dataChannel;\n};\n\nChromeRTCPeerConnection.prototype.setLocalDescription = function setLocalDescription() {\n  var args = [].slice.call(arguments);\n  var description = args[0]; // NOTE(mmalavalli): If setLocalDescription() is called immediately after rolling back,\n  // then we need to restore the rolled back tracks to SSRCs Map.\n\n  if (this._rolledBackTracksToSSRCs.size > 0) {\n    this._tracksToSSRCs = new Map(this._rolledBackTracksToSSRCs);\n\n    this._rolledBackTracksToSSRCs.clear();\n  }\n\n  var promise = setDescription(this, true, description);\n  return args.length > 1 ? util.legacyPromise(promise, args[1], args[2]) : promise;\n};\n\nChromeRTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription() {\n  var args = [].slice.call(arguments);\n  var description = args[0]; // NOTE(mmalavalli): If setRemoteDescription() is called immediately after rolling back,\n  // then we no longer need to retain the rolled back tracks to SSRCs Map.\n\n  this._rolledBackTracksToSSRCs.clear();\n\n  var promise = setDescription(this, false, description);\n  return args.length > 1 ? util.legacyPromise(promise, args[1], args[2]) : promise;\n};\n\nutil.delegateMethods(RTCPeerConnection.prototype, ChromeRTCPeerConnection.prototype, '_peerConnection'); // NOTE(mroberts): We workaround Chrome's lack of rollback support, per the\n// workaround suggested here: https://bugs.chromium.org/p/webrtc/issues/detail?id=5738#c3\n// Namely, we \"fake\" setting the local or remote description and instead buffer\n// it. If we receive or create an answer, then we will actually apply the\n// description. Until we receive or create an answer, we will be able to\n// \"rollback\" by simply discarding the buffer description.\n\nfunction setDescription(peerConnection, local, description) {\n  function setPendingLocalOffer(offer) {\n    if (local) {\n      peerConnection._pendingLocalOffer = offer;\n    } else {\n      peerConnection._pendingRemoteOffer = offer;\n    }\n  }\n\n  function clearPendingLocalOffer() {\n    if (local) {\n      peerConnection._pendingLocalOffer = null;\n    } else {\n      peerConnection._pendingRemoteOffer = null;\n    }\n  }\n\n  var pendingLocalOffer = local ? peerConnection._pendingLocalOffer : peerConnection._pendingRemoteOffer;\n  var pendingRemoteOffer = local ? peerConnection._pendingRemoteOffer : peerConnection._pendingLocalOffer;\n  var intermediateState = local ? 'have-local-offer' : 'have-remote-offer';\n  var setLocalDescription = local ? 'setLocalDescription' : 'setRemoteDescription';\n  var promise;\n\n  if (!local && pendingRemoteOffer && description.type === 'answer') {\n    promise = setRemoteAnswer(peerConnection, description);\n  } else if (description.type === 'offer') {\n    if (peerConnection.signalingState !== intermediateState && peerConnection.signalingState !== 'stable') {\n      // NOTE(mroberts): Error message copied from Firefox.\n      return Promise.reject(new Error('Cannot set ' + (local ? 'local' : 'remote') + ' offer in state ' + peerConnection.signalingState));\n    } // We need to save this local offer in case of a rollback. We also need to\n    // check to see if the signalingState between the ChromeRTCPeerConnection\n    // and the underlying RTCPeerConnection implementation are about to diverge.\n    // If so, we need to ensure subsequent calls to addIceCandidate will block.\n\n\n    if (!pendingLocalOffer && peerConnection._signalingStateLatch.state === 'low') {\n      peerConnection._signalingStateLatch.raise();\n    }\n\n    var previousSignalingState = peerConnection.signalingState;\n    setPendingLocalOffer(unwrap(description));\n    promise = Promise.resolve(); // Only dispatch a signalingstatechange event if we transitioned.\n\n    if (peerConnection.signalingState !== previousSignalingState) {\n      promise.then(function dispatchSignalingStateChangeEvent() {\n        peerConnection.dispatchEvent(new Event('signalingstatechange'));\n      });\n    }\n  } else if (description.type === 'rollback') {\n    if (peerConnection.signalingState !== intermediateState) {\n      // NOTE(mroberts): Error message copied from Firefox.\n      promise = Promise.reject(new Error('Cannot rollback ' + (local ? 'local' : 'remote') + ' description in ' + peerConnection.signalingState));\n    } else {\n      // Reset the pending offer.\n      clearPendingLocalOffer(); // NOTE(mmalavalli): We store the rolled back tracks to SSRCs Map here in case\n      // setLocalDescription() is called immediately after a rollback (without calling\n      // createOffer() or createAnswer()), in which case this roll back is not due to a\n      // glare scenario and this Map should be restored.\n\n      peerConnection._rolledBackTracksToSSRCs = new Map(peerConnection._tracksToSSRCs);\n      peerConnection._tracksToSSRCs = new Map(peerConnection._appliedTracksToSSRCs);\n      promise = Promise.resolve();\n      promise.then(function dispatchSignalingStateChangeEvent() {\n        peerConnection.dispatchEvent(new Event('signalingstatechange'));\n      });\n    }\n  }\n\n  return promise || peerConnection._peerConnection[setLocalDescription](unwrap(description));\n}\n\nfunction setRemoteAnswer(peerConnection, answer) {\n  // Apply the pending local offer.\n  var pendingLocalOffer = peerConnection._pendingLocalOffer;\n  return peerConnection._peerConnection.setLocalDescription(pendingLocalOffer).then(function setLocalOfferSucceeded() {\n    peerConnection._pendingLocalOffer = null;\n    return peerConnection.setRemoteDescription(answer);\n  }).then(function setRemoteAnswerSucceeded() {\n    // NOTE(mroberts): The signalingStates between the ChromeRTCPeerConnection\n    // and the underlying RTCPeerConnection implementation have converged. We\n    // can unblock any pending calls to addIceCandidate now.\n    peerConnection._signalingStateLatch.lower();\n  });\n}\n\nfunction unwrap(description) {\n  if (description instanceof ChromeRTCSessionDescription) {\n    if (description._description) {\n      return description._description;\n    }\n  }\n\n  return new RTCSessionDescription(description);\n}\n/**\n * Check whether or not we need to apply our maxPacketLifeTime shim. We are\n * pretty conservative: we'll only apply it if the legacy maxRetransmitTime\n * property is available _and_ the standard maxPacketLifeTime property is _not_\n * available (the thinking being that Chrome will land the standards-compliant\n * property).\n * @returns {boolean}\n */\n\n\nfunction needsMaxPacketLifeTimeShim() {\n  return 'maxRetransmitTime' in RTCDataChannel.prototype && !('maxPacketLifeTime' in RTCDataChannel.prototype);\n}\n/**\n * Shim an RTCDataChannelInit dictionary (if necessary). This function returns\n * a copy of the original RTCDataChannelInit.\n * @param {RTCDataChannelInit} dataChannelDict\n * @returns {RTCDataChannelInit}\n */\n\n\nfunction shimDataChannelInit(dataChannelDict) {\n  dataChannelDict = Object.assign({}, dataChannelDict);\n\n  if (needsMaxPacketLifeTimeShim() && 'maxPacketLifeTime' in dataChannelDict) {\n    dataChannelDict.maxRetransmitTime = dataChannelDict.maxPacketLifeTime;\n  }\n\n  return dataChannelDict;\n}\n/**\n * Shim an RTCDataChannel (if necessary). This function mutates the\n * RTCDataChannel.\n * @param {RTCDataChannel} dataChannel\n * @returns {RTCDataChannel}\n */\n\n\nfunction shimDataChannel(dataChannel) {\n  Object.defineProperty(dataChannel, 'maxRetransmits', {\n    value: dataChannel.maxRetransmits === 65535 ? null : dataChannel.maxRetransmits\n  });\n\n  if (needsMaxPacketLifeTimeShim()) {\n    // NOTE(mroberts): We can rename `maxRetransmitTime` to `maxPacketLifeTime`.\n    //\n    //   https://bugs.chromium.org/p/chromium/issues/detail?id=696681\n    //\n    Object.defineProperty(dataChannel, 'maxPacketLifeTime', {\n      value: dataChannel.maxRetransmitTime === 65535 ? null : dataChannel.maxRetransmitTime\n    });\n  }\n\n  return dataChannel;\n}\n/**\n * Update the mappings from MediaStreamTrack IDs to SSRCs as indicated by both\n * the Map from MediaStreamTrack IDs to SSRCs and the SDP itself. This method\n * ensures that SSRCs never change once announced.\n * @param {'planb'|'unified'} sdpFormat\n * @param {Map<string, Set<string>>} tracksToSSRCs\n * @param {string} sdp - an SDP whose format is determined by `sdpSemantics`\n * @returns {string} updatedSdp - updated SDP\n */\n\n\nfunction updateTrackIdsToSSRCs(sdpFormat, tracksToSSRCs, sdp) {\n  return sdpFormat === 'unified' ? sdpUtils.updateUnifiedPlanTrackIdsToSSRCs(tracksToSSRCs, sdp) : sdpUtils.updatePlanBTrackIdsToSSRCs(tracksToSSRCs, sdp);\n}\n\nmodule.exports = ChromeRTCPeerConnection;","map":{"version":3,"sources":["/home/ascencion/sebrae_megahack/node_modules/@twilio/webrtc/lib/rtcpeerconnection/chrome.js"],"names":["ChromeRTCSessionDescription","require","EventTarget","inherits","Latch","MediaStream","RTCRtpSenderShim","sdpUtils","util","ChromeRTCPeerConnection","configuration","constraints","call","newConfiguration","Object","assign","iceTransportPolicy","iceTransports","interceptEvent","sdpFormat","getSdpFormat","sdpSemantics","peerConnection","RTCPeerConnection","defineProperties","_appliedTracksToSSRCs","value","Map","writable","_localStream","_peerConnection","_pendingLocalOffer","_pendingRemoteOffer","_rolledBackTracksToSSRCs","_sdpFormat","_senders","_signalingStateLatch","_tracksToSSRCs","localDescription","enumerable","get","remoteDescription","signalingState","self","addEventListener","ondatachannel","event","shimDataChannel","channel","dispatchEvent","onsignalingstatechange","apply","arguments","ontrack","prototype","addTrack","addStream","proxyProperties","args","slice","track","Error","id","kind","sender","removeStream","set","removeTrack","getSenders","Array","from","values","e","addIceCandidate","candidate","promise","when","then","signalingStatesResolved","length","legacyPromise","close","createAnswer","setRemoteDescription","setRemoteDescriptionSucceeded","lower","createAnswerSucceeded","answer","clear","type","sdp","updateTrackIdsToSSRCs","setRemoteDescriptionOrCreateAnswerFailed","error","createOffer","options","offer","createDataChannel","label","dataChannelDict","shimDataChannelInit","dataChannel","setLocalDescription","description","size","setDescription","delegateMethods","local","setPendingLocalOffer","clearPendingLocalOffer","pendingLocalOffer","pendingRemoteOffer","intermediateState","setRemoteAnswer","Promise","reject","state","raise","previousSignalingState","unwrap","resolve","dispatchSignalingStateChangeEvent","Event","setLocalOfferSucceeded","setRemoteAnswerSucceeded","_description","RTCSessionDescription","needsMaxPacketLifeTimeShim","RTCDataChannel","maxRetransmitTime","maxPacketLifeTime","defineProperty","maxRetransmits","tracksToSSRCs","updateUnifiedPlanTrackIdsToSSRCs","updatePlanBTrackIdsToSSRCs","module","exports"],"mappings":"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","sourcesContent":["/* globals RTCDataChannel, RTCPeerConnection, RTCSessionDescription */\n'use strict';\n\nvar ChromeRTCSessionDescription = require('../rtcsessiondescription/chrome');\nvar EventTarget = require('../util/eventtarget');\nvar inherits = require('util').inherits;\nvar Latch = require('../util/latch');\nvar MediaStream = require('../mediastream');\nvar RTCRtpSenderShim = require('../rtcrtpsender');\nvar sdpUtils = require('../util/sdp');\nvar util = require('../util');\n\n// NOTE(mroberts): This class wraps Chrome's RTCPeerConnection implementation.\n// It provides some functionality not currently present in Chrome, namely the\n// abilities to\n//\n//   1. Rollback, per the workaround suggested here:\n//      https://bugs.chromium.org/p/webrtc/issues/detail?id=5738#c3\n//\n//   2. Listen for track events, per the adapter.js workaround.\n//\n//   3. Set iceTransportPolicy.\n//\nfunction ChromeRTCPeerConnection(configuration, constraints) {\n  if (!(this instanceof ChromeRTCPeerConnection)) {\n    return new ChromeRTCPeerConnection(configuration, constraints);\n  }\n\n  EventTarget.call(this);\n\n  configuration = configuration || {};\n  var newConfiguration = Object.assign(configuration.iceTransportPolicy\n    ? { iceTransports: configuration.iceTransportPolicy }\n    : {}, configuration);\n\n  util.interceptEvent(this, 'datachannel');\n  util.interceptEvent(this, 'signalingstatechange');\n\n  var sdpFormat = sdpUtils.getSdpFormat(newConfiguration.sdpSemantics);\n  var peerConnection = new RTCPeerConnection(newConfiguration, constraints);\n\n  Object.defineProperties(this, {\n    _appliedTracksToSSRCs: {\n      value: new Map(),\n      writable: true\n    },\n    _localStream: {\n      value: new MediaStream()\n    },\n    _peerConnection: {\n      value: peerConnection\n    },\n    _pendingLocalOffer: {\n      value: null,\n      writable: true\n    },\n    _pendingRemoteOffer: {\n      value: null,\n      writable: true\n    },\n    _rolledBackTracksToSSRCs: {\n      value: new Map(),\n      writable: true\n    },\n    _sdpFormat: {\n      value: sdpFormat\n    },\n    _senders: {\n      value: new Map()\n    },\n    _signalingStateLatch: {\n      value: new Latch()\n    },\n    _tracksToSSRCs: {\n      value: new Map(),\n      writable: true\n    },\n    localDescription: {\n      enumerable: true,\n      get: function() {\n        return this._pendingLocalOffer ? this._pendingLocalOffer : peerConnection.localDescription;\n      }\n    },\n    remoteDescription: {\n      enumerable: true,\n      get: function() {\n        return this._pendingRemoteOffer ? this._pendingRemoteOffer : peerConnection.remoteDescription;\n      }\n    },\n    signalingState: {\n      enumerable: true,\n      get: function() {\n        if (this._pendingLocalOffer) {\n          return 'have-local-offer';\n        } else if (this._pendingRemoteOffer) {\n          return 'have-remote-offer';\n        }\n        return peerConnection.signalingState;\n      }\n    }\n  });\n\n  var self = this;\n\n  peerConnection.addEventListener('datachannel', function ondatachannel(event) {\n    shimDataChannel(event.channel);\n    self.dispatchEvent(event);\n  });\n\n  peerConnection.addEventListener('signalingstatechange', function onsignalingstatechange() {\n    if (peerConnection.signalingState === 'stable') {\n      self._appliedTracksToSSRCs = new Map(self._tracksToSSRCs);\n    }\n    if (!self._pendingLocalOffer && !self._pendingRemoteOffer) {\n      self.dispatchEvent.apply(self, arguments);\n    }\n  });\n\n  peerConnection.ontrack = function ontrack() {\n    // NOTE(mroberts): adapter.js's \"track\" event shim only kicks off if we set\n    // the ontrack property of the RTCPeerConnection.\n  };\n\n  if (typeof RTCPeerConnection.prototype.addTrack !== 'function') {\n    peerConnection.addStream(this._localStream);\n  }\n  util.proxyProperties(RTCPeerConnection.prototype, this, peerConnection);\n}\n\ninherits(ChromeRTCPeerConnection, EventTarget);\n\nif (typeof RTCPeerConnection.prototype.addTrack !== 'function') {\n  // NOTE(mmalavalli): This shim supports our limited case of adding\n  // all MediaStreamTracks to one MediaStream. It has been implemented this\n  // keeping in mind that this is to be maintained only until \"addTrack\" is\n  // supported natively in Chrome.\n  ChromeRTCPeerConnection.prototype.addTrack = function addTrack() {\n    var args = [].slice.call(arguments);\n    var track = args[0];\n    if (this._peerConnection.signalingState === 'closed') {\n      throw new Error('Cannot add MediaStreamTrack [' + track.id + ', '\n        + track.kind + ']: RTCPeerConnection is closed');\n    }\n\n    var sender = this._senders.get(track);\n    if (sender && sender.track) {\n      throw new Error('Cannot add MediaStreamTrack [' + track.id + ', '\n        + track.kind + ']: RTCPeerConnection already has it');\n    }\n    this._peerConnection.removeStream(this._localStream);\n    this._localStream.addTrack(track);\n    this._peerConnection.addStream(this._localStream);\n\n    sender = new RTCRtpSenderShim(track);\n    this._senders.set(track, sender);\n    return sender;\n  };\n\n  // NOTE(mmalavalli): This shim supports our limited case of removing\n  // MediaStreamTracks from one MediaStream. It has been implemented this\n  // keeping in mind that this is to be maintained only until \"removeTrack\" is\n  // supported natively in Chrome.\n  ChromeRTCPeerConnection.prototype.removeTrack = function removeTrack(sender) {\n    if (this._peerConnection.signalingState === 'closed') {\n      throw new Error('Cannot remove MediaStreamTrack: RTCPeerConnection is closed');\n    }\n\n    var track = sender.track;\n    if (!track) {\n      return;\n    }\n    sender = this._senders.get(track);\n    if (sender && sender.track) {\n      sender.track = null;\n      this._peerConnection.removeStream(this._localStream);\n      this._localStream.removeTrack(track);\n      this._peerConnection.addStream(this._localStream);\n    }\n  };\n\n  ChromeRTCPeerConnection.prototype.getSenders = function getSenders() {\n    return Array.from(this._senders.values());\n  };\n} else {\n  ChromeRTCPeerConnection.prototype.removeTrack = function removeTrack(sender) {\n    if (this._peerConnection.signalingState === 'closed') {\n      throw new Error('Cannot remove MediaStreamTrack: RTCPeerConnection is closed');\n    }\n    try {\n      this._peerConnection.removeTrack(sender);\n    } catch (e) {\n      // NOTE(mhuynh): Do nothing. In Chrome, will throw if a 'sender was not\n      // created by this peer connection'. This behavior does not seem to be\n      // spec compliant, so a temporary shim is introduced. A bug has been filed,\n      // and is tracked here:\n      // https://bugs.chromium.org/p/chromium/issues/detail?id=860853\n    }\n  };\n}\n\nChromeRTCPeerConnection.prototype.addIceCandidate = function addIceCandidate(candidate) {\n  var args = [].slice.call(arguments);\n  var promise;\n  var self = this;\n\n  if (this.signalingState === 'have-remote-offer') {\n    // NOTE(mroberts): Because the ChromeRTCPeerConnection simulates the\n    // \"have-remote-offer\" signalingStates, we only want to invoke the true\n    // addIceCandidates method when the remote description has been applied.\n    promise = this._signalingStateLatch.when('low').then(function signalingStatesResolved() {\n      return self._peerConnection.addIceCandidate(candidate);\n    });\n  } else {\n    promise = this._peerConnection.addIceCandidate(candidate);\n  }\n\n  return args.length > 1\n    ? util.legacyPromise(promise, args[1], args[2])\n    : promise;\n};\n\n// NOTE(mroberts): The WebRTC spec does not specify that close should throw an\n// Error; however, in Chrome it does. We workaround this by checking the\n// signalingState manually.\nChromeRTCPeerConnection.prototype.close = function close() {\n  if (this.signalingState !== 'closed') {\n    this._pendingLocalOffer = null;\n    this._pendingRemoteOffer = null;\n    this._peerConnection.close();\n  }\n};\n\n// NOTE(mroberts): Because we workaround Chrome's lack of rollback support by\n// \"faking\" setRemoteDescription, we cannot create an answer until we actually\n// apply the remote description. This means, once you call createAnswer, you\n// can no longer rollback. This is acceptable for our use case because we will\n// apply the newly-created answer almost immediately; however, this may be\n// unacceptable for other use cases.\nChromeRTCPeerConnection.prototype.createAnswer = function createAnswer() {\n  var args = [].slice.call(arguments);\n  var promise;\n  var self = this;\n\n  if (this._pendingRemoteOffer) {\n    promise = this._peerConnection.setRemoteDescription(this._pendingRemoteOffer).then(function setRemoteDescriptionSucceeded() {\n      // NOTE(mroberts): The signalingStates between the ChromeRTCPeerConnection\n      // and the underlying RTCPeerConnection implementation have converged. We\n      // can unblock any pending calls to addIceCandidate now.\n      self._signalingStateLatch.lower();\n      return self._peerConnection.createAnswer();\n    }).then(function createAnswerSucceeded(answer) {\n      self._pendingRemoteOffer = null;\n\n      // NOTE(mmalavalli): If createAnswer() is called immediately after rolling back, then we no\n      // longer need to retain the rolled back tracks to SSRCs Map.\n      self._rolledBackTracksToSSRCs.clear();\n\n      return new ChromeRTCSessionDescription({\n        type: 'answer',\n        sdp: updateTrackIdsToSSRCs(self._sdpFormat, self._tracksToSSRCs, answer.sdp)\n      });\n    }, function setRemoteDescriptionOrCreateAnswerFailed(error) {\n      self._pendingRemoteOffer = null;\n      throw error;\n    });\n  } else {\n    promise = this._peerConnection.createAnswer().then(function(answer) {\n      // NOTE(mmalavalli): If createAnswer() is called immediately after rolling back, then we no\n      // longer need to retain the rolled back tracks to SSRCs Map.\n      self._rolledBackTracksToSSRCs.clear();\n\n      return new ChromeRTCSessionDescription({\n        type: 'answer',\n        sdp: updateTrackIdsToSSRCs(self._sdpFormat, self._tracksToSSRCs, answer.sdp)\n      });\n    });\n  }\n\n  return args.length > 1\n    ? util.legacyPromise(promise, args[0], args[1])\n    : promise;\n};\n\nChromeRTCPeerConnection.prototype.createOffer = function createOffer() {\n  var args = [].slice.call(arguments);\n  var options = (args.length > 1 ? args[2] : args[0]) || {};\n  var self = this;\n\n  var promise = this._peerConnection.createOffer(options).then(function(offer) {\n    // NOTE(mmalavalli): If createOffer() is called immediately after rolling back, then we no\n    // longer need to retain the rolled back tracks to SSRCs Map.\n    self._rolledBackTracksToSSRCs.clear();\n\n    return new ChromeRTCSessionDescription({\n      type: offer.type,\n      sdp: updateTrackIdsToSSRCs(self._sdpFormat, self._tracksToSSRCs, offer.sdp)\n    });\n  });\n\n  return args.length > 1\n    ? util.legacyPromise(promise, args[0], args[1])\n    : promise;\n};\n\nChromeRTCPeerConnection.prototype.createDataChannel = function createDataChannel(label, dataChannelDict) {\n  dataChannelDict = shimDataChannelInit(dataChannelDict);\n  var dataChannel = this._peerConnection.createDataChannel(label, dataChannelDict);\n  shimDataChannel(dataChannel);\n  return dataChannel;\n};\n\nChromeRTCPeerConnection.prototype.setLocalDescription = function setLocalDescription() {\n  var args = [].slice.call(arguments);\n  var description = args[0];\n\n  // NOTE(mmalavalli): If setLocalDescription() is called immediately after rolling back,\n  // then we need to restore the rolled back tracks to SSRCs Map.\n  if (this._rolledBackTracksToSSRCs.size > 0) {\n    this._tracksToSSRCs = new Map(this._rolledBackTracksToSSRCs);\n    this._rolledBackTracksToSSRCs.clear();\n  }\n\n  var promise = setDescription(this, true, description);\n  return args.length > 1\n    ? util.legacyPromise(promise, args[1], args[2])\n    : promise;\n};\n\nChromeRTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription() {\n  var args = [].slice.call(arguments);\n  var description = args[0];\n\n  // NOTE(mmalavalli): If setRemoteDescription() is called immediately after rolling back,\n  // then we no longer need to retain the rolled back tracks to SSRCs Map.\n  this._rolledBackTracksToSSRCs.clear();\n\n  var promise = setDescription(this, false, description);\n  return args.length > 1\n    ? util.legacyPromise(promise, args[1], args[2])\n    : promise;\n};\n\nutil.delegateMethods(\n  RTCPeerConnection.prototype,\n  ChromeRTCPeerConnection.prototype,\n  '_peerConnection');\n\n// NOTE(mroberts): We workaround Chrome's lack of rollback support, per the\n// workaround suggested here: https://bugs.chromium.org/p/webrtc/issues/detail?id=5738#c3\n// Namely, we \"fake\" setting the local or remote description and instead buffer\n// it. If we receive or create an answer, then we will actually apply the\n// description. Until we receive or create an answer, we will be able to\n// \"rollback\" by simply discarding the buffer description.\nfunction setDescription(peerConnection, local, description) {\n  function setPendingLocalOffer(offer) {\n    if (local) {\n      peerConnection._pendingLocalOffer = offer;\n    } else {\n      peerConnection._pendingRemoteOffer = offer;\n    }\n  }\n\n  function clearPendingLocalOffer() {\n    if (local) {\n      peerConnection._pendingLocalOffer = null;\n    } else {\n      peerConnection._pendingRemoteOffer = null;\n    }\n  }\n\n  var pendingLocalOffer = local ? peerConnection._pendingLocalOffer : peerConnection._pendingRemoteOffer;\n  var pendingRemoteOffer = local ? peerConnection._pendingRemoteOffer : peerConnection._pendingLocalOffer;\n  var intermediateState = local ? 'have-local-offer' : 'have-remote-offer';\n  var setLocalDescription = local ? 'setLocalDescription' : 'setRemoteDescription';\n  var promise;\n\n  if (!local && pendingRemoteOffer && description.type === 'answer') {\n    promise = setRemoteAnswer(peerConnection, description);\n  } else if (description.type === 'offer') {\n    if (peerConnection.signalingState !== intermediateState && peerConnection.signalingState !== 'stable') {\n      // NOTE(mroberts): Error message copied from Firefox.\n      return Promise.reject(new Error('Cannot set ' + (local ? 'local' : 'remote') +\n        ' offer in state ' + peerConnection.signalingState));\n    }\n\n    // We need to save this local offer in case of a rollback. We also need to\n    // check to see if the signalingState between the ChromeRTCPeerConnection\n    // and the underlying RTCPeerConnection implementation are about to diverge.\n    // If so, we need to ensure subsequent calls to addIceCandidate will block.\n    if (!pendingLocalOffer && peerConnection._signalingStateLatch.state === 'low') {\n      peerConnection._signalingStateLatch.raise();\n    }\n    var previousSignalingState = peerConnection.signalingState;\n    setPendingLocalOffer(unwrap(description));\n    promise = Promise.resolve();\n\n    // Only dispatch a signalingstatechange event if we transitioned.\n    if (peerConnection.signalingState !== previousSignalingState) {\n      promise.then(function dispatchSignalingStateChangeEvent() {\n        peerConnection.dispatchEvent(new Event('signalingstatechange'));\n      });\n    }\n\n  } else if (description.type === 'rollback') {\n    if (peerConnection.signalingState !== intermediateState) {\n      // NOTE(mroberts): Error message copied from Firefox.\n      promise = Promise.reject(new Error('Cannot rollback ' +\n        (local ? 'local' : 'remote') + ' description in ' + peerConnection.signalingState));\n    } else {\n      // Reset the pending offer.\n      clearPendingLocalOffer();\n\n      // NOTE(mmalavalli): We store the rolled back tracks to SSRCs Map here in case\n      // setLocalDescription() is called immediately after a rollback (without calling\n      // createOffer() or createAnswer()), in which case this roll back is not due to a\n      // glare scenario and this Map should be restored.\n      peerConnection._rolledBackTracksToSSRCs = new Map(peerConnection._tracksToSSRCs);\n      peerConnection._tracksToSSRCs = new Map(peerConnection._appliedTracksToSSRCs);\n\n      promise = Promise.resolve();\n      promise.then(function dispatchSignalingStateChangeEvent() {\n        peerConnection.dispatchEvent(new Event('signalingstatechange'));\n      });\n    }\n  }\n\n  return promise || peerConnection._peerConnection[setLocalDescription](unwrap(description));\n}\n\nfunction setRemoteAnswer(peerConnection, answer) {\n  // Apply the pending local offer.\n  var pendingLocalOffer = peerConnection._pendingLocalOffer;\n  return peerConnection._peerConnection.setLocalDescription(pendingLocalOffer).then(function setLocalOfferSucceeded() {\n    peerConnection._pendingLocalOffer = null;\n    return peerConnection.setRemoteDescription(answer);\n  }).then(function setRemoteAnswerSucceeded() {\n    // NOTE(mroberts): The signalingStates between the ChromeRTCPeerConnection\n    // and the underlying RTCPeerConnection implementation have converged. We\n    // can unblock any pending calls to addIceCandidate now.\n    peerConnection._signalingStateLatch.lower();\n  });\n}\n\nfunction unwrap(description) {\n  if (description instanceof ChromeRTCSessionDescription) {\n    if (description._description) {\n      return description._description;\n    }\n  }\n  return new RTCSessionDescription(description);\n}\n\n/**\n * Check whether or not we need to apply our maxPacketLifeTime shim. We are\n * pretty conservative: we'll only apply it if the legacy maxRetransmitTime\n * property is available _and_ the standard maxPacketLifeTime property is _not_\n * available (the thinking being that Chrome will land the standards-compliant\n * property).\n * @returns {boolean}\n */\nfunction needsMaxPacketLifeTimeShim() {\n  return 'maxRetransmitTime' in RTCDataChannel.prototype\n    && !('maxPacketLifeTime' in RTCDataChannel.prototype);\n}\n\n/**\n * Shim an RTCDataChannelInit dictionary (if necessary). This function returns\n * a copy of the original RTCDataChannelInit.\n * @param {RTCDataChannelInit} dataChannelDict\n * @returns {RTCDataChannelInit}\n */\nfunction shimDataChannelInit(dataChannelDict) {\n  dataChannelDict = Object.assign({}, dataChannelDict);\n  if (needsMaxPacketLifeTimeShim() && 'maxPacketLifeTime' in dataChannelDict) {\n    dataChannelDict.maxRetransmitTime = dataChannelDict.maxPacketLifeTime;\n  }\n  return dataChannelDict;\n}\n\n/**\n * Shim an RTCDataChannel (if necessary). This function mutates the\n * RTCDataChannel.\n * @param {RTCDataChannel} dataChannel\n * @returns {RTCDataChannel}\n */\nfunction shimDataChannel(dataChannel) {\n  Object.defineProperty(dataChannel, 'maxRetransmits', {\n    value: dataChannel.maxRetransmits === 65535\n      ? null\n      : dataChannel.maxRetransmits\n  });\n  if (needsMaxPacketLifeTimeShim()) {\n    // NOTE(mroberts): We can rename `maxRetransmitTime` to `maxPacketLifeTime`.\n    //\n    //   https://bugs.chromium.org/p/chromium/issues/detail?id=696681\n    //\n    Object.defineProperty(dataChannel, 'maxPacketLifeTime', {\n      value: dataChannel.maxRetransmitTime === 65535\n        ? null\n        : dataChannel.maxRetransmitTime\n    });\n  }\n  return dataChannel;\n}\n\n/**\n * Update the mappings from MediaStreamTrack IDs to SSRCs as indicated by both\n * the Map from MediaStreamTrack IDs to SSRCs and the SDP itself. This method\n * ensures that SSRCs never change once announced.\n * @param {'planb'|'unified'} sdpFormat\n * @param {Map<string, Set<string>>} tracksToSSRCs\n * @param {string} sdp - an SDP whose format is determined by `sdpSemantics`\n * @returns {string} updatedSdp - updated SDP\n */\nfunction updateTrackIdsToSSRCs(sdpFormat, tracksToSSRCs, sdp) {\n  return sdpFormat === 'unified'\n    ? sdpUtils.updateUnifiedPlanTrackIdsToSSRCs(tracksToSSRCs, sdp)\n    : sdpUtils.updatePlanBTrackIdsToSSRCs(tracksToSSRCs, sdp);\n}\n\nmodule.exports = ChromeRTCPeerConnection;\n"]},"metadata":{},"sourceType":"script"}