{"ast":null,"code":"/* globals RTCPeerConnection, RTCSessionDescription */\n'use strict';\n\nvar EventTarget = require('../util/eventtarget');\n\nvar inherits = require('util').inherits;\n\nvar Latch = require('../util/latch');\n\nvar sdpUtils = require('../util/sdp');\n\nvar util = require('../util');\n\nvar isUnifiedPlan = sdpUtils.getSdpFormat() === 'unified';\nvar updateTrackIdsToSSRCs = isUnifiedPlan ? sdpUtils.updateUnifiedPlanTrackIdsToSSRCs : sdpUtils.updatePlanBTrackIdsToSSRCs;\n\nfunction SafariRTCPeerConnection(configuration) {\n  if (!(this instanceof SafariRTCPeerConnection)) {\n    return new SafariRTCPeerConnection(configuration);\n  }\n\n  EventTarget.call(this);\n  util.interceptEvent(this, 'datachannel');\n  util.interceptEvent(this, 'iceconnectionstatechange');\n  util.interceptEvent(this, 'signalingstatechange');\n  util.interceptEvent(this, 'track');\n  var peerConnection = new RTCPeerConnection(configuration);\n  Object.defineProperties(this, {\n    _appliedTracksToSSRCs: {\n      value: new Map(),\n      writable: true\n    },\n    _audioTransceiver: {\n      value: null,\n      writable: true\n    },\n    _isClosed: {\n      value: false,\n      writable: true\n    },\n    _peerConnection: {\n      value: peerConnection\n    },\n    _pendingLocalOffer: {\n      value: null,\n      writable: true\n    },\n    _pendingRemoteOffer: {\n      value: null,\n      writable: true\n    },\n    _rolledBackTracksToSSRCs: {\n      value: new Map(),\n      writable: true\n    },\n    _signalingStateLatch: {\n      value: new Latch()\n    },\n    _tracksToSSRCs: {\n      value: new Map(),\n      writable: true\n    },\n    _videoTransceiver: {\n      value: null,\n      writable: true\n    },\n    localDescription: {\n      enumerable: true,\n      get: function () {\n        return this._pendingLocalOffer || this._peerConnection.localDescription;\n      }\n    },\n    iceConnectionState: {\n      enumerable: true,\n      get: function () {\n        return this._isClosed ? 'closed' : this._peerConnection.iceConnectionState;\n      }\n    },\n    iceGatheringState: {\n      enumerable: true,\n      get: function () {\n        return this._isClosed ? 'complete' : this._peerConnection.iceGatheringState;\n      }\n    },\n    remoteDescription: {\n      enumerable: true,\n      get: function () {\n        return this._pendingRemoteOffer || this._peerConnection.remoteDescription;\n      }\n    },\n    signalingState: {\n      enumerable: true,\n      get: function () {\n        if (this._isClosed) {\n          return 'closed';\n        } else if (this._pendingLocalOffer) {\n          return 'have-local-offer';\n        } else if (this._pendingRemoteOffer) {\n          return 'have-remote-offer';\n        }\n\n        return this._peerConnection.signalingState;\n      }\n    }\n  });\n  var self = this;\n  peerConnection.addEventListener('datachannel', function ondatachannel(event) {\n    shimDataChannel(event.channel);\n    self.dispatchEvent(event);\n  });\n  peerConnection.addEventListener('iceconnectionstatechange', function oniceconnectionstatechange() {\n    if (self._isClosed) {\n      return;\n    }\n\n    self.dispatchEvent.apply(self, arguments);\n  });\n  peerConnection.addEventListener('signalingstatechange', function onsignalingstatechange() {\n    if (self._isClosed) {\n      return;\n    }\n\n    if (peerConnection.signalingState === 'stable') {\n      self._appliedTracksToSSRCs = new Map(self._tracksToSSRCs);\n    }\n\n    if (!self._pendingLocalOffer && !self._pendingRemoteOffer) {\n      self.dispatchEvent.apply(self, arguments);\n    }\n  }); // NOTE(syerrapragada): This ensures that SafariRTCPeerConnection's \"remoteDescription\", when accessed\n  // in an RTCTrackEvent listener, will point to the underlying RTCPeerConnection's\n  // \"remoteDescription\". Before this fix, this was still pointing to \"_pendingRemoteOffer\"\n  // even though a new remote RTCSessionDescription had already been applied.\n\n  peerConnection.addEventListener('track', function ontrack(event) {\n    self._pendingRemoteOffer = null;\n    self.dispatchEvent(event);\n  });\n  util.proxyProperties(RTCPeerConnection.prototype, this, peerConnection);\n}\n\ninherits(SafariRTCPeerConnection, EventTarget);\n\nSafariRTCPeerConnection.prototype.addIceCandidate = function addIceCandidate(candidate) {\n  var self = this;\n\n  if (this.signalingState === 'have-remote-offer') {\n    return this._signalingStateLatch.when('low').then(function signalingStatesResolved() {\n      return self._peerConnection.addIceCandidate(candidate);\n    });\n  }\n\n  return this._peerConnection.addIceCandidate(candidate);\n};\n\nSafariRTCPeerConnection.prototype.createOffer = function createOffer(options) {\n  options = Object.assign({}, options);\n  var self = this; // NOTE(mroberts): In general, this is not the way to do this; however, it's\n  // good enough for our application.\n\n  if (options.offerToReceiveAudio && !this._audioTransceiver && !(isUnifiedPlan && hasReceiversForTracksOfKind(this, 'audio'))) {\n    delete options.offerToReceiveAudio;\n\n    try {\n      this._audioTransceiver = isUnifiedPlan ? this.addTransceiver('audio', {\n        direction: 'recvonly'\n      }) : this.addTransceiver('audio');\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  }\n\n  if (options.offerToReceiveVideo && !this._videoTransceiver && !(isUnifiedPlan && hasReceiversForTracksOfKind(this, 'video'))) {\n    delete options.offerToReceiveVideo;\n\n    try {\n      this._videoTransceiver = isUnifiedPlan ? this.addTransceiver('video', {\n        direction: 'recvonly'\n      }) : this.addTransceiver('video');\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  }\n\n  return this._peerConnection.createOffer(options).then(function (offer) {\n    // NOTE(mmalavalli): If createOffer() is called immediately after rolling back,\n    // then we no longer need to retain the rolled back tracks to SSRCs Map.\n    self._rolledBackTracksToSSRCs.clear();\n\n    return new RTCSessionDescription({\n      type: offer.type,\n      sdp: updateTrackIdsToSSRCs(self._tracksToSSRCs, offer.sdp)\n    });\n  });\n};\n\nSafariRTCPeerConnection.prototype.createAnswer = function createAnswer(options) {\n  var self = this;\n\n  if (this._pendingRemoteOffer) {\n    return this._peerConnection.setRemoteDescription(this._pendingRemoteOffer).then(function setRemoteDescriptionSucceeded() {\n      self._signalingStateLatch.lower();\n\n      return self._peerConnection.createAnswer();\n    }).then(function createAnswerSucceeded(answer) {\n      self._pendingRemoteOffer = null; // NOTE(mmalavalli): If createAnswer() is called immediately after rolling back, then we no\n      // longer need to retain the rolled back tracks to SSRCs Map.\n\n      self._rolledBackTracksToSSRCs.clear();\n\n      return isUnifiedPlan ? new RTCSessionDescription({\n        type: answer.type,\n        sdp: updateTrackIdsToSSRCs(self._tracksToSSRCs, answer.sdp)\n      }) : answer;\n    }, function setRemoteDescriptionOrCreateAnswerFailed(error) {\n      self._pendingRemoteOffer = null;\n      throw error;\n    });\n  }\n\n  return this._peerConnection.createAnswer(options).then(function createAnswerSucceeded(answer) {\n    // NOTE(mmalavalli): If createAnswer() is called immediately after rolling back, then we no\n    // longer need to retain the rolled back tracks to SSRCs Map.\n    self._rolledBackTracksToSSRCs.clear();\n\n    return isUnifiedPlan ? new RTCSessionDescription({\n      type: answer.type,\n      sdp: updateTrackIdsToSSRCs(self._tracksToSSRCs, answer.sdp)\n    }) : answer;\n  });\n};\n\nSafariRTCPeerConnection.prototype.createDataChannel = function createDataChannel(label, dataChannelDict) {\n  var dataChannel = this._peerConnection.createDataChannel(label, dataChannelDict);\n\n  shimDataChannel(dataChannel);\n  return dataChannel;\n};\n\nSafariRTCPeerConnection.prototype.removeTrack = function removeTrack(sender) {\n  sender.replaceTrack(null);\n\n  this._peerConnection.removeTrack(sender);\n};\n\nSafariRTCPeerConnection.prototype.setLocalDescription = function setLocalDescription(description) {\n  // NOTE(mmalavalli): If setLocalDescription() is called immediately after rolling back,\n  // then we need to restore the rolled back tracks to SSRCs Map.\n  if (this._rolledBackTracksToSSRCs.size > 0) {\n    this._tracksToSSRCs = new Map(this._rolledBackTracksToSSRCs);\n\n    this._rolledBackTracksToSSRCs.clear();\n  }\n\n  return setDescription(this, true, description);\n};\n\nSafariRTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription(description) {\n  // NOTE(mmalavalli): If setRemoteDescription() is called immediately after rolling back,\n  // then we no longer need to retain the rolled back tracks to SSRCs Map.\n  this._rolledBackTracksToSSRCs.clear();\n\n  return setDescription(this, false, description);\n};\n\nSafariRTCPeerConnection.prototype.close = function close() {\n  if (this._isClosed) {\n    return;\n  }\n\n  this._isClosed = true;\n\n  this._peerConnection.close();\n\n  var self = this;\n  setTimeout(function () {\n    self.dispatchEvent(new Event('iceconnectionstatechange'));\n    self.dispatchEvent(new Event('signalingstatechange'));\n  });\n};\n\nutil.delegateMethods(RTCPeerConnection.prototype, SafariRTCPeerConnection.prototype, '_peerConnection');\n\nfunction setDescription(peerConnection, local, description) {\n  function setPendingLocalOffer(offer) {\n    if (local) {\n      peerConnection._pendingLocalOffer = offer;\n    } else {\n      peerConnection._pendingRemoteOffer = offer;\n    }\n  }\n\n  function clearPendingLocalOffer() {\n    if (local) {\n      peerConnection._pendingLocalOffer = null;\n    } else {\n      peerConnection._pendingRemoteOffer = null;\n    }\n  }\n\n  var pendingLocalOffer = local ? peerConnection._pendingLocalOffer : peerConnection._pendingRemoteOffer;\n  var pendingRemoteOffer = local ? peerConnection._pendingRemoteOffer : peerConnection._pendingLocalOffer;\n  var intermediateState = local ? 'have-local-offer' : 'have-remote-offer';\n  var setLocalDescription = local ? 'setLocalDescription' : 'setRemoteDescription';\n\n  if (!local && pendingRemoteOffer && description.type === 'answer') {\n    return setRemoteAnswer(peerConnection, description);\n  } else if (description.type === 'offer') {\n    if (peerConnection.signalingState !== intermediateState && peerConnection.signalingState !== 'stable') {\n      return Promise.reject(new Error('Cannot set ' + (local ? 'local' : 'remote') + ' offer in state ' + peerConnection.signalingState));\n    }\n\n    if (!pendingLocalOffer && peerConnection._signalingStateLatch.state === 'low') {\n      peerConnection._signalingStateLatch.raise();\n    }\n\n    var previousSignalingState = peerConnection.signalingState;\n    setPendingLocalOffer(description); // Only dispatch a signalingstatechange event if we transitioned.\n\n    if (peerConnection.signalingState !== previousSignalingState) {\n      return Promise.resolve().then(function dispatchSignalingStateChangeEvent() {\n        peerConnection.dispatchEvent(new Event('signalingstatechange'));\n      });\n    }\n\n    return Promise.resolve();\n  } else if (description.type === 'rollback') {\n    if (peerConnection.signalingState !== intermediateState) {\n      return Promise.reject(new Error('Cannot rollback ' + (local ? 'local' : 'remote') + ' description in ' + peerConnection.signalingState));\n    }\n\n    clearPendingLocalOffer(); // NOTE(mmalavalli): We store the rolled back tracks to SSRCs Map here in case\n    // setLocalDescription() is called immediately aftera rollback (without calling\n    // createOffer() or createAnswer()), in which case this roll back is not due to\n    // a glare scenario and this Map should be restored.\n\n    peerConnection._rolledBackTracksToSSRCs = new Map(peerConnection._tracksToSSRCs);\n    peerConnection._tracksToSSRCs = new Map(peerConnection._appliedTracksToSSRCs);\n    return Promise.resolve().then(function dispatchSignalingStateChangeEvent() {\n      peerConnection.dispatchEvent(new Event('signalingstatechange'));\n    });\n  }\n\n  return peerConnection._peerConnection[setLocalDescription](description);\n}\n\nfunction setRemoteAnswer(peerConnection, answer) {\n  var pendingLocalOffer = peerConnection._pendingLocalOffer;\n  return peerConnection._peerConnection.setLocalDescription(pendingLocalOffer).then(function setLocalOfferSucceeded() {\n    peerConnection._pendingLocalOffer = null;\n    return peerConnection.setRemoteDescription(answer);\n  }).then(function setRemoteAnswerSucceeded() {\n    peerConnection._signalingStateLatch.lower();\n  });\n}\n/**\n * Whether a SafariRTCPeerConnection has any RTCRtpReceivers(s) for the given\n * MediaStreamTrack kind.\n * @param {SafariRTCPeerConnection} peerConnection\n * @param {'audio' | 'video'} kind\n * @returns {boolean}\n */\n\n\nfunction hasReceiversForTracksOfKind(peerConnection, kind) {\n  return !!peerConnection.getTransceivers().find(function (transceiver) {\n    return transceiver.receiver && transceiver.receiver.track && transceiver.receiver.track.kind === kind;\n  });\n}\n/**\n * Shim an RTCDataChannel. This function mutates the RTCDataChannel.\n * @param {RTCDataChannel} dataChannel\n * @returns {RTCDataChannel}\n */\n\n\nfunction shimDataChannel(dataChannel) {\n  return Object.defineProperties(dataChannel, {\n    maxPacketLifeTime: {\n      value: dataChannel.maxPacketLifeTime === 65535 ? null : dataChannel.maxPacketLifeTime\n    },\n    maxRetransmits: {\n      value: dataChannel.maxRetransmits === 65535 ? null : dataChannel.maxRetransmits\n    }\n  });\n}\n\nmodule.exports = SafariRTCPeerConnection;","map":{"version":3,"sources":["/home/ascencion/sebrae_megahack/node_modules/@twilio/webrtc/lib/rtcpeerconnection/safari.js"],"names":["EventTarget","require","inherits","Latch","sdpUtils","util","isUnifiedPlan","getSdpFormat","updateTrackIdsToSSRCs","updateUnifiedPlanTrackIdsToSSRCs","updatePlanBTrackIdsToSSRCs","SafariRTCPeerConnection","configuration","call","interceptEvent","peerConnection","RTCPeerConnection","Object","defineProperties","_appliedTracksToSSRCs","value","Map","writable","_audioTransceiver","_isClosed","_peerConnection","_pendingLocalOffer","_pendingRemoteOffer","_rolledBackTracksToSSRCs","_signalingStateLatch","_tracksToSSRCs","_videoTransceiver","localDescription","enumerable","get","iceConnectionState","iceGatheringState","remoteDescription","signalingState","self","addEventListener","ondatachannel","event","shimDataChannel","channel","dispatchEvent","oniceconnectionstatechange","apply","arguments","onsignalingstatechange","ontrack","proxyProperties","prototype","addIceCandidate","candidate","when","then","signalingStatesResolved","createOffer","options","assign","offerToReceiveAudio","hasReceiversForTracksOfKind","addTransceiver","direction","e","Promise","reject","offerToReceiveVideo","offer","clear","RTCSessionDescription","type","sdp","createAnswer","setRemoteDescription","setRemoteDescriptionSucceeded","lower","createAnswerSucceeded","answer","setRemoteDescriptionOrCreateAnswerFailed","error","createDataChannel","label","dataChannelDict","dataChannel","removeTrack","sender","replaceTrack","setLocalDescription","description","size","setDescription","close","setTimeout","Event","delegateMethods","local","setPendingLocalOffer","clearPendingLocalOffer","pendingLocalOffer","pendingRemoteOffer","intermediateState","setRemoteAnswer","Error","state","raise","previousSignalingState","resolve","dispatchSignalingStateChangeEvent","setLocalOfferSucceeded","setRemoteAnswerSucceeded","kind","getTransceivers","find","transceiver","receiver","track","maxPacketLifeTime","maxRetransmits","module","exports"],"mappings":"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","sourcesContent":["/* globals RTCPeerConnection, RTCSessionDescription */\n'use strict';\n\nvar EventTarget = require('../util/eventtarget');\nvar inherits = require('util').inherits;\nvar Latch = require('../util/latch');\nvar sdpUtils = require('../util/sdp');\nvar util = require('../util');\n\nvar isUnifiedPlan = sdpUtils.getSdpFormat() === 'unified';\n\nvar updateTrackIdsToSSRCs = isUnifiedPlan\n  ? sdpUtils.updateUnifiedPlanTrackIdsToSSRCs\n  : sdpUtils.updatePlanBTrackIdsToSSRCs;\n\nfunction SafariRTCPeerConnection(configuration) {\n  if (!(this instanceof SafariRTCPeerConnection)) {\n    return new SafariRTCPeerConnection(configuration);\n  }\n\n  EventTarget.call(this);\n\n  util.interceptEvent(this, 'datachannel');\n  util.interceptEvent(this, 'iceconnectionstatechange');\n  util.interceptEvent(this, 'signalingstatechange');\n  util.interceptEvent(this, 'track');\n\n  var peerConnection = new RTCPeerConnection(configuration);\n\n  Object.defineProperties(this, {\n    _appliedTracksToSSRCs: {\n      value: new Map(),\n      writable: true\n    },\n    _audioTransceiver: {\n      value: null,\n      writable: true\n    },\n    _isClosed: {\n      value: false,\n      writable: true\n    },\n    _peerConnection: {\n      value: peerConnection\n    },\n    _pendingLocalOffer: {\n      value: null,\n      writable: true\n    },\n    _pendingRemoteOffer: {\n      value: null,\n      writable: true\n    },\n    _rolledBackTracksToSSRCs: {\n      value: new Map(),\n      writable: true\n    },\n    _signalingStateLatch: {\n      value: new Latch()\n    },\n    _tracksToSSRCs: {\n      value: new Map(),\n      writable: true\n    },\n    _videoTransceiver: {\n      value: null,\n      writable: true\n    },\n    localDescription: {\n      enumerable: true,\n      get: function() {\n        return this._pendingLocalOffer || this._peerConnection.localDescription;\n      }\n    },\n    iceConnectionState: {\n      enumerable: true,\n      get: function() {\n        return this._isClosed ? 'closed' : this._peerConnection.iceConnectionState;\n      }\n    },\n    iceGatheringState: {\n      enumerable: true,\n      get: function() {\n        return this._isClosed ? 'complete' : this._peerConnection.iceGatheringState;\n      }\n    },\n    remoteDescription: {\n      enumerable: true,\n      get: function() {\n        return this._pendingRemoteOffer || this._peerConnection.remoteDescription;\n      }\n    },\n    signalingState: {\n      enumerable: true,\n      get: function() {\n        if (this._isClosed) {\n          return 'closed';\n        } else if (this._pendingLocalOffer) {\n          return 'have-local-offer';\n        } else if (this._pendingRemoteOffer) {\n          return 'have-remote-offer';\n        }\n        return this._peerConnection.signalingState;\n      }\n    }\n  });\n\n  var self = this;\n\n  peerConnection.addEventListener('datachannel', function ondatachannel(event) {\n    shimDataChannel(event.channel);\n    self.dispatchEvent(event);\n  });\n\n  peerConnection.addEventListener('iceconnectionstatechange', function oniceconnectionstatechange() {\n    if (self._isClosed) {\n      return;\n    }\n    self.dispatchEvent.apply(self, arguments);\n  });\n\n  peerConnection.addEventListener('signalingstatechange', function onsignalingstatechange() {\n    if (self._isClosed) {\n      return;\n    }\n    if (peerConnection.signalingState === 'stable') {\n      self._appliedTracksToSSRCs = new Map(self._tracksToSSRCs);\n    }\n    if (!self._pendingLocalOffer && !self._pendingRemoteOffer) {\n      self.dispatchEvent.apply(self, arguments);\n    }\n  });\n\n  // NOTE(syerrapragada): This ensures that SafariRTCPeerConnection's \"remoteDescription\", when accessed\n  // in an RTCTrackEvent listener, will point to the underlying RTCPeerConnection's\n  // \"remoteDescription\". Before this fix, this was still pointing to \"_pendingRemoteOffer\"\n  // even though a new remote RTCSessionDescription had already been applied.\n  peerConnection.addEventListener('track', function ontrack(event) {\n    self._pendingRemoteOffer = null;\n    self.dispatchEvent(event);\n  });\n\n  util.proxyProperties(RTCPeerConnection.prototype, this, peerConnection);\n}\n\ninherits(SafariRTCPeerConnection, EventTarget);\n\nSafariRTCPeerConnection.prototype.addIceCandidate = function addIceCandidate(candidate) {\n  var self = this;\n  if (this.signalingState === 'have-remote-offer') {\n    return this._signalingStateLatch.when('low').then(function signalingStatesResolved() {\n      return self._peerConnection.addIceCandidate(candidate);\n    });\n  }\n  return this._peerConnection.addIceCandidate(candidate);\n};\n\nSafariRTCPeerConnection.prototype.createOffer = function createOffer(options) {\n  options = Object.assign({}, options);\n  var self = this;\n\n  // NOTE(mroberts): In general, this is not the way to do this; however, it's\n  // good enough for our application.\n  if (options.offerToReceiveAudio && !this._audioTransceiver && !(isUnifiedPlan && hasReceiversForTracksOfKind(this, 'audio'))) {\n    delete options.offerToReceiveAudio;\n    try {\n      this._audioTransceiver = isUnifiedPlan\n        ? this.addTransceiver('audio', { direction: 'recvonly' })\n        : this.addTransceiver('audio');\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  }\n\n  if (options.offerToReceiveVideo && !this._videoTransceiver && !(isUnifiedPlan && hasReceiversForTracksOfKind(this, 'video'))) {\n    delete options.offerToReceiveVideo;\n    try {\n      this._videoTransceiver = isUnifiedPlan\n        ? this.addTransceiver('video', { direction: 'recvonly' })\n        : this.addTransceiver('video');\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  }\n\n  return this._peerConnection.createOffer(options).then(function(offer) {\n    // NOTE(mmalavalli): If createOffer() is called immediately after rolling back,\n    // then we no longer need to retain the rolled back tracks to SSRCs Map.\n    self._rolledBackTracksToSSRCs.clear();\n\n    return new RTCSessionDescription({\n      type: offer.type,\n      sdp: updateTrackIdsToSSRCs(self._tracksToSSRCs, offer.sdp)\n    });\n  });\n};\n\nSafariRTCPeerConnection.prototype.createAnswer = function createAnswer(options) {\n  var self = this;\n\n  if (this._pendingRemoteOffer) {\n    return this._peerConnection.setRemoteDescription(this._pendingRemoteOffer).then(function setRemoteDescriptionSucceeded() {\n      self._signalingStateLatch.lower();\n      return self._peerConnection.createAnswer();\n    }).then(function createAnswerSucceeded(answer) {\n      self._pendingRemoteOffer = null;\n\n      // NOTE(mmalavalli): If createAnswer() is called immediately after rolling back, then we no\n      // longer need to retain the rolled back tracks to SSRCs Map.\n      self._rolledBackTracksToSSRCs.clear();\n\n      return isUnifiedPlan ? new RTCSessionDescription({\n        type: answer.type,\n        sdp: updateTrackIdsToSSRCs(self._tracksToSSRCs, answer.sdp)\n      }) : answer;\n    }, function setRemoteDescriptionOrCreateAnswerFailed(error) {\n      self._pendingRemoteOffer = null;\n      throw error;\n    });\n  }\n\n  return this._peerConnection.createAnswer(options).then(function createAnswerSucceeded(answer) {\n    // NOTE(mmalavalli): If createAnswer() is called immediately after rolling back, then we no\n    // longer need to retain the rolled back tracks to SSRCs Map.\n    self._rolledBackTracksToSSRCs.clear();\n\n    return isUnifiedPlan ? new RTCSessionDescription({\n      type: answer.type,\n      sdp: updateTrackIdsToSSRCs(self._tracksToSSRCs, answer.sdp)\n    }) : answer;\n  });\n};\n\nSafariRTCPeerConnection.prototype.createDataChannel = function createDataChannel(label, dataChannelDict) {\n  var dataChannel = this._peerConnection.createDataChannel(label, dataChannelDict);\n  shimDataChannel(dataChannel);\n  return dataChannel;\n};\n\nSafariRTCPeerConnection.prototype.removeTrack = function removeTrack(sender) {\n  sender.replaceTrack(null);\n  this._peerConnection.removeTrack(sender);\n};\n\nSafariRTCPeerConnection.prototype.setLocalDescription = function setLocalDescription(description) {\n  // NOTE(mmalavalli): If setLocalDescription() is called immediately after rolling back,\n  // then we need to restore the rolled back tracks to SSRCs Map.\n  if (this._rolledBackTracksToSSRCs.size > 0) {\n    this._tracksToSSRCs = new Map(this._rolledBackTracksToSSRCs);\n    this._rolledBackTracksToSSRCs.clear();\n  }\n  return setDescription(this, true, description);\n};\n\nSafariRTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription(description) {\n  // NOTE(mmalavalli): If setRemoteDescription() is called immediately after rolling back,\n  // then we no longer need to retain the rolled back tracks to SSRCs Map.\n  this._rolledBackTracksToSSRCs.clear();\n  return setDescription(this, false, description);\n};\n\nSafariRTCPeerConnection.prototype.close = function close() {\n  if (this._isClosed) {\n    return;\n  }\n  this._isClosed = true;\n  this._peerConnection.close();\n  var self = this;\n  setTimeout(function() {\n    self.dispatchEvent(new Event('iceconnectionstatechange'));\n    self.dispatchEvent(new Event('signalingstatechange'));\n  });\n};\n\nutil.delegateMethods(\n  RTCPeerConnection.prototype,\n  SafariRTCPeerConnection.prototype,\n  '_peerConnection');\n\nfunction setDescription(peerConnection, local, description) {\n  function setPendingLocalOffer(offer) {\n    if (local) {\n      peerConnection._pendingLocalOffer = offer;\n    } else {\n      peerConnection._pendingRemoteOffer = offer;\n    }\n  }\n\n  function clearPendingLocalOffer() {\n    if (local) {\n      peerConnection._pendingLocalOffer = null;\n    } else {\n      peerConnection._pendingRemoteOffer = null;\n    }\n  }\n\n  var pendingLocalOffer = local ? peerConnection._pendingLocalOffer : peerConnection._pendingRemoteOffer;\n  var pendingRemoteOffer = local ? peerConnection._pendingRemoteOffer : peerConnection._pendingLocalOffer;\n  var intermediateState = local ? 'have-local-offer' : 'have-remote-offer';\n  var setLocalDescription = local ? 'setLocalDescription' : 'setRemoteDescription';\n\n  if (!local && pendingRemoteOffer && description.type === 'answer') {\n    return setRemoteAnswer(peerConnection, description);\n  } else if (description.type === 'offer') {\n    if (peerConnection.signalingState !== intermediateState && peerConnection.signalingState !== 'stable') {\n      return Promise.reject(new Error('Cannot set ' + (local ? 'local' : 'remote') +\n        ' offer in state ' + peerConnection.signalingState));\n    }\n\n    if (!pendingLocalOffer && peerConnection._signalingStateLatch.state === 'low') {\n      peerConnection._signalingStateLatch.raise();\n    }\n    var previousSignalingState = peerConnection.signalingState;\n    setPendingLocalOffer(description);\n\n    // Only dispatch a signalingstatechange event if we transitioned.\n    if (peerConnection.signalingState !== previousSignalingState) {\n      return Promise.resolve().then(function dispatchSignalingStateChangeEvent() {\n        peerConnection.dispatchEvent(new Event('signalingstatechange'));\n      });\n    }\n\n    return Promise.resolve();\n  } else if (description.type === 'rollback') {\n    if (peerConnection.signalingState !== intermediateState) {\n      return Promise.reject(new Error('Cannot rollback ' +\n        (local ? 'local' : 'remote') + ' description in ' + peerConnection.signalingState));\n    }\n    clearPendingLocalOffer();\n\n    // NOTE(mmalavalli): We store the rolled back tracks to SSRCs Map here in case\n    // setLocalDescription() is called immediately aftera rollback (without calling\n    // createOffer() or createAnswer()), in which case this roll back is not due to\n    // a glare scenario and this Map should be restored.\n    peerConnection._rolledBackTracksToSSRCs = new Map(peerConnection._tracksToSSRCs);\n    peerConnection._tracksToSSRCs = new Map(peerConnection._appliedTracksToSSRCs);\n\n    return Promise.resolve().then(function dispatchSignalingStateChangeEvent() {\n      peerConnection.dispatchEvent(new Event('signalingstatechange'));\n    });\n  }\n\n  return peerConnection._peerConnection[setLocalDescription](description);\n}\n\nfunction setRemoteAnswer(peerConnection, answer) {\n  var pendingLocalOffer = peerConnection._pendingLocalOffer;\n  return peerConnection._peerConnection.setLocalDescription(pendingLocalOffer).then(function setLocalOfferSucceeded() {\n    peerConnection._pendingLocalOffer = null;\n    return peerConnection.setRemoteDescription(answer);\n  }).then(function setRemoteAnswerSucceeded() {\n    peerConnection._signalingStateLatch.lower();\n  });\n}\n\n/**\n * Whether a SafariRTCPeerConnection has any RTCRtpReceivers(s) for the given\n * MediaStreamTrack kind.\n * @param {SafariRTCPeerConnection} peerConnection\n * @param {'audio' | 'video'} kind\n * @returns {boolean}\n */\nfunction hasReceiversForTracksOfKind(peerConnection, kind) {\n  return !!peerConnection.getTransceivers().find(function(transceiver) {\n    return transceiver.receiver && transceiver.receiver.track && transceiver.receiver.track.kind === kind;\n  });\n}\n\n/**\n * Shim an RTCDataChannel. This function mutates the RTCDataChannel.\n * @param {RTCDataChannel} dataChannel\n * @returns {RTCDataChannel}\n */\nfunction shimDataChannel(dataChannel) {\n  return Object.defineProperties(dataChannel, {\n    maxPacketLifeTime: {\n      value: dataChannel.maxPacketLifeTime === 65535\n        ? null\n        : dataChannel.maxPacketLifeTime\n    },\n    maxRetransmits: {\n      value: dataChannel.maxRetransmits === 65535\n        ? null\n        : dataChannel.maxRetransmits\n    }\n  });\n}\n\nmodule.exports = SafariRTCPeerConnection;\n"]},"metadata":{},"sourceType":"script"}