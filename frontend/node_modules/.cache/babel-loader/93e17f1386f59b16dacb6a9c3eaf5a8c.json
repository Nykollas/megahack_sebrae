{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst syncerror_1 = require(\"./utils/syncerror\");\n\nconst sanitize_1 = require(\"./utils/sanitize\");\n\nconst logger_1 = require(\"./utils/logger\");\n\nconst entity_1 = require(\"./entity\");\n\nconst mergingqueue_1 = require(\"./mergingqueue\");\n\nconst closeable_1 = require(\"./closeable\");\n\nclass SyncDocumentImpl extends entity_1.SyncEntity {\n  /**\n   * @private\n   */\n  constructor(services, descriptor, removalHandler) {\n    super(services, removalHandler);\n    this.isDeleted = false;\n\n    const updateRequestReducer = (acc, input) => typeof input.ttl === 'number' ? {\n      ttl: input.ttl\n    } : acc;\n\n    this.updateMergingQueue = new mergingqueue_1.MergingQueue(updateRequestReducer);\n    this.descriptor = descriptor;\n    this.descriptor.data = this.descriptor.data || {};\n    this.descriptor.date_updated = new Date(this.descriptor.date_updated);\n  } // private props\n\n\n  get uri() {\n    return this.descriptor.url;\n  }\n\n  get revision() {\n    return this.descriptor.revision;\n  }\n\n  get lastEventId() {\n    return this.descriptor.last_event_id;\n  }\n\n  get dateExpires() {\n    return this.descriptor.date_expires;\n  }\n\n  static get type() {\n    return 'document';\n  }\n\n  get type() {\n    return 'document';\n  } // below properties are specific to Insights only\n\n\n  get indexName() {\n    return undefined;\n  }\n\n  get queryString() {\n    return undefined;\n  } // public props, documented along with class description\n\n\n  get sid() {\n    return this.descriptor.sid;\n  }\n\n  get value() {\n    return this.descriptor.data;\n  }\n\n  get dateUpdated() {\n    return this.descriptor.date_updated;\n  }\n\n  get uniqueName() {\n    return this.descriptor.unique_name || null;\n  }\n  /**\n   * Update data entity with new data\n   * @private\n   */\n\n\n  _update(update) {\n    update.date_created = new Date(update.date_created);\n\n    switch (update.type) {\n      case 'document_updated':\n        if (update.id > this.lastEventId) {\n          this.descriptor.last_event_id = update.id;\n          this.descriptor.revision = update.document_revision;\n          this.descriptor.date_updated = update.date_created;\n          this.descriptor.data = update.document_data;\n          this.broadcastEventToListeners('updated', {\n            value: update.document_data,\n            isLocal: false\n          });\n          this.services.storage.update(this.type, this.sid, this.uniqueName, {\n            last_event_id: update.id,\n            revision: update.document_revision,\n            date_updated: update.date_created,\n            data: update.document_data\n          });\n        } else {\n          logger_1.default.trace('Document update skipped, current:', this.lastEventId, ', remote:', update.id);\n        }\n\n        break;\n\n      case 'document_removed':\n        this.onRemoved(false);\n        break;\n    }\n  }\n\n  async set(value, metadataUpdates) {\n    const input = metadataUpdates || {};\n    sanitize_1.validateOptionalTtl(input.ttl);\n    return this.updateMergingQueue.squashAndAdd(input, input => this._setUnconditionally(value, input.ttl));\n  }\n\n  async mutate(mutator, metadataUpdates) {\n    const input = metadataUpdates || {};\n    sanitize_1.validateOptionalTtl(input.ttl);\n    return this.updateMergingQueue.add(input, input => this._setWithIfMatch(mutator, input.ttl));\n  }\n\n  async update(obj, metadataUpdates) {\n    return this.mutate(remote => Object.assign(remote, obj), metadataUpdates);\n  }\n\n  async setTtl(ttl) {\n    sanitize_1.validateMandatoryTtl(ttl);\n    const response = await this._postUpdateToServer({\n      ttl\n    });\n    this.descriptor.date_expires = response.date_expires;\n  }\n  /**\n   * @private\n   */\n\n\n  async _setUnconditionally(value, ttl) {\n    let result = await this._postUpdateToServer({\n      data: value,\n      revision: undefined,\n      ttl\n    });\n\n    this._handleSuccessfulUpdateResult(result);\n\n    return this.value;\n  }\n  /**\n   * @private\n   */\n\n\n  async _setWithIfMatch(mutatorFunction, ttl) {\n    let data = mutatorFunction(sanitize_1.deepClone(this.value));\n\n    if (data) {\n      let revision = this.revision;\n\n      try {\n        let result = await this._postUpdateToServer({\n          data,\n          revision,\n          ttl\n        });\n\n        this._handleSuccessfulUpdateResult(result);\n\n        return this.value;\n      } catch (error) {\n        if (error.status === 412) {\n          await this._softSync();\n          return this._setWithIfMatch(mutatorFunction);\n        } else {\n          throw error;\n        }\n      }\n    } else {\n      return this.value;\n    }\n  }\n  /**\n   * @private\n   */\n\n\n  _handleSuccessfulUpdateResult(result) {\n    if (result.last_event_id > this.descriptor.last_event_id) {\n      // Ignore returned value if we already got a newer one\n      this.descriptor.revision = result.revision;\n      this.descriptor.data = result.data;\n      this.descriptor.last_event_id = result.last_event_id;\n      this.descriptor.date_expires = result.date_expires;\n      this.descriptor.date_updated = new Date(result.date_updated);\n      this.services.storage.update(this.type, this.sid, this.uniqueName, {\n        last_event_id: result.last_event_id,\n        revision: result.revision,\n        date_updated: result.date_updated,\n        data: result.data\n      });\n      this.broadcastEventToListeners('updated', {\n        value: this.value,\n        isLocal: true\n      });\n    }\n  }\n  /**\n   * @private\n   */\n\n\n  async _postUpdateToServer(request) {\n    if (!this.isDeleted) {\n      const requestBody = {\n        data: request.data\n      };\n\n      if (request.ttl !== undefined) {\n        requestBody.ttl = request.ttl;\n      }\n\n      const ifMatch = request.revision;\n\n      try {\n        const response = await this.services.network.post(this.uri, requestBody, ifMatch);\n        return {\n          revision: response.body.revision,\n          data: request.data,\n          last_event_id: response.body.last_event_id,\n          date_updated: response.body.date_updated,\n          date_expires: response.body.date_expires\n        };\n      } catch (error) {\n        if (error.status === 404) {\n          this.onRemoved(false);\n        }\n\n        throw error;\n      }\n    } else {\n      return Promise.reject(new syncerror_1.SyncError('The Document has been removed', 404, 54100));\n    }\n  }\n  /**\n   * Get new data from server\n   * @private\n   */\n\n\n  async _softSync() {\n    return this.services.network.get(this.uri).then(response => {\n      const event = {\n        type: 'document_updated',\n        id: response.body.last_event_id,\n        document_revision: response.body.revision,\n        document_data: response.body.data,\n        date_created: response.body.date_updated\n      };\n\n      this._update(event);\n\n      return this;\n    }).catch(err => {\n      if (err.status === 404) {\n        this.onRemoved(false);\n      } else {\n        logger_1.default.error(`Can't get updates for ${this.sid}:`, err);\n      }\n    });\n  }\n\n  onRemoved(locally) {\n    if (this.isDeleted) {\n      return;\n    } else {\n      this.isDeleted = true;\n\n      this._unsubscribe();\n\n      this.removalHandler(this.type, this.sid, this.uniqueName);\n      this.broadcastEventToListeners('removed', {\n        isLocal: locally\n      });\n    }\n  }\n\n  async removeDocument() {\n    if (!this.isDeleted) {\n      await this.services.network.delete(this.uri);\n      this.onRemoved(true);\n    } else {\n      return Promise.reject(new syncerror_1.SyncError('The Document has been removed', 404, 54100));\n    }\n  }\n\n}\n\nexports.SyncDocumentImpl = SyncDocumentImpl;\n/**\n * @class\n * @alias Document\n * @classdesc Represents a Sync Document, the contents of which is a single JSON object.\n * Use the {@link Client#document} method to obtain a reference to a Sync Document.\n * @property {String} sid The immutable identifier of this document, assigned by the system.\n * @property {String} [uniqueName=null] An optional immutable identifier that may be assigned by the programmer\n * to this document during creation. Globally unique among other Documents.\n * @property {Date} dateUpdated Date when the Document was last updated.\n * @property {Object} value The contents of this document.\n *\n * @fires Document#removed\n * @fires Document#updated\n */\n\nclass SyncDocument extends closeable_1.default {\n  constructor(syncDocumentImpl) {\n    super();\n    this.syncDocumentImpl = syncDocumentImpl;\n    this.syncDocumentImpl.attach(this);\n  } // private props\n\n\n  get uri() {\n    return this.syncDocumentImpl.uri;\n  }\n\n  get revision() {\n    return this.syncDocumentImpl.revision;\n  }\n\n  get lastEventId() {\n    return this.syncDocumentImpl.lastEventId;\n  }\n\n  get dateExpires() {\n    return this.syncDocumentImpl.dateExpires;\n  }\n\n  static get type() {\n    return SyncDocumentImpl.type;\n  }\n\n  get type() {\n    return SyncDocumentImpl.type;\n  } // public props, documented along with class description\n\n\n  get sid() {\n    return this.syncDocumentImpl.sid;\n  }\n\n  get value() {\n    return this.syncDocumentImpl.value;\n  }\n\n  get dateUpdated() {\n    return this.syncDocumentImpl.dateUpdated;\n  }\n\n  get uniqueName() {\n    return this.syncDocumentImpl.uniqueName;\n  }\n  /**\n   * Assign new contents to this document. The current value will be overwritten.\n   * @param {Object} value The new contents to assign.\n   * @param {Document#Metadata} [metadataUpdates] New document metadata.\n   * @returns {Promise<Object>} A promise resolving to the new value of the document.\n   * @public\n   * @example\n   * // Say, the Document value is { name: 'John Smith', age: 34 }\n   * document.set({ name: 'Barbara Oaks' }, { ttl: 86400 })\n   *   .then(function(newValue) {\n   *     // Now the Document value is { name: 'Barbara Oaks' }\n   *     console.log('Document set() successful, new value:', newValue);\n   *   })\n   *   .catch(function(error) {\n   *     console.error('Document set() failed', error);\n   *   });\n   */\n\n\n  async set(value, metadataUpdates) {\n    this.ensureNotClosed();\n    return this.syncDocumentImpl.set(value, metadataUpdates);\n  }\n  /**\n   * Schedules a modification to this document that will apply a mutation function.\n   * @param {Document~Mutator} mutator A function that outputs a new value based on the existing value.\n   * May be called multiple times, particularly if this Document is modified concurrently by remote code.\n   * If the mutation ultimately succeeds, the Document will have made the particular transition described\n   * by this function.\n   * @param {Document#Metadata} [metadataUpdates] New document metadata.\n   * @return {Promise<Object>} Resolves with the most recent Document state, whether the output of a\n   *    successful mutation or a state that prompted graceful cancellation (mutator returned <code>null</code>).\n   * @public\n   * @example\n   * var mutatorFunction = function(currentValue) {\n   *     currentValue.viewCount = (currentValue.viewCount || 0) + 1;\n   *     return currentValue;\n   * };\n   * document.mutate(mutatorFunction, { ttl: 86400 }))\n   *   .then(function(newValue) {\n   *     console.log('Document mutate() successful, new value:', newValue);\n   *   })\n   *   .catch(function(error) {\n   *     console.error('Document mutate() failed', error);\n   *   });\n   */\n\n\n  async mutate(mutator, metadataUpdates) {\n    this.ensureNotClosed();\n    return this.syncDocumentImpl.mutate(mutator, metadataUpdates);\n  }\n  /**\n   * Modify a document by appending new fields (or by overwriting existing ones) with the values from the provided Object.\n   * This is equivalent to\n   * <pre>\n   * document.mutate(function(currentValue) {\n   *   return Object.assign(currentValue, obj));\n   * });\n   * </pre>\n   * @param {Object} obj Specifies the particular (top-level) attributes that will receive new values.\n   * @param {Document#Metadata} [metadataUpdates] New document metadata.\n   * @return {Promise<Object>} A promise resolving to the new value of the document.\n   * @public\n   * @example\n   * // Say, the Document value is { name: 'John Smith' }\n   * document.update({ age: 34 }, { ttl: 86400 })\n   *   .then(function(newValue) {\n   *     // Now the Document value is { name: 'John Smith', age: 34 }\n   *     console.log('Document update() successful, new value:', newValue);\n   *   })\n   *   .catch(function(error) {\n   *     console.error('Document update() failed', error);\n   *   });\n   */\n\n\n  async update(obj, metadataUpdates) {\n    this.ensureNotClosed();\n    return this.syncDocumentImpl.update(obj, metadataUpdates);\n  }\n  /**\n   * Update the time-to-live of the document.\n   * @param {Number} ttl Specifies the time-to-live in seconds after which the document is subject to automatic deletion. The value 0 means infinity.\n   * @return {Promise<void>} A promise that resolves after the TTL update was successful.\n   * @public\n   * @example\n   * document.setTtl(3600)\n   *   .then(function() {\n   *     console.log('Document setTtl() successful');\n   *   })\n   *   .catch(function(error) {\n   *     console.error('Document setTtl() failed', error);\n   *   });\n   */\n\n\n  async setTtl(ttl) {\n    this.ensureNotClosed();\n    return this.syncDocumentImpl.setTtl(ttl);\n  }\n  /**\n   * Delete a document.\n   * @return {Promise<void>} A promise which resolves if (and only if) the document is ultimately deleted.\n   * @public\n   * @example\n   * document.removeDocument()\n   *   .then(function() {\n   *     console.log('Document removeDocument() successful');\n   *   })\n   *   .catch(function(error) {\n   *     console.error('Document removeDocument() failed', error);\n   *   });\n   */\n\n\n  async removeDocument() {\n    this.ensureNotClosed();\n    return this.syncDocumentImpl.removeDocument();\n  }\n  /**\n   * Conclude work with the document instance and remove all event listeners attached to it.\n   * Any subsequent operation on this object will be rejected with error.\n   * Other local copies of this document will continue operating and receiving events normally.\n   * @public\n   * @example\n   * document.close();\n   */\n\n\n  close() {\n    super.close();\n    this.syncDocumentImpl.detach(this.listenerUuid);\n  }\n\n}\n\nexports.SyncDocument = SyncDocument;\nexports.default = SyncDocument;\n/**\n * Contains Document metadata.\n * @typedef {Object} Document#Metadata\n * @property {Number} [ttl] Specifies the time-to-live in seconds after which the document is subject to automatic deletion.\n * The value 0 means infinity.\n */\n\n/**\n * Applies a transformation to the document value.\n * @callback Document~Mutator\n * @param {Object} currentValue The current value of the document in the cloud.\n * @return {Object} The desired new value for the document or <code>null</code> to gracefully cancel the mutation.\n */\n\n/**\n * Fired when the document is removed, whether the remover was local or remote.\n * @event Document#removed\n * @param {Object} args Arguments provided with the event.\n * @param {Boolean} args.isLocal Equals 'true' if document was removed by local actor, 'false' otherwise.\n * @example\n * document.on('removed', function(args) {\n *   console.log('Document ' + document.sid + ' was removed');\n *   console.log('args.isLocal:', args.isLocal);\n * });\n */\n\n/**\n * Fired when the document's contents have changed, whether the updater was local or remote.\n * @event Document#updated\n * @param {Object} args Arguments provided with the event.\n * @param {Object} args.value A snapshot of the document's new contents.\n * @param {Boolean} args.isLocal Equals 'true' if document was updated by local actor, 'false' otherwise.\n * @example\n * document.on('updated', function(args) {\n *   console.log('Document ' + document.sid + ' was updated');\n *   console.log('args.value: ', args.value);\n *   console.log('args.isLocal: ', args.isLocal);\n * });\n */","map":{"version":3,"sources":["/home/ascencion/sebrae_megahack/node_modules/twilio-sync/lib/syncdocument.js"],"names":["Object","defineProperty","exports","value","syncerror_1","require","sanitize_1","logger_1","entity_1","mergingqueue_1","closeable_1","SyncDocumentImpl","SyncEntity","constructor","services","descriptor","removalHandler","isDeleted","updateRequestReducer","acc","input","ttl","updateMergingQueue","MergingQueue","data","date_updated","Date","uri","url","revision","lastEventId","last_event_id","dateExpires","date_expires","type","indexName","undefined","queryString","sid","dateUpdated","uniqueName","unique_name","_update","update","date_created","id","document_revision","document_data","broadcastEventToListeners","isLocal","storage","default","trace","onRemoved","set","metadataUpdates","validateOptionalTtl","squashAndAdd","_setUnconditionally","mutate","mutator","add","_setWithIfMatch","obj","remote","assign","setTtl","validateMandatoryTtl","response","_postUpdateToServer","result","_handleSuccessfulUpdateResult","mutatorFunction","deepClone","error","status","_softSync","request","requestBody","ifMatch","network","post","body","Promise","reject","SyncError","get","then","event","catch","err","locally","_unsubscribe","removeDocument","delete","SyncDocument","syncDocumentImpl","attach","ensureNotClosed","close","detach","listenerUuid"],"mappings":"AAAA;;AACAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;;AACA,MAAMC,WAAW,GAAGC,OAAO,CAAC,mBAAD,CAA3B;;AACA,MAAMC,UAAU,GAAGD,OAAO,CAAC,kBAAD,CAA1B;;AACA,MAAME,QAAQ,GAAGF,OAAO,CAAC,gBAAD,CAAxB;;AACA,MAAMG,QAAQ,GAAGH,OAAO,CAAC,UAAD,CAAxB;;AACA,MAAMI,cAAc,GAAGJ,OAAO,CAAC,gBAAD,CAA9B;;AACA,MAAMK,WAAW,GAAGL,OAAO,CAAC,aAAD,CAA3B;;AACA,MAAMM,gBAAN,SAA+BH,QAAQ,CAACI,UAAxC,CAAmD;AAC/C;;;AAGAC,EAAAA,WAAW,CAACC,QAAD,EAAWC,UAAX,EAAuBC,cAAvB,EAAuC;AAC9C,UAAMF,QAAN,EAAgBE,cAAhB;AACA,SAAKC,SAAL,GAAiB,KAAjB;;AACA,UAAMC,oBAAoB,GAAG,CAACC,GAAD,EAAMC,KAAN,KAAiB,OAAOA,KAAK,CAACC,GAAb,KAAqB,QAAtB,GAAkC;AAAEA,MAAAA,GAAG,EAAED,KAAK,CAACC;AAAb,KAAlC,GACvCF,GADN;;AAEA,SAAKG,kBAAL,GAA0B,IAAIb,cAAc,CAACc,YAAnB,CAAgCL,oBAAhC,CAA1B;AACA,SAAKH,UAAL,GAAkBA,UAAlB;AACA,SAAKA,UAAL,CAAgBS,IAAhB,GAAuB,KAAKT,UAAL,CAAgBS,IAAhB,IAAwB,EAA/C;AACA,SAAKT,UAAL,CAAgBU,YAAhB,GAA+B,IAAIC,IAAJ,CAAS,KAAKX,UAAL,CAAgBU,YAAzB,CAA/B;AACH,GAb8C,CAc/C;;;AACA,MAAIE,GAAJ,GAAU;AACN,WAAO,KAAKZ,UAAL,CAAgBa,GAAvB;AACH;;AACD,MAAIC,QAAJ,GAAe;AACX,WAAO,KAAKd,UAAL,CAAgBc,QAAvB;AACH;;AACD,MAAIC,WAAJ,GAAkB;AACd,WAAO,KAAKf,UAAL,CAAgBgB,aAAvB;AACH;;AACD,MAAIC,WAAJ,GAAkB;AACd,WAAO,KAAKjB,UAAL,CAAgBkB,YAAvB;AACH;;AACD,aAAWC,IAAX,GAAkB;AACd,WAAO,UAAP;AACH;;AACD,MAAIA,IAAJ,GAAW;AACP,WAAO,UAAP;AACH,GAhC8C,CAiC/C;;;AACA,MAAIC,SAAJ,GAAgB;AACZ,WAAOC,SAAP;AACH;;AACD,MAAIC,WAAJ,GAAkB;AACd,WAAOD,SAAP;AACH,GAvC8C,CAwC/C;;;AACA,MAAIE,GAAJ,GAAU;AACN,WAAO,KAAKvB,UAAL,CAAgBuB,GAAvB;AACH;;AACD,MAAInC,KAAJ,GAAY;AACR,WAAO,KAAKY,UAAL,CAAgBS,IAAvB;AACH;;AACD,MAAIe,WAAJ,GAAkB;AACd,WAAO,KAAKxB,UAAL,CAAgBU,YAAvB;AACH;;AACD,MAAIe,UAAJ,GAAiB;AACb,WAAO,KAAKzB,UAAL,CAAgB0B,WAAhB,IAA+B,IAAtC;AACH;AACD;;;;;;AAIAC,EAAAA,OAAO,CAACC,MAAD,EAAS;AACZA,IAAAA,MAAM,CAACC,YAAP,GAAsB,IAAIlB,IAAJ,CAASiB,MAAM,CAACC,YAAhB,CAAtB;;AACA,YAAQD,MAAM,CAACT,IAAf;AACI,WAAK,kBAAL;AACI,YAAIS,MAAM,CAACE,EAAP,GAAY,KAAKf,WAArB,EAAkC;AAC9B,eAAKf,UAAL,CAAgBgB,aAAhB,GAAgCY,MAAM,CAACE,EAAvC;AACA,eAAK9B,UAAL,CAAgBc,QAAhB,GAA2Bc,MAAM,CAACG,iBAAlC;AACA,eAAK/B,UAAL,CAAgBU,YAAhB,GAA+BkB,MAAM,CAACC,YAAtC;AACA,eAAK7B,UAAL,CAAgBS,IAAhB,GAAuBmB,MAAM,CAACI,aAA9B;AACA,eAAKC,yBAAL,CAA+B,SAA/B,EAA0C;AAAE7C,YAAAA,KAAK,EAAEwC,MAAM,CAACI,aAAhB;AAA+BE,YAAAA,OAAO,EAAE;AAAxC,WAA1C;AACA,eAAKnC,QAAL,CAAcoC,OAAd,CAAsBP,MAAtB,CAA6B,KAAKT,IAAlC,EAAwC,KAAKI,GAA7C,EAAkD,KAAKE,UAAvD,EAAmE;AAC/DT,YAAAA,aAAa,EAAEY,MAAM,CAACE,EADyC;AAE/DhB,YAAAA,QAAQ,EAAEc,MAAM,CAACG,iBAF8C;AAG/DrB,YAAAA,YAAY,EAAEkB,MAAM,CAACC,YAH0C;AAI/DpB,YAAAA,IAAI,EAAEmB,MAAM,CAACI;AAJkD,WAAnE;AAMH,SAZD,MAaK;AACDxC,UAAAA,QAAQ,CAAC4C,OAAT,CAAiBC,KAAjB,CAAuB,mCAAvB,EAA4D,KAAKtB,WAAjE,EAA8E,WAA9E,EAA2Fa,MAAM,CAACE,EAAlG;AACH;;AACD;;AACJ,WAAK,kBAAL;AACI,aAAKQ,SAAL,CAAe,KAAf;AACA;AArBR;AAuBH;;AACD,QAAMC,GAAN,CAAUnD,KAAV,EAAiBoD,eAAjB,EAAkC;AAC9B,UAAMnC,KAAK,GAAGmC,eAAe,IAAI,EAAjC;AACAjD,IAAAA,UAAU,CAACkD,mBAAX,CAA+BpC,KAAK,CAACC,GAArC;AACA,WAAO,KAAKC,kBAAL,CAAwBmC,YAAxB,CAAqCrC,KAArC,EAA4CA,KAAK,IAAI,KAAKsC,mBAAL,CAAyBvD,KAAzB,EAAgCiB,KAAK,CAACC,GAAtC,CAArD,CAAP;AACH;;AACD,QAAMsC,MAAN,CAAaC,OAAb,EAAsBL,eAAtB,EAAuC;AACnC,UAAMnC,KAAK,GAAGmC,eAAe,IAAI,EAAjC;AACAjD,IAAAA,UAAU,CAACkD,mBAAX,CAA+BpC,KAAK,CAACC,GAArC;AACA,WAAO,KAAKC,kBAAL,CAAwBuC,GAAxB,CAA4BzC,KAA5B,EAAmCA,KAAK,IAAI,KAAK0C,eAAL,CAAqBF,OAArB,EAA8BxC,KAAK,CAACC,GAApC,CAA5C,CAAP;AACH;;AACD,QAAMsB,MAAN,CAAaoB,GAAb,EAAkBR,eAAlB,EAAmC;AAC/B,WAAO,KAAKI,MAAL,CAAYK,MAAM,IAAIhE,MAAM,CAACiE,MAAP,CAAcD,MAAd,EAAsBD,GAAtB,CAAtB,EAAkDR,eAAlD,CAAP;AACH;;AACD,QAAMW,MAAN,CAAa7C,GAAb,EAAkB;AACdf,IAAAA,UAAU,CAAC6D,oBAAX,CAAgC9C,GAAhC;AACA,UAAM+C,QAAQ,GAAG,MAAM,KAAKC,mBAAL,CAAyB;AAAEhD,MAAAA;AAAF,KAAzB,CAAvB;AACA,SAAKN,UAAL,CAAgBkB,YAAhB,GAA+BmC,QAAQ,CAACnC,YAAxC;AACH;AACD;;;;;AAGA,QAAMyB,mBAAN,CAA0BvD,KAA1B,EAAiCkB,GAAjC,EAAsC;AAClC,QAAIiD,MAAM,GAAG,MAAM,KAAKD,mBAAL,CAAyB;AAAE7C,MAAAA,IAAI,EAAErB,KAAR;AAAe0B,MAAAA,QAAQ,EAAEO,SAAzB;AAAoCf,MAAAA;AAApC,KAAzB,CAAnB;;AACA,SAAKkD,6BAAL,CAAmCD,MAAnC;;AACA,WAAO,KAAKnE,KAAZ;AACH;AACD;;;;;AAGA,QAAM2D,eAAN,CAAsBU,eAAtB,EAAuCnD,GAAvC,EAA4C;AACxC,QAAIG,IAAI,GAAGgD,eAAe,CAAClE,UAAU,CAACmE,SAAX,CAAqB,KAAKtE,KAA1B,CAAD,CAA1B;;AACA,QAAIqB,IAAJ,EAAU;AACN,UAAIK,QAAQ,GAAG,KAAKA,QAApB;;AACA,UAAI;AACA,YAAIyC,MAAM,GAAG,MAAM,KAAKD,mBAAL,CAAyB;AAAE7C,UAAAA,IAAF;AAAQK,UAAAA,QAAR;AAAkBR,UAAAA;AAAlB,SAAzB,CAAnB;;AACA,aAAKkD,6BAAL,CAAmCD,MAAnC;;AACA,eAAO,KAAKnE,KAAZ;AACH,OAJD,CAKA,OAAOuE,KAAP,EAAc;AACV,YAAIA,KAAK,CAACC,MAAN,KAAiB,GAArB,EAA0B;AACtB,gBAAM,KAAKC,SAAL,EAAN;AACA,iBAAO,KAAKd,eAAL,CAAqBU,eAArB,CAAP;AACH,SAHD,MAIK;AACD,gBAAME,KAAN;AACH;AACJ;AACJ,KAhBD,MAiBK;AACD,aAAO,KAAKvE,KAAZ;AACH;AACJ;AACD;;;;;AAGAoE,EAAAA,6BAA6B,CAACD,MAAD,EAAS;AAClC,QAAIA,MAAM,CAACvC,aAAP,GAAuB,KAAKhB,UAAL,CAAgBgB,aAA3C,EAA0D;AACtD;AACA,WAAKhB,UAAL,CAAgBc,QAAhB,GAA2ByC,MAAM,CAACzC,QAAlC;AACA,WAAKd,UAAL,CAAgBS,IAAhB,GAAuB8C,MAAM,CAAC9C,IAA9B;AACA,WAAKT,UAAL,CAAgBgB,aAAhB,GAAgCuC,MAAM,CAACvC,aAAvC;AACA,WAAKhB,UAAL,CAAgBkB,YAAhB,GAA+BqC,MAAM,CAACrC,YAAtC;AACA,WAAKlB,UAAL,CAAgBU,YAAhB,GAA+B,IAAIC,IAAJ,CAAS4C,MAAM,CAAC7C,YAAhB,CAA/B;AACA,WAAKX,QAAL,CAAcoC,OAAd,CAAsBP,MAAtB,CAA6B,KAAKT,IAAlC,EAAwC,KAAKI,GAA7C,EAAkD,KAAKE,UAAvD,EAAmE;AAC/DT,QAAAA,aAAa,EAAEuC,MAAM,CAACvC,aADyC;AAE/DF,QAAAA,QAAQ,EAAEyC,MAAM,CAACzC,QAF8C;AAG/DJ,QAAAA,YAAY,EAAE6C,MAAM,CAAC7C,YAH0C;AAI/DD,QAAAA,IAAI,EAAE8C,MAAM,CAAC9C;AAJkD,OAAnE;AAMA,WAAKwB,yBAAL,CAA+B,SAA/B,EAA0C;AAAE7C,QAAAA,KAAK,EAAE,KAAKA,KAAd;AAAqB8C,QAAAA,OAAO,EAAE;AAA9B,OAA1C;AACH;AACJ;AACD;;;;;AAGA,QAAMoB,mBAAN,CAA0BQ,OAA1B,EAAmC;AAC/B,QAAI,CAAC,KAAK5D,SAAV,EAAqB;AACjB,YAAM6D,WAAW,GAAG;AAChBtD,QAAAA,IAAI,EAAEqD,OAAO,CAACrD;AADE,OAApB;;AAGA,UAAIqD,OAAO,CAACxD,GAAR,KAAgBe,SAApB,EAA+B;AAC3B0C,QAAAA,WAAW,CAACzD,GAAZ,GAAkBwD,OAAO,CAACxD,GAA1B;AACH;;AACD,YAAM0D,OAAO,GAAGF,OAAO,CAAChD,QAAxB;;AACA,UAAI;AACA,cAAMuC,QAAQ,GAAG,MAAM,KAAKtD,QAAL,CAAckE,OAAd,CAAsBC,IAAtB,CAA2B,KAAKtD,GAAhC,EAAqCmD,WAArC,EAAkDC,OAAlD,CAAvB;AACA,eAAO;AACHlD,UAAAA,QAAQ,EAAEuC,QAAQ,CAACc,IAAT,CAAcrD,QADrB;AAEHL,UAAAA,IAAI,EAAEqD,OAAO,CAACrD,IAFX;AAGHO,UAAAA,aAAa,EAAEqC,QAAQ,CAACc,IAAT,CAAcnD,aAH1B;AAIHN,UAAAA,YAAY,EAAE2C,QAAQ,CAACc,IAAT,CAAczD,YAJzB;AAKHQ,UAAAA,YAAY,EAAEmC,QAAQ,CAACc,IAAT,CAAcjD;AALzB,SAAP;AAOH,OATD,CAUA,OAAOyC,KAAP,EAAc;AACV,YAAIA,KAAK,CAACC,MAAN,KAAiB,GAArB,EAA0B;AACtB,eAAKtB,SAAL,CAAe,KAAf;AACH;;AACD,cAAMqB,KAAN;AACH;AACJ,KAxBD,MAyBK;AACD,aAAOS,OAAO,CAACC,MAAR,CAAe,IAAIhF,WAAW,CAACiF,SAAhB,CAA0B,+BAA1B,EAA2D,GAA3D,EAAgE,KAAhE,CAAf,CAAP;AACH;AACJ;AACD;;;;;;AAIA,QAAMT,SAAN,GAAkB;AACd,WAAO,KAAK9D,QAAL,CAAckE,OAAd,CAAsBM,GAAtB,CAA0B,KAAK3D,GAA/B,EACF4D,IADE,CACGnB,QAAQ,IAAI;AAClB,YAAMoB,KAAK,GAAG;AACVtD,QAAAA,IAAI,EAAE,kBADI;AAEVW,QAAAA,EAAE,EAAEuB,QAAQ,CAACc,IAAT,CAAcnD,aAFR;AAGVe,QAAAA,iBAAiB,EAAEsB,QAAQ,CAACc,IAAT,CAAcrD,QAHvB;AAIVkB,QAAAA,aAAa,EAAEqB,QAAQ,CAACc,IAAT,CAAc1D,IAJnB;AAKVoB,QAAAA,YAAY,EAAEwB,QAAQ,CAACc,IAAT,CAAczD;AALlB,OAAd;;AAOA,WAAKiB,OAAL,CAAa8C,KAAb;;AACA,aAAO,IAAP;AACH,KAXM,EAYFC,KAZE,CAYIC,GAAG,IAAI;AACd,UAAIA,GAAG,CAACf,MAAJ,KAAe,GAAnB,EAAwB;AACpB,aAAKtB,SAAL,CAAe,KAAf;AACH,OAFD,MAGK;AACD9C,QAAAA,QAAQ,CAAC4C,OAAT,CAAiBuB,KAAjB,CAAwB,yBAAwB,KAAKpC,GAAI,GAAzD,EAA6DoD,GAA7D;AACH;AACJ,KAnBM,CAAP;AAoBH;;AACDrC,EAAAA,SAAS,CAACsC,OAAD,EAAU;AACf,QAAI,KAAK1E,SAAT,EAAoB;AAChB;AACH,KAFD,MAGK;AACD,WAAKA,SAAL,GAAiB,IAAjB;;AACA,WAAK2E,YAAL;;AACA,WAAK5E,cAAL,CAAoB,KAAKkB,IAAzB,EAA+B,KAAKI,GAApC,EAAyC,KAAKE,UAA9C;AACA,WAAKQ,yBAAL,CAA+B,SAA/B,EAA0C;AAAEC,QAAAA,OAAO,EAAE0C;AAAX,OAA1C;AACH;AACJ;;AACD,QAAME,cAAN,GAAuB;AACnB,QAAI,CAAC,KAAK5E,SAAV,EAAqB;AACjB,YAAM,KAAKH,QAAL,CAAckE,OAAd,CAAsBc,MAAtB,CAA6B,KAAKnE,GAAlC,CAAN;AACA,WAAK0B,SAAL,CAAe,IAAf;AACH,KAHD,MAIK;AACD,aAAO8B,OAAO,CAACC,MAAR,CAAe,IAAIhF,WAAW,CAACiF,SAAhB,CAA0B,+BAA1B,EAA2D,GAA3D,EAAgE,KAAhE,CAAf,CAAP;AACH;AACJ;;AAzO8C;;AA2OnDnF,OAAO,CAACS,gBAAR,GAA2BA,gBAA3B;AACA;;;;;;;;;;;;;;;AAcA,MAAMoF,YAAN,SAA2BrF,WAAW,CAACyC,OAAvC,CAA+C;AAC3CtC,EAAAA,WAAW,CAACmF,gBAAD,EAAmB;AAC1B;AACA,SAAKA,gBAAL,GAAwBA,gBAAxB;AACA,SAAKA,gBAAL,CAAsBC,MAAtB,CAA6B,IAA7B;AACH,GAL0C,CAM3C;;;AACA,MAAItE,GAAJ,GAAU;AACN,WAAO,KAAKqE,gBAAL,CAAsBrE,GAA7B;AACH;;AACD,MAAIE,QAAJ,GAAe;AACX,WAAO,KAAKmE,gBAAL,CAAsBnE,QAA7B;AACH;;AACD,MAAIC,WAAJ,GAAkB;AACd,WAAO,KAAKkE,gBAAL,CAAsBlE,WAA7B;AACH;;AACD,MAAIE,WAAJ,GAAkB;AACd,WAAO,KAAKgE,gBAAL,CAAsBhE,WAA7B;AACH;;AACD,aAAWE,IAAX,GAAkB;AACd,WAAOvB,gBAAgB,CAACuB,IAAxB;AACH;;AACD,MAAIA,IAAJ,GAAW;AACP,WAAOvB,gBAAgB,CAACuB,IAAxB;AACH,GAxB0C,CAyB3C;;;AACA,MAAII,GAAJ,GAAU;AACN,WAAO,KAAK0D,gBAAL,CAAsB1D,GAA7B;AACH;;AACD,MAAInC,KAAJ,GAAY;AACR,WAAO,KAAK6F,gBAAL,CAAsB7F,KAA7B;AACH;;AACD,MAAIoC,WAAJ,GAAkB;AACd,WAAO,KAAKyD,gBAAL,CAAsBzD,WAA7B;AACH;;AACD,MAAIC,UAAJ,GAAiB;AACb,WAAO,KAAKwD,gBAAL,CAAsBxD,UAA7B;AACH;AACD;;;;;;;;;;;;;;;;;;;AAiBA,QAAMc,GAAN,CAAUnD,KAAV,EAAiBoD,eAAjB,EAAkC;AAC9B,SAAK2C,eAAL;AACA,WAAO,KAAKF,gBAAL,CAAsB1C,GAAtB,CAA0BnD,KAA1B,EAAiCoD,eAAjC,CAAP;AACH;AACD;;;;;;;;;;;;;;;;;;;;;;;;;AAuBA,QAAMI,MAAN,CAAaC,OAAb,EAAsBL,eAAtB,EAAuC;AACnC,SAAK2C,eAAL;AACA,WAAO,KAAKF,gBAAL,CAAsBrC,MAAtB,CAA6BC,OAA7B,EAAsCL,eAAtC,CAAP;AACH;AACD;;;;;;;;;;;;;;;;;;;;;;;;;AAuBA,QAAMZ,MAAN,CAAaoB,GAAb,EAAkBR,eAAlB,EAAmC;AAC/B,SAAK2C,eAAL;AACA,WAAO,KAAKF,gBAAL,CAAsBrD,MAAtB,CAA6BoB,GAA7B,EAAkCR,eAAlC,CAAP;AACH;AACD;;;;;;;;;;;;;;;;AAcA,QAAMW,MAAN,CAAa7C,GAAb,EAAkB;AACd,SAAK6E,eAAL;AACA,WAAO,KAAKF,gBAAL,CAAsB9B,MAAtB,CAA6B7C,GAA7B,CAAP;AACH;AACD;;;;;;;;;;;;;;;AAaA,QAAMwE,cAAN,GAAuB;AACnB,SAAKK,eAAL;AACA,WAAO,KAAKF,gBAAL,CAAsBH,cAAtB,EAAP;AACH;AACD;;;;;;;;;;AAQAM,EAAAA,KAAK,GAAG;AACJ,UAAMA,KAAN;AACA,SAAKH,gBAAL,CAAsBI,MAAtB,CAA6B,KAAKC,YAAlC;AACH;;AA/J0C;;AAiK/CnG,OAAO,CAAC6F,YAAR,GAAuBA,YAAvB;AACA7F,OAAO,CAACiD,OAAR,GAAkB4C,YAAlB;AACA;;;;;;;AAMA;;;;;;;AAMA;;;;;;;;;;;;AAWA","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst syncerror_1 = require(\"./utils/syncerror\");\nconst sanitize_1 = require(\"./utils/sanitize\");\nconst logger_1 = require(\"./utils/logger\");\nconst entity_1 = require(\"./entity\");\nconst mergingqueue_1 = require(\"./mergingqueue\");\nconst closeable_1 = require(\"./closeable\");\nclass SyncDocumentImpl extends entity_1.SyncEntity {\n    /**\n     * @private\n     */\n    constructor(services, descriptor, removalHandler) {\n        super(services, removalHandler);\n        this.isDeleted = false;\n        const updateRequestReducer = (acc, input) => (typeof input.ttl === 'number') ? { ttl: input.ttl }\n            : acc;\n        this.updateMergingQueue = new mergingqueue_1.MergingQueue(updateRequestReducer);\n        this.descriptor = descriptor;\n        this.descriptor.data = this.descriptor.data || {};\n        this.descriptor.date_updated = new Date(this.descriptor.date_updated);\n    }\n    // private props\n    get uri() {\n        return this.descriptor.url;\n    }\n    get revision() {\n        return this.descriptor.revision;\n    }\n    get lastEventId() {\n        return this.descriptor.last_event_id;\n    }\n    get dateExpires() {\n        return this.descriptor.date_expires;\n    }\n    static get type() {\n        return 'document';\n    }\n    get type() {\n        return 'document';\n    }\n    // below properties are specific to Insights only\n    get indexName() {\n        return undefined;\n    }\n    get queryString() {\n        return undefined;\n    }\n    // public props, documented along with class description\n    get sid() {\n        return this.descriptor.sid;\n    }\n    get value() {\n        return this.descriptor.data;\n    }\n    get dateUpdated() {\n        return this.descriptor.date_updated;\n    }\n    get uniqueName() {\n        return this.descriptor.unique_name || null;\n    }\n    /**\n     * Update data entity with new data\n     * @private\n     */\n    _update(update) {\n        update.date_created = new Date(update.date_created);\n        switch (update.type) {\n            case 'document_updated':\n                if (update.id > this.lastEventId) {\n                    this.descriptor.last_event_id = update.id;\n                    this.descriptor.revision = update.document_revision;\n                    this.descriptor.date_updated = update.date_created;\n                    this.descriptor.data = update.document_data;\n                    this.broadcastEventToListeners('updated', { value: update.document_data, isLocal: false });\n                    this.services.storage.update(this.type, this.sid, this.uniqueName, {\n                        last_event_id: update.id,\n                        revision: update.document_revision,\n                        date_updated: update.date_created,\n                        data: update.document_data\n                    });\n                }\n                else {\n                    logger_1.default.trace('Document update skipped, current:', this.lastEventId, ', remote:', update.id);\n                }\n                break;\n            case 'document_removed':\n                this.onRemoved(false);\n                break;\n        }\n    }\n    async set(value, metadataUpdates) {\n        const input = metadataUpdates || {};\n        sanitize_1.validateOptionalTtl(input.ttl);\n        return this.updateMergingQueue.squashAndAdd(input, input => this._setUnconditionally(value, input.ttl));\n    }\n    async mutate(mutator, metadataUpdates) {\n        const input = metadataUpdates || {};\n        sanitize_1.validateOptionalTtl(input.ttl);\n        return this.updateMergingQueue.add(input, input => this._setWithIfMatch(mutator, input.ttl));\n    }\n    async update(obj, metadataUpdates) {\n        return this.mutate(remote => Object.assign(remote, obj), metadataUpdates);\n    }\n    async setTtl(ttl) {\n        sanitize_1.validateMandatoryTtl(ttl);\n        const response = await this._postUpdateToServer({ ttl });\n        this.descriptor.date_expires = response.date_expires;\n    }\n    /**\n     * @private\n     */\n    async _setUnconditionally(value, ttl) {\n        let result = await this._postUpdateToServer({ data: value, revision: undefined, ttl });\n        this._handleSuccessfulUpdateResult(result);\n        return this.value;\n    }\n    /**\n     * @private\n     */\n    async _setWithIfMatch(mutatorFunction, ttl) {\n        let data = mutatorFunction(sanitize_1.deepClone(this.value));\n        if (data) {\n            let revision = this.revision;\n            try {\n                let result = await this._postUpdateToServer({ data, revision, ttl });\n                this._handleSuccessfulUpdateResult(result);\n                return this.value;\n            }\n            catch (error) {\n                if (error.status === 412) {\n                    await this._softSync();\n                    return this._setWithIfMatch(mutatorFunction);\n                }\n                else {\n                    throw error;\n                }\n            }\n        }\n        else {\n            return this.value;\n        }\n    }\n    /**\n     * @private\n     */\n    _handleSuccessfulUpdateResult(result) {\n        if (result.last_event_id > this.descriptor.last_event_id) {\n            // Ignore returned value if we already got a newer one\n            this.descriptor.revision = result.revision;\n            this.descriptor.data = result.data;\n            this.descriptor.last_event_id = result.last_event_id;\n            this.descriptor.date_expires = result.date_expires;\n            this.descriptor.date_updated = new Date(result.date_updated);\n            this.services.storage.update(this.type, this.sid, this.uniqueName, {\n                last_event_id: result.last_event_id,\n                revision: result.revision,\n                date_updated: result.date_updated,\n                data: result.data\n            });\n            this.broadcastEventToListeners('updated', { value: this.value, isLocal: true });\n        }\n    }\n    /**\n     * @private\n     */\n    async _postUpdateToServer(request) {\n        if (!this.isDeleted) {\n            const requestBody = {\n                data: request.data\n            };\n            if (request.ttl !== undefined) {\n                requestBody.ttl = request.ttl;\n            }\n            const ifMatch = request.revision;\n            try {\n                const response = await this.services.network.post(this.uri, requestBody, ifMatch);\n                return {\n                    revision: response.body.revision,\n                    data: request.data,\n                    last_event_id: response.body.last_event_id,\n                    date_updated: response.body.date_updated,\n                    date_expires: response.body.date_expires\n                };\n            }\n            catch (error) {\n                if (error.status === 404) {\n                    this.onRemoved(false);\n                }\n                throw error;\n            }\n        }\n        else {\n            return Promise.reject(new syncerror_1.SyncError('The Document has been removed', 404, 54100));\n        }\n    }\n    /**\n     * Get new data from server\n     * @private\n     */\n    async _softSync() {\n        return this.services.network.get(this.uri)\n            .then(response => {\n            const event = {\n                type: 'document_updated',\n                id: response.body.last_event_id,\n                document_revision: response.body.revision,\n                document_data: response.body.data,\n                date_created: response.body.date_updated\n            };\n            this._update(event);\n            return this;\n        })\n            .catch(err => {\n            if (err.status === 404) {\n                this.onRemoved(false);\n            }\n            else {\n                logger_1.default.error(`Can't get updates for ${this.sid}:`, err);\n            }\n        });\n    }\n    onRemoved(locally) {\n        if (this.isDeleted) {\n            return;\n        }\n        else {\n            this.isDeleted = true;\n            this._unsubscribe();\n            this.removalHandler(this.type, this.sid, this.uniqueName);\n            this.broadcastEventToListeners('removed', { isLocal: locally });\n        }\n    }\n    async removeDocument() {\n        if (!this.isDeleted) {\n            await this.services.network.delete(this.uri);\n            this.onRemoved(true);\n        }\n        else {\n            return Promise.reject(new syncerror_1.SyncError('The Document has been removed', 404, 54100));\n        }\n    }\n}\nexports.SyncDocumentImpl = SyncDocumentImpl;\n/**\n * @class\n * @alias Document\n * @classdesc Represents a Sync Document, the contents of which is a single JSON object.\n * Use the {@link Client#document} method to obtain a reference to a Sync Document.\n * @property {String} sid The immutable identifier of this document, assigned by the system.\n * @property {String} [uniqueName=null] An optional immutable identifier that may be assigned by the programmer\n * to this document during creation. Globally unique among other Documents.\n * @property {Date} dateUpdated Date when the Document was last updated.\n * @property {Object} value The contents of this document.\n *\n * @fires Document#removed\n * @fires Document#updated\n */\nclass SyncDocument extends closeable_1.default {\n    constructor(syncDocumentImpl) {\n        super();\n        this.syncDocumentImpl = syncDocumentImpl;\n        this.syncDocumentImpl.attach(this);\n    }\n    // private props\n    get uri() {\n        return this.syncDocumentImpl.uri;\n    }\n    get revision() {\n        return this.syncDocumentImpl.revision;\n    }\n    get lastEventId() {\n        return this.syncDocumentImpl.lastEventId;\n    }\n    get dateExpires() {\n        return this.syncDocumentImpl.dateExpires;\n    }\n    static get type() {\n        return SyncDocumentImpl.type;\n    }\n    get type() {\n        return SyncDocumentImpl.type;\n    }\n    // public props, documented along with class description\n    get sid() {\n        return this.syncDocumentImpl.sid;\n    }\n    get value() {\n        return this.syncDocumentImpl.value;\n    }\n    get dateUpdated() {\n        return this.syncDocumentImpl.dateUpdated;\n    }\n    get uniqueName() {\n        return this.syncDocumentImpl.uniqueName;\n    }\n    /**\n     * Assign new contents to this document. The current value will be overwritten.\n     * @param {Object} value The new contents to assign.\n     * @param {Document#Metadata} [metadataUpdates] New document metadata.\n     * @returns {Promise<Object>} A promise resolving to the new value of the document.\n     * @public\n     * @example\n     * // Say, the Document value is { name: 'John Smith', age: 34 }\n     * document.set({ name: 'Barbara Oaks' }, { ttl: 86400 })\n     *   .then(function(newValue) {\n     *     // Now the Document value is { name: 'Barbara Oaks' }\n     *     console.log('Document set() successful, new value:', newValue);\n     *   })\n     *   .catch(function(error) {\n     *     console.error('Document set() failed', error);\n     *   });\n     */\n    async set(value, metadataUpdates) {\n        this.ensureNotClosed();\n        return this.syncDocumentImpl.set(value, metadataUpdates);\n    }\n    /**\n     * Schedules a modification to this document that will apply a mutation function.\n     * @param {Document~Mutator} mutator A function that outputs a new value based on the existing value.\n     * May be called multiple times, particularly if this Document is modified concurrently by remote code.\n     * If the mutation ultimately succeeds, the Document will have made the particular transition described\n     * by this function.\n     * @param {Document#Metadata} [metadataUpdates] New document metadata.\n     * @return {Promise<Object>} Resolves with the most recent Document state, whether the output of a\n     *    successful mutation or a state that prompted graceful cancellation (mutator returned <code>null</code>).\n     * @public\n     * @example\n     * var mutatorFunction = function(currentValue) {\n     *     currentValue.viewCount = (currentValue.viewCount || 0) + 1;\n     *     return currentValue;\n     * };\n     * document.mutate(mutatorFunction, { ttl: 86400 }))\n     *   .then(function(newValue) {\n     *     console.log('Document mutate() successful, new value:', newValue);\n     *   })\n     *   .catch(function(error) {\n     *     console.error('Document mutate() failed', error);\n     *   });\n     */\n    async mutate(mutator, metadataUpdates) {\n        this.ensureNotClosed();\n        return this.syncDocumentImpl.mutate(mutator, metadataUpdates);\n    }\n    /**\n     * Modify a document by appending new fields (or by overwriting existing ones) with the values from the provided Object.\n     * This is equivalent to\n     * <pre>\n     * document.mutate(function(currentValue) {\n     *   return Object.assign(currentValue, obj));\n     * });\n     * </pre>\n     * @param {Object} obj Specifies the particular (top-level) attributes that will receive new values.\n     * @param {Document#Metadata} [metadataUpdates] New document metadata.\n     * @return {Promise<Object>} A promise resolving to the new value of the document.\n     * @public\n     * @example\n     * // Say, the Document value is { name: 'John Smith' }\n     * document.update({ age: 34 }, { ttl: 86400 })\n     *   .then(function(newValue) {\n     *     // Now the Document value is { name: 'John Smith', age: 34 }\n     *     console.log('Document update() successful, new value:', newValue);\n     *   })\n     *   .catch(function(error) {\n     *     console.error('Document update() failed', error);\n     *   });\n     */\n    async update(obj, metadataUpdates) {\n        this.ensureNotClosed();\n        return this.syncDocumentImpl.update(obj, metadataUpdates);\n    }\n    /**\n     * Update the time-to-live of the document.\n     * @param {Number} ttl Specifies the time-to-live in seconds after which the document is subject to automatic deletion. The value 0 means infinity.\n     * @return {Promise<void>} A promise that resolves after the TTL update was successful.\n     * @public\n     * @example\n     * document.setTtl(3600)\n     *   .then(function() {\n     *     console.log('Document setTtl() successful');\n     *   })\n     *   .catch(function(error) {\n     *     console.error('Document setTtl() failed', error);\n     *   });\n     */\n    async setTtl(ttl) {\n        this.ensureNotClosed();\n        return this.syncDocumentImpl.setTtl(ttl);\n    }\n    /**\n     * Delete a document.\n     * @return {Promise<void>} A promise which resolves if (and only if) the document is ultimately deleted.\n     * @public\n     * @example\n     * document.removeDocument()\n     *   .then(function() {\n     *     console.log('Document removeDocument() successful');\n     *   })\n     *   .catch(function(error) {\n     *     console.error('Document removeDocument() failed', error);\n     *   });\n     */\n    async removeDocument() {\n        this.ensureNotClosed();\n        return this.syncDocumentImpl.removeDocument();\n    }\n    /**\n     * Conclude work with the document instance and remove all event listeners attached to it.\n     * Any subsequent operation on this object will be rejected with error.\n     * Other local copies of this document will continue operating and receiving events normally.\n     * @public\n     * @example\n     * document.close();\n     */\n    close() {\n        super.close();\n        this.syncDocumentImpl.detach(this.listenerUuid);\n    }\n}\nexports.SyncDocument = SyncDocument;\nexports.default = SyncDocument;\n/**\n * Contains Document metadata.\n * @typedef {Object} Document#Metadata\n * @property {Number} [ttl] Specifies the time-to-live in seconds after which the document is subject to automatic deletion.\n * The value 0 means infinity.\n */\n/**\n * Applies a transformation to the document value.\n * @callback Document~Mutator\n * @param {Object} currentValue The current value of the document in the cloud.\n * @return {Object} The desired new value for the document or <code>null</code> to gracefully cancel the mutation.\n */\n/**\n * Fired when the document is removed, whether the remover was local or remote.\n * @event Document#removed\n * @param {Object} args Arguments provided with the event.\n * @param {Boolean} args.isLocal Equals 'true' if document was removed by local actor, 'false' otherwise.\n * @example\n * document.on('removed', function(args) {\n *   console.log('Document ' + document.sid + ' was removed');\n *   console.log('args.isLocal:', args.isLocal);\n * });\n */\n/**\n * Fired when the document's contents have changed, whether the updater was local or remote.\n * @event Document#updated\n * @param {Object} args Arguments provided with the event.\n * @param {Object} args.value A snapshot of the document's new contents.\n * @param {Boolean} args.isLocal Equals 'true' if document was updated by local actor, 'false' otherwise.\n * @example\n * document.on('updated', function(args) {\n *   console.log('Document ' + document.sid + ' was updated');\n *   console.log('args.value: ', args.value);\n *   console.log('args.isLocal: ', args.isLocal);\n * });\n */\n"]},"metadata":{},"sourceType":"script"}