{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst events_1 = require(\"events\");\n/**\n * Provides retrier service\n */\n\n\nclass Retrier extends events_1.EventEmitter {\n  /**\n   * Creates a new Retrier instance\n   */\n  constructor(options) {\n    super();\n    this.minDelay = options.min;\n    this.maxDelay = options.max;\n    this.initialDelay = options.initial || 0;\n    this.maxAttemptsCount = options.maxAttemptsCount || 0;\n    this.maxAttemptsTime = options.maxAttemptsTime || 0;\n    this.randomness = options.randomness || 0;\n    this.inProgress = false;\n    this.attemptNum = 0;\n    this.prevDelay = 0;\n    this.currDelay = 0;\n  }\n\n  attempt() {\n    clearTimeout(this.timeout);\n    this.attemptNum++;\n    this.timeout = null;\n    this.emit('attempt', this);\n  }\n\n  nextDelay(delayOverride) {\n    if (typeof delayOverride === 'number') {\n      this.prevDelay = 0;\n      this.currDelay = delayOverride;\n      return delayOverride;\n    }\n\n    if (this.attemptNum == 0) {\n      return this.initialDelay;\n    }\n\n    if (this.attemptNum == 1) {\n      this.currDelay = this.minDelay;\n      return this.currDelay;\n    }\n\n    this.prevDelay = this.currDelay;\n    let delay = this.currDelay + this.prevDelay;\n\n    if (this.maxDelay && delay > this.maxDelay) {\n      this.currDelay = this.maxDelay;\n      delay = this.maxDelay;\n    }\n\n    this.currDelay = delay;\n    return delay;\n  }\n\n  randomize(delay) {\n    let area = delay * this.randomness;\n    let corr = Math.round(Math.random() * area * 2 - area);\n    return Math.max(0, delay + corr);\n  }\n\n  scheduleAttempt(delayOverride) {\n    if (this.maxAttemptsCount && this.attemptNum >= this.maxAttemptsCount) {\n      this.cleanup();\n      this.emit('failed', new Error('Maximum attempt count limit reached'));\n      this.reject(new Error('Maximum attempt count reached'));\n      return;\n    }\n\n    let delay = this.nextDelay(delayOverride);\n    delay = this.randomize(delay);\n\n    if (this.maxAttemptsTime && this.startTimestamp + this.maxAttemptsTime < Date.now() + delay) {\n      this.cleanup();\n      this.emit('failed', new Error('Maximum attempt time limit reached'));\n      this.reject(new Error('Maximum attempt time limit reached'));\n      return;\n    }\n\n    this.timeout = setTimeout(() => this.attempt(), delay);\n  }\n\n  cleanup() {\n    clearTimeout(this.timeout);\n    this.timeout = null;\n    this.inProgress = false;\n    this.attemptNum = 0;\n    this.prevDelay = 0;\n    this.currDelay = 0;\n  }\n\n  start() {\n    if (this.inProgress) {\n      throw new Error('Retrier is already in progress');\n    }\n\n    this.inProgress = true;\n    return new Promise((resolve, reject) => {\n      this.resolve = resolve;\n      this.reject = reject;\n      this.startTimestamp = Date.now();\n      this.scheduleAttempt(this.initialDelay);\n    });\n  }\n\n  cancel() {\n    if (this.timeout) {\n      clearTimeout(this.timeout);\n      this.timeout = null;\n      this.inProgress = false;\n      this.emit('cancelled');\n      this.reject(new Error('Cancelled'));\n    }\n  }\n\n  succeeded(arg) {\n    this.emit('succeeded', arg);\n    this.resolve(arg);\n  }\n\n  failed(err, nextAttemptDelayOverride) {\n    if (this.timeout) {\n      throw new Error('Retrier attempt is already in progress');\n    }\n\n    this.scheduleAttempt(nextAttemptDelayOverride);\n  }\n\n  run(handler) {\n    this.on('attempt', () => {\n      handler().then(v => this.succeeded(v)).catch(e => this.failed(e));\n    });\n    return this.start();\n  }\n\n}\n\nexports.Retrier = Retrier;\nexports.default = Retrier;","map":{"version":3,"sources":["../src/retrier.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst events_1 = require(\"events\");\n/**\n * Provides retrier service\n */\nclass Retrier extends events_1.EventEmitter {\n    /**\n     * Creates a new Retrier instance\n     */\n    constructor(options) {\n        super();\n        this.minDelay = options.min;\n        this.maxDelay = options.max;\n        this.initialDelay = options.initial || 0;\n        this.maxAttemptsCount = options.maxAttemptsCount || 0;\n        this.maxAttemptsTime = options.maxAttemptsTime || 0;\n        this.randomness = options.randomness || 0;\n        this.inProgress = false;\n        this.attemptNum = 0;\n        this.prevDelay = 0;\n        this.currDelay = 0;\n    }\n    attempt() {\n        clearTimeout(this.timeout);\n        this.attemptNum++;\n        this.timeout = null;\n        this.emit('attempt', this);\n    }\n    nextDelay(delayOverride) {\n        if (typeof delayOverride === 'number') {\n            this.prevDelay = 0;\n            this.currDelay = delayOverride;\n            return delayOverride;\n        }\n        if (this.attemptNum == 0) {\n            return this.initialDelay;\n        }\n        if (this.attemptNum == 1) {\n            this.currDelay = this.minDelay;\n            return this.currDelay;\n        }\n        this.prevDelay = this.currDelay;\n        let delay = this.currDelay + this.prevDelay;\n        if (this.maxDelay && delay > this.maxDelay) {\n            this.currDelay = this.maxDelay;\n            delay = this.maxDelay;\n        }\n        this.currDelay = delay;\n        return delay;\n    }\n    randomize(delay) {\n        let area = delay * this.randomness;\n        let corr = Math.round(Math.random() * area * 2 - area);\n        return Math.max(0, delay + corr);\n    }\n    scheduleAttempt(delayOverride) {\n        if (this.maxAttemptsCount && this.attemptNum >= this.maxAttemptsCount) {\n            this.cleanup();\n            this.emit('failed', new Error('Maximum attempt count limit reached'));\n            this.reject(new Error('Maximum attempt count reached'));\n            return;\n        }\n        let delay = this.nextDelay(delayOverride);\n        delay = this.randomize(delay);\n        if (this.maxAttemptsTime && (this.startTimestamp + this.maxAttemptsTime < Date.now() + delay)) {\n            this.cleanup();\n            this.emit('failed', new Error('Maximum attempt time limit reached'));\n            this.reject(new Error('Maximum attempt time limit reached'));\n            return;\n        }\n        this.timeout = setTimeout(() => this.attempt(), delay);\n    }\n    cleanup() {\n        clearTimeout(this.timeout);\n        this.timeout = null;\n        this.inProgress = false;\n        this.attemptNum = 0;\n        this.prevDelay = 0;\n        this.currDelay = 0;\n    }\n    start() {\n        if (this.inProgress) {\n            throw new Error('Retrier is already in progress');\n        }\n        this.inProgress = true;\n        return new Promise((resolve, reject) => {\n            this.resolve = resolve;\n            this.reject = reject;\n            this.startTimestamp = Date.now();\n            this.scheduleAttempt(this.initialDelay);\n        });\n    }\n    cancel() {\n        if (this.timeout) {\n            clearTimeout(this.timeout);\n            this.timeout = null;\n            this.inProgress = false;\n            this.emit('cancelled');\n            this.reject(new Error('Cancelled'));\n        }\n    }\n    succeeded(arg) {\n        this.emit('succeeded', arg);\n        this.resolve(arg);\n    }\n    failed(err, nextAttemptDelayOverride) {\n        if (this.timeout) {\n            throw new Error('Retrier attempt is already in progress');\n        }\n        this.scheduleAttempt(nextAttemptDelayOverride);\n    }\n    run(handler) {\n        this.on('attempt', () => {\n            handler().then(v => this.succeeded(v)).catch(e => this.failed(e));\n        });\n        return this.start();\n    }\n}\nexports.Retrier = Retrier;\nexports.default = Retrier;\n//# sourceMappingURL=retrier.js.map"]},"metadata":{},"sourceType":"script"}