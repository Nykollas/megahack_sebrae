{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n/**\nRecursively copy a value.\n\n@param source - should be a JavaScript primitive, Array, or (plain old) Object.\n@returns copy of source where every Array and Object have been recursively\n         reconstructed from their constituent elements\n*/\n\nfunction clone(source) {\n  // loose-equality checking for null is faster than strict checking for each of null/undefined/true/false\n  // checking null first, then calling typeof, is faster than vice-versa\n  if (source == null || typeof source != 'object') {\n    // short-circuiting is faster than a single return\n    return source;\n  } // x.constructor == Array is the fastest way to check if x is an Array\n\n\n  if (source.constructor == Array) {\n    // construction via imperative for-loop is faster than source.map(arrayVsObject)\n    var length_1 = source.length; // setting the Array length during construction is faster than just `[]` or `new Array()`\n\n    var arrayTarget = new Array(length_1);\n\n    for (var i = 0; i < length_1; i++) {\n      arrayTarget[i] = clone(source[i]);\n    }\n\n    return arrayTarget;\n  } // Object\n\n\n  var objectTarget = {}; // declaring the variable (with const) inside the loop is faster\n\n  for (var key in source) {\n    // hasOwnProperty costs a bit of performance, but it's semantically necessary\n    // using a global helper is MUCH faster than calling source.hasOwnProperty(key)\n    if (hasOwnProperty.call(source, key)) {\n      objectTarget[key] = clone(source[key]);\n    }\n  }\n\n  return objectTarget;\n}\n\nexports.clone = clone;","map":{"version":3,"sources":["/home/ascencion/sebrae_megahack/node_modules/rfc6902/util.js"],"names":["Object","defineProperty","exports","value","hasOwnProperty","prototype","clone","source","constructor","Array","length_1","length","arrayTarget","i","objectTarget","key","call"],"mappings":"AAAA;;AACAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;AACA,IAAIC,cAAc,GAAGJ,MAAM,CAACK,SAAP,CAAiBD,cAAtC;AACA;;;;;;;;AAOA,SAASE,KAAT,CAAeC,MAAf,EAAuB;AACnB;AACA;AACA,MAAIA,MAAM,IAAI,IAAV,IAAkB,OAAOA,MAAP,IAAiB,QAAvC,EAAiD;AAC7C;AACA,WAAOA,MAAP;AACH,GANkB,CAOnB;;;AACA,MAAIA,MAAM,CAACC,WAAP,IAAsBC,KAA1B,EAAiC;AAC7B;AACA,QAAIC,QAAQ,GAAGH,MAAM,CAACI,MAAtB,CAF6B,CAG7B;;AACA,QAAIC,WAAW,GAAG,IAAIH,KAAJ,CAAUC,QAAV,CAAlB;;AACA,SAAK,IAAIG,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGH,QAApB,EAA8BG,CAAC,EAA/B,EAAmC;AAC/BD,MAAAA,WAAW,CAACC,CAAD,CAAX,GAAiBP,KAAK,CAACC,MAAM,CAACM,CAAD,CAAP,CAAtB;AACH;;AACD,WAAOD,WAAP;AACH,GAjBkB,CAkBnB;;;AACA,MAAIE,YAAY,GAAG,EAAnB,CAnBmB,CAoBnB;;AACA,OAAK,IAAIC,GAAT,IAAgBR,MAAhB,EAAwB;AACpB;AACA;AACA,QAAIH,cAAc,CAACY,IAAf,CAAoBT,MAApB,EAA4BQ,GAA5B,CAAJ,EAAsC;AAClCD,MAAAA,YAAY,CAACC,GAAD,CAAZ,GAAoBT,KAAK,CAACC,MAAM,CAACQ,GAAD,CAAP,CAAzB;AACH;AACJ;;AACD,SAAOD,YAAP;AACH;;AACDZ,OAAO,CAACI,KAAR,GAAgBA,KAAhB","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n/**\nRecursively copy a value.\n\n@param source - should be a JavaScript primitive, Array, or (plain old) Object.\n@returns copy of source where every Array and Object have been recursively\n         reconstructed from their constituent elements\n*/\nfunction clone(source) {\n    // loose-equality checking for null is faster than strict checking for each of null/undefined/true/false\n    // checking null first, then calling typeof, is faster than vice-versa\n    if (source == null || typeof source != 'object') {\n        // short-circuiting is faster than a single return\n        return source;\n    }\n    // x.constructor == Array is the fastest way to check if x is an Array\n    if (source.constructor == Array) {\n        // construction via imperative for-loop is faster than source.map(arrayVsObject)\n        var length_1 = source.length;\n        // setting the Array length during construction is faster than just `[]` or `new Array()`\n        var arrayTarget = new Array(length_1);\n        for (var i = 0; i < length_1; i++) {\n            arrayTarget[i] = clone(source[i]);\n        }\n        return arrayTarget;\n    }\n    // Object\n    var objectTarget = {};\n    // declaring the variable (with const) inside the loop is faster\n    for (var key in source) {\n        // hasOwnProperty costs a bit of performance, but it's semantically necessary\n        // using a global helper is MUCH faster than calling source.hasOwnProperty(key)\n        if (hasOwnProperty.call(source, key)) {\n            objectTarget[key] = clone(source[key]);\n        }\n    }\n    return objectTarget;\n}\nexports.clone = clone;\n"]},"metadata":{},"sourceType":"script"}