{"ast":null,"code":"import { useState, useCallback, useRef } from 'react';\nimport useVideoContext from '../useVideoContext/useVideoContext';\nexport default function useScreenShareToggle() {\n  const {\n    room,\n    onError\n  } = useVideoContext();\n  const [isSharing, setIsSharing] = useState(false);\n  const stopScreenShareRef = useRef(null);\n  const shareScreen = useCallback(() => {\n    navigator.mediaDevices.getDisplayMedia({\n      audio: false,\n      video: {\n        frameRate: 10,\n        height: 1080,\n        width: 1920\n      }\n    }).then(stream => {\n      const track = stream.getTracks()[0]; // All video tracks are published with 'low' priority. This works because the video\n      // track that is displayed in the 'MainParticipant' component will have it's priority\n      // set to 'high' via track.setPriority()\n\n      room.localParticipant.publishTrack(track, {\n        name: 'screen',\n        // Tracks can be named to easily find them later\n        priority: 'low' // Priority is set to high by the subscriber when the video track is rendered\n\n      }).then(trackPublication => {\n        stopScreenShareRef.current = () => {\n          room.localParticipant.unpublishTrack(track); // TODO: remove this if the SDK is updated to emit this event\n\n          room.localParticipant.emit('trackUnpublished', trackPublication);\n          track.stop();\n          setIsSharing(false);\n        };\n\n        track.onended = stopScreenShareRef.current;\n        setIsSharing(true);\n      }).catch(onError);\n    }).catch(error => {\n      // Don't display an error if the user closes the screen share dialog\n      if (error.name !== 'AbortError' && error.name !== 'NotAllowedError') {\n        onError(error);\n      }\n    });\n  }, [room, onError]);\n  const toggleScreenShare = useCallback(() => {\n    !isSharing ? shareScreen() : stopScreenShareRef.current();\n  }, [isSharing, shareScreen, stopScreenShareRef]);\n  return [isSharing, toggleScreenShare];\n}","map":{"version":3,"sources":["/home/ascencion/sebrae_megahack/src/hooks/useScreenShareToggle/useScreenShareToggle.tsx"],"names":["useState","useCallback","useRef","useVideoContext","useScreenShareToggle","room","onError","isSharing","setIsSharing","stopScreenShareRef","shareScreen","navigator","mediaDevices","getDisplayMedia","audio","video","frameRate","height","width","then","stream","track","getTracks","localParticipant","publishTrack","name","priority","trackPublication","current","unpublishTrack","emit","stop","onended","catch","error","toggleScreenShare"],"mappings":"AAAA,SAASA,QAAT,EAAmBC,WAAnB,EAAgCC,MAAhC,QAA8C,OAA9C;AACA,OAAOC,eAAP,MAA4B,oCAA5B;AASA,eAAe,SAASC,oBAAT,GAAgC;AAC7C,QAAM;AAAEC,IAAAA,IAAF;AAAQC,IAAAA;AAAR,MAAoBH,eAAe,EAAzC;AACA,QAAM,CAACI,SAAD,EAAYC,YAAZ,IAA4BR,QAAQ,CAAC,KAAD,CAA1C;AACA,QAAMS,kBAAkB,GAAGP,MAAM,CAAa,IAAb,CAAjC;AAEA,QAAMQ,WAAW,GAAGT,WAAW,CAAC,MAAM;AACpCU,IAAAA,SAAS,CAACC,YAAV,CACGC,eADH,CACmB;AACfC,MAAAA,KAAK,EAAE,KADQ;AAEfC,MAAAA,KAAK,EAAE;AACLC,QAAAA,SAAS,EAAE,EADN;AAELC,QAAAA,MAAM,EAAE,IAFH;AAGLC,QAAAA,KAAK,EAAE;AAHF;AAFQ,KADnB,EASGC,IATH,CASQC,MAAM,IAAI;AACd,YAAMC,KAAK,GAAGD,MAAM,CAACE,SAAP,GAAmB,CAAnB,CAAd,CADc,CAGd;AACA;AACA;;AACAjB,MAAAA,IAAI,CAACkB,gBAAL,CACGC,YADH,CACgBH,KADhB,EACuB;AACnBI,QAAAA,IAAI,EAAE,QADa;AACH;AAChBC,QAAAA,QAAQ,EAAE,KAFS,CAEF;;AAFE,OADvB,EAKGP,IALH,CAKQQ,gBAAgB,IAAI;AACxBlB,QAAAA,kBAAkB,CAACmB,OAAnB,GAA6B,MAAM;AACjCvB,UAAAA,IAAI,CAACkB,gBAAL,CAAsBM,cAAtB,CAAqCR,KAArC,EADiC,CAEjC;;AACAhB,UAAAA,IAAI,CAACkB,gBAAL,CAAsBO,IAAtB,CAA2B,kBAA3B,EAA+CH,gBAA/C;AACAN,UAAAA,KAAK,CAACU,IAAN;AACAvB,UAAAA,YAAY,CAAC,KAAD,CAAZ;AACD,SAND;;AAQAa,QAAAA,KAAK,CAACW,OAAN,GAAgBvB,kBAAkB,CAACmB,OAAnC;AACApB,QAAAA,YAAY,CAAC,IAAD,CAAZ;AACD,OAhBH,EAiBGyB,KAjBH,CAiBS3B,OAjBT;AAkBD,KAjCH,EAkCG2B,KAlCH,CAkCSC,KAAK,IAAI;AACd;AACA,UAAIA,KAAK,CAACT,IAAN,KAAe,YAAf,IAA+BS,KAAK,CAACT,IAAN,KAAe,iBAAlD,EAAqE;AACnEnB,QAAAA,OAAO,CAAC4B,KAAD,CAAP;AACD;AACF,KAvCH;AAwCD,GAzC8B,EAyC5B,CAAC7B,IAAD,EAAOC,OAAP,CAzC4B,CAA/B;AA2CA,QAAM6B,iBAAiB,GAAGlC,WAAW,CAAC,MAAM;AAC1C,KAACM,SAAD,GAAaG,WAAW,EAAxB,GAA6BD,kBAAkB,CAACmB,OAAnB,EAA7B;AACD,GAFoC,EAElC,CAACrB,SAAD,EAAYG,WAAZ,EAAyBD,kBAAzB,CAFkC,CAArC;AAIA,SAAO,CAACF,SAAD,EAAY4B,iBAAZ,CAAP;AACD","sourcesContent":["import { useState, useCallback, useRef } from 'react';\nimport useVideoContext from '../useVideoContext/useVideoContext';\nimport { LogLevels, Track } from 'twilio-video';\n\ninterface MediaStreamTrackPublishOptions {\n  name?: string;\n  priority: Track.Priority;\n  logLevel: LogLevels;\n}\n\nexport default function useScreenShareToggle() {\n  const { room, onError } = useVideoContext();\n  const [isSharing, setIsSharing] = useState(false);\n  const stopScreenShareRef = useRef<() => void>(null!);\n\n  const shareScreen = useCallback(() => {\n    navigator.mediaDevices\n      .getDisplayMedia({\n        audio: false,\n        video: {\n          frameRate: 10,\n          height: 1080,\n          width: 1920,\n        },\n      })\n      .then(stream => {\n        const track = stream.getTracks()[0];\n\n        // All video tracks are published with 'low' priority. This works because the video\n        // track that is displayed in the 'MainParticipant' component will have it's priority\n        // set to 'high' via track.setPriority()\n        room.localParticipant\n          .publishTrack(track, {\n            name: 'screen', // Tracks can be named to easily find them later\n            priority: 'low', // Priority is set to high by the subscriber when the video track is rendered\n          } as MediaStreamTrackPublishOptions)\n          .then(trackPublication => {\n            stopScreenShareRef.current = () => {\n              room.localParticipant.unpublishTrack(track);\n              // TODO: remove this if the SDK is updated to emit this event\n              room.localParticipant.emit('trackUnpublished', trackPublication);\n              track.stop();\n              setIsSharing(false);\n            };\n\n            track.onended = stopScreenShareRef.current;\n            setIsSharing(true);\n          })\n          .catch(onError);\n      })\n      .catch(error => {\n        // Don't display an error if the user closes the screen share dialog\n        if (error.name !== 'AbortError' && error.name !== 'NotAllowedError') {\n          onError(error);\n        }\n      });\n  }, [room, onError]);\n\n  const toggleScreenShare = useCallback(() => {\n    !isSharing ? shareScreen() : stopScreenShareRef.current();\n  }, [isSharing, shareScreen, stopScreenShareRef]);\n\n  return [isSharing, toggleScreenShare] as const;\n}\n"]},"metadata":{},"sourceType":"module"}