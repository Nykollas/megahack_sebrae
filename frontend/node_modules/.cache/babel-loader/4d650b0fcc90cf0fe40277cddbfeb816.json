{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nclass MergingQueue {\n  constructor(inputMergingFunction) {\n    this.queuedRequests = [];\n    this.isRequestInFlight = false;\n    this.inputMergingFunction = inputMergingFunction;\n  }\n\n  add(input, requestFunction) {\n    let promise = new Promise((resolve, reject) => this.queuedRequests.push({\n      input,\n      requestFunction,\n      resolve,\n      reject\n    }));\n    this.wakeupQueue();\n    return promise;\n  }\n\n  squashAndAdd(input, requestFunction) {\n    let queueToSquash = this.queuedRequests;\n    this.queuedRequests = [];\n    let reducedInput;\n\n    if (queueToSquash.length > 0) {\n      reducedInput = queueToSquash.map(r => r.input).reduce(this.inputMergingFunction);\n      reducedInput = this.inputMergingFunction(reducedInput, input);\n    } else {\n      reducedInput = input;\n    }\n\n    let promise = this.add(reducedInput, requestFunction);\n    queueToSquash.forEach(request => promise.then(request.resolve, request.reject));\n    return promise;\n  }\n\n  isEmpty() {\n    return this.queuedRequests.length === 0 && !this.isRequestInFlight;\n  }\n\n  wakeupQueue() {\n    if (this.queuedRequests.length === 0 || this.isRequestInFlight) {\n      return;\n    } else {\n      let requestToExecute = this.queuedRequests.shift();\n      this.isRequestInFlight = true;\n      requestToExecute.requestFunction(requestToExecute.input).then(requestToExecute.resolve, requestToExecute.reject).then(__ => {\n        this.isRequestInFlight = false;\n        this.wakeupQueue();\n      });\n    }\n  }\n\n}\n\nexports.MergingQueue = MergingQueue;\n\nclass NamespacedMergingQueue {\n  constructor(inputReducer) {\n    this.queueByNamespaceKey = new Map();\n    this.inputReducer = inputReducer;\n  }\n\n  async add(namespaceKey, input, requestFunction) {\n    return this.invokeQueueMethod(namespaceKey, queue => queue.add(input, requestFunction));\n  }\n\n  async squashAndAdd(namespaceKey, input, requestFunction) {\n    return this.invokeQueueMethod(namespaceKey, queue => queue.squashAndAdd(input, requestFunction));\n  }\n\n  async invokeQueueMethod(namespaceKey, queueMethodInvoker) {\n    if (!this.queueByNamespaceKey.has(namespaceKey)) {\n      this.queueByNamespaceKey.set(namespaceKey, new MergingQueue(this.inputReducer));\n    }\n\n    const queue = this.queueByNamespaceKey.get(namespaceKey);\n    const result = queueMethodInvoker(queue);\n\n    if (this.queueByNamespaceKey.get(namespaceKey).isEmpty()) {\n      this.queueByNamespaceKey.delete(namespaceKey);\n    }\n\n    return result;\n  }\n\n}\n\nexports.NamespacedMergingQueue = NamespacedMergingQueue;","map":{"version":3,"sources":["/home/ascencion/sebrae_megahack/node_modules/twilio-sync/lib/mergingqueue.js"],"names":["Object","defineProperty","exports","value","MergingQueue","constructor","inputMergingFunction","queuedRequests","isRequestInFlight","add","input","requestFunction","promise","Promise","resolve","reject","push","wakeupQueue","squashAndAdd","queueToSquash","reducedInput","length","map","r","reduce","forEach","request","then","isEmpty","requestToExecute","shift","__","NamespacedMergingQueue","inputReducer","queueByNamespaceKey","Map","namespaceKey","invokeQueueMethod","queue","queueMethodInvoker","has","set","get","result","delete"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass MergingQueue {\n    constructor(inputMergingFunction) {\n        this.queuedRequests = [];\n        this.isRequestInFlight = false;\n        this.inputMergingFunction = inputMergingFunction;\n    }\n    add(input, requestFunction) {\n        let promise = new Promise((resolve, reject) => this.queuedRequests.push({ input, requestFunction, resolve, reject }));\n        this.wakeupQueue();\n        return promise;\n    }\n    squashAndAdd(input, requestFunction) {\n        let queueToSquash = this.queuedRequests;\n        this.queuedRequests = [];\n        let reducedInput;\n        if (queueToSquash.length > 0) {\n            reducedInput = queueToSquash.map(r => r.input).reduce(this.inputMergingFunction);\n            reducedInput = this.inputMergingFunction(reducedInput, input);\n        }\n        else {\n            reducedInput = input;\n        }\n        let promise = this.add(reducedInput, requestFunction);\n        queueToSquash.forEach(request => promise.then(request.resolve, request.reject));\n        return promise;\n    }\n    isEmpty() {\n        return this.queuedRequests.length === 0 && !this.isRequestInFlight;\n    }\n    wakeupQueue() {\n        if (this.queuedRequests.length === 0 || this.isRequestInFlight) {\n            return;\n        }\n        else {\n            let requestToExecute = this.queuedRequests.shift();\n            this.isRequestInFlight = true;\n            requestToExecute.requestFunction(requestToExecute.input)\n                .then(requestToExecute.resolve, requestToExecute.reject)\n                .then(__ => {\n                this.isRequestInFlight = false;\n                this.wakeupQueue();\n            });\n        }\n    }\n}\nexports.MergingQueue = MergingQueue;\nclass NamespacedMergingQueue {\n    constructor(inputReducer) {\n        this.queueByNamespaceKey = new Map();\n        this.inputReducer = inputReducer;\n    }\n    async add(namespaceKey, input, requestFunction) {\n        return this.invokeQueueMethod(namespaceKey, queue => queue.add(input, requestFunction));\n    }\n    async squashAndAdd(namespaceKey, input, requestFunction) {\n        return this.invokeQueueMethod(namespaceKey, queue => queue.squashAndAdd(input, requestFunction));\n    }\n    async invokeQueueMethod(namespaceKey, queueMethodInvoker) {\n        if (!this.queueByNamespaceKey.has(namespaceKey)) {\n            this.queueByNamespaceKey.set(namespaceKey, new MergingQueue(this.inputReducer));\n        }\n        const queue = this.queueByNamespaceKey.get(namespaceKey);\n        const result = queueMethodInvoker(queue);\n        if (this.queueByNamespaceKey.get(namespaceKey).isEmpty()) {\n            this.queueByNamespaceKey.delete(namespaceKey);\n        }\n        return result;\n    }\n}\nexports.NamespacedMergingQueue = NamespacedMergingQueue;\n"]},"metadata":{},"sourceType":"script"}