{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar pointer_1 = require(\"./pointer\");\n\nvar util_1 = require(\"./util\");\n\nvar equal_1 = require(\"./equal\");\n\nvar MissingError =\n/** @class */\nfunction (_super) {\n  __extends(MissingError, _super);\n\n  function MissingError(path) {\n    var _this = _super.call(this, \"Value required at path: \" + path) || this;\n\n    _this.path = path;\n    _this.name = 'MissingError';\n    return _this;\n  }\n\n  return MissingError;\n}(Error);\n\nexports.MissingError = MissingError;\n\nvar TestError =\n/** @class */\nfunction (_super) {\n  __extends(TestError, _super);\n\n  function TestError(actual, expected) {\n    var _this = _super.call(this, \"Test failed: \" + actual + \" != \" + expected) || this;\n\n    _this.actual = actual;\n    _this.expected = expected;\n    _this.name = 'TestError';\n    _this.actual = actual;\n    _this.expected = expected;\n    return _this;\n  }\n\n  return TestError;\n}(Error);\n\nexports.TestError = TestError;\n\nfunction _add(object, key, value) {\n  if (Array.isArray(object)) {\n    // `key` must be an index\n    if (key == '-') {\n      object.push(value);\n    } else {\n      var index = parseInt(key, 10);\n      object.splice(index, 0, value);\n    }\n  } else {\n    object[key] = value;\n  }\n}\n\nfunction _remove(object, key) {\n  if (Array.isArray(object)) {\n    // '-' syntax doesn't make sense when removing\n    var index = parseInt(key, 10);\n    object.splice(index, 1);\n  } else {\n    // not sure what the proper behavior is when path = ''\n    delete object[key];\n  }\n}\n/**\n>  o  If the target location specifies an array index, a new value is\n>     inserted into the array at the specified index.\n>  o  If the target location specifies an object member that does not\n>     already exist, a new member is added to the object.\n>  o  If the target location specifies an object member that does exist,\n>     that member's value is replaced.\n*/\n\n\nfunction add(object, operation) {\n  var endpoint = pointer_1.Pointer.fromJSON(operation.path).evaluate(object); // it's not exactly a \"MissingError\" in the same way that `remove` is -- more like a MissingParent, or something\n\n  if (endpoint.parent === undefined) {\n    return new MissingError(operation.path);\n  }\n\n  _add(endpoint.parent, endpoint.key, util_1.clone(operation.value));\n\n  return null;\n}\n\nexports.add = add;\n/**\n> The \"remove\" operation removes the value at the target location.\n> The target location MUST exist for the operation to be successful.\n*/\n\nfunction remove(object, operation) {\n  // endpoint has parent, key, and value properties\n  var endpoint = pointer_1.Pointer.fromJSON(operation.path).evaluate(object);\n\n  if (endpoint.value === undefined) {\n    return new MissingError(operation.path);\n  } // not sure what the proper behavior is when path = ''\n\n\n  _remove(endpoint.parent, endpoint.key);\n\n  return null;\n}\n\nexports.remove = remove;\n/**\n> The \"replace\" operation replaces the value at the target location\n> with a new value.  The operation object MUST contain a \"value\" member\n> whose content specifies the replacement value.\n> The target location MUST exist for the operation to be successful.\n\n> This operation is functionally identical to a \"remove\" operation for\n> a value, followed immediately by an \"add\" operation at the same\n> location with the replacement value.\n\nEven more simply, it's like the add operation with an existence check.\n*/\n\nfunction replace(object, operation) {\n  var endpoint = pointer_1.Pointer.fromJSON(operation.path).evaluate(object);\n\n  if (endpoint.parent === null) {\n    return new MissingError(operation.path);\n  } // this existence check treats arrays as a special case\n\n\n  if (Array.isArray(endpoint.parent)) {\n    if (parseInt(endpoint.key, 10) >= endpoint.parent.length) {\n      return new MissingError(operation.path);\n    }\n  } else if (endpoint.value === undefined) {\n    return new MissingError(operation.path);\n  }\n\n  endpoint.parent[endpoint.key] = operation.value;\n  return null;\n}\n\nexports.replace = replace;\n/**\n> The \"move\" operation removes the value at a specified location and\n> adds it to the target location.\n> The operation object MUST contain a \"from\" member, which is a string\n> containing a JSON Pointer value that references the location in the\n> target document to move the value from.\n> This operation is functionally identical to a \"remove\" operation on\n> the \"from\" location, followed immediately by an \"add\" operation at\n> the target location with the value that was just removed.\n\n> The \"from\" location MUST NOT be a proper prefix of the \"path\"\n> location; i.e., a location cannot be moved into one of its children.\n\nTODO: throw if the check described in the previous paragraph fails.\n*/\n\nfunction move(object, operation) {\n  var from_endpoint = pointer_1.Pointer.fromJSON(operation.from).evaluate(object);\n\n  if (from_endpoint.value === undefined) {\n    return new MissingError(operation.from);\n  }\n\n  var endpoint = pointer_1.Pointer.fromJSON(operation.path).evaluate(object);\n\n  if (endpoint.parent === undefined) {\n    return new MissingError(operation.path);\n  }\n\n  _remove(from_endpoint.parent, from_endpoint.key);\n\n  _add(endpoint.parent, endpoint.key, from_endpoint.value);\n\n  return null;\n}\n\nexports.move = move;\n/**\n> The \"copy\" operation copies the value at a specified location to the\n> target location.\n> The operation object MUST contain a \"from\" member, which is a string\n> containing a JSON Pointer value that references the location in the\n> target document to copy the value from.\n> The \"from\" location MUST exist for the operation to be successful.\n\n> This operation is functionally identical to an \"add\" operation at the\n> target location using the value specified in the \"from\" member.\n\nAlternatively, it's like 'move' without the 'remove'.\n*/\n\nfunction copy(object, operation) {\n  var from_endpoint = pointer_1.Pointer.fromJSON(operation.from).evaluate(object);\n\n  if (from_endpoint.value === undefined) {\n    return new MissingError(operation.from);\n  }\n\n  var endpoint = pointer_1.Pointer.fromJSON(operation.path).evaluate(object);\n\n  if (endpoint.parent === undefined) {\n    return new MissingError(operation.path);\n  }\n\n  _add(endpoint.parent, endpoint.key, util_1.clone(from_endpoint.value));\n\n  return null;\n}\n\nexports.copy = copy;\n/**\n> The \"test\" operation tests that a value at the target location is\n> equal to a specified value.\n> The operation object MUST contain a \"value\" member that conveys the\n> value to be compared to the target location's value.\n> The target location MUST be equal to the \"value\" value for the\n> operation to be considered successful.\n*/\n\nfunction test(object, operation) {\n  var endpoint = pointer_1.Pointer.fromJSON(operation.path).evaluate(object);\n  var result = equal_1.compare(endpoint.value, operation.value);\n\n  if (!result) {\n    return new TestError(endpoint.value, operation.value);\n  }\n\n  return null;\n}\n\nexports.test = test;\n\nvar InvalidOperationError =\n/** @class */\nfunction (_super) {\n  __extends(InvalidOperationError, _super);\n\n  function InvalidOperationError(operation) {\n    var _this = _super.call(this, \"Invalid operation: \" + operation.op) || this;\n\n    _this.operation = operation;\n    _this.name = 'InvalidOperationError';\n    return _this;\n  }\n\n  return InvalidOperationError;\n}(Error);\n\nexports.InvalidOperationError = InvalidOperationError;\n/**\nSwitch on `operation.op`, applying the corresponding patch function for each\ncase to `object`.\n*/\n\nfunction apply(object, operation) {\n  // not sure why TypeScript can't infer typesafety of:\n  //   {add, remove, replace, move, copy, test}[operation.op](object, operation)\n  // (seems like a bug)\n  switch (operation.op) {\n    case 'add':\n      return add(object, operation);\n\n    case 'remove':\n      return remove(object, operation);\n\n    case 'replace':\n      return replace(object, operation);\n\n    case 'move':\n      return move(object, operation);\n\n    case 'copy':\n      return copy(object, operation);\n\n    case 'test':\n      return test(object, operation);\n  }\n\n  return new InvalidOperationError(operation);\n}\n\nexports.apply = apply;","map":{"version":3,"sources":["/home/ascencion/sebrae_megahack/node_modules/rfc6902/patch.js"],"names":["__extends","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__","constructor","prototype","create","defineProperty","exports","value","pointer_1","require","util_1","equal_1","MissingError","_super","path","_this","call","name","Error","TestError","actual","expected","_add","object","key","isArray","push","index","parseInt","splice","_remove","add","operation","endpoint","Pointer","fromJSON","evaluate","parent","undefined","clone","remove","replace","length","move","from_endpoint","from","copy","test","result","compare","InvalidOperationError","op","apply"],"mappings":"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","sourcesContent":["\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar pointer_1 = require(\"./pointer\");\nvar util_1 = require(\"./util\");\nvar equal_1 = require(\"./equal\");\nvar MissingError = /** @class */ (function (_super) {\n    __extends(MissingError, _super);\n    function MissingError(path) {\n        var _this = _super.call(this, \"Value required at path: \" + path) || this;\n        _this.path = path;\n        _this.name = 'MissingError';\n        return _this;\n    }\n    return MissingError;\n}(Error));\nexports.MissingError = MissingError;\nvar TestError = /** @class */ (function (_super) {\n    __extends(TestError, _super);\n    function TestError(actual, expected) {\n        var _this = _super.call(this, \"Test failed: \" + actual + \" != \" + expected) || this;\n        _this.actual = actual;\n        _this.expected = expected;\n        _this.name = 'TestError';\n        _this.actual = actual;\n        _this.expected = expected;\n        return _this;\n    }\n    return TestError;\n}(Error));\nexports.TestError = TestError;\nfunction _add(object, key, value) {\n    if (Array.isArray(object)) {\n        // `key` must be an index\n        if (key == '-') {\n            object.push(value);\n        }\n        else {\n            var index = parseInt(key, 10);\n            object.splice(index, 0, value);\n        }\n    }\n    else {\n        object[key] = value;\n    }\n}\nfunction _remove(object, key) {\n    if (Array.isArray(object)) {\n        // '-' syntax doesn't make sense when removing\n        var index = parseInt(key, 10);\n        object.splice(index, 1);\n    }\n    else {\n        // not sure what the proper behavior is when path = ''\n        delete object[key];\n    }\n}\n/**\n>  o  If the target location specifies an array index, a new value is\n>     inserted into the array at the specified index.\n>  o  If the target location specifies an object member that does not\n>     already exist, a new member is added to the object.\n>  o  If the target location specifies an object member that does exist,\n>     that member's value is replaced.\n*/\nfunction add(object, operation) {\n    var endpoint = pointer_1.Pointer.fromJSON(operation.path).evaluate(object);\n    // it's not exactly a \"MissingError\" in the same way that `remove` is -- more like a MissingParent, or something\n    if (endpoint.parent === undefined) {\n        return new MissingError(operation.path);\n    }\n    _add(endpoint.parent, endpoint.key, util_1.clone(operation.value));\n    return null;\n}\nexports.add = add;\n/**\n> The \"remove\" operation removes the value at the target location.\n> The target location MUST exist for the operation to be successful.\n*/\nfunction remove(object, operation) {\n    // endpoint has parent, key, and value properties\n    var endpoint = pointer_1.Pointer.fromJSON(operation.path).evaluate(object);\n    if (endpoint.value === undefined) {\n        return new MissingError(operation.path);\n    }\n    // not sure what the proper behavior is when path = ''\n    _remove(endpoint.parent, endpoint.key);\n    return null;\n}\nexports.remove = remove;\n/**\n> The \"replace\" operation replaces the value at the target location\n> with a new value.  The operation object MUST contain a \"value\" member\n> whose content specifies the replacement value.\n> The target location MUST exist for the operation to be successful.\n\n> This operation is functionally identical to a \"remove\" operation for\n> a value, followed immediately by an \"add\" operation at the same\n> location with the replacement value.\n\nEven more simply, it's like the add operation with an existence check.\n*/\nfunction replace(object, operation) {\n    var endpoint = pointer_1.Pointer.fromJSON(operation.path).evaluate(object);\n    if (endpoint.parent === null) {\n        return new MissingError(operation.path);\n    }\n    // this existence check treats arrays as a special case\n    if (Array.isArray(endpoint.parent)) {\n        if (parseInt(endpoint.key, 10) >= endpoint.parent.length) {\n            return new MissingError(operation.path);\n        }\n    }\n    else if (endpoint.value === undefined) {\n        return new MissingError(operation.path);\n    }\n    endpoint.parent[endpoint.key] = operation.value;\n    return null;\n}\nexports.replace = replace;\n/**\n> The \"move\" operation removes the value at a specified location and\n> adds it to the target location.\n> The operation object MUST contain a \"from\" member, which is a string\n> containing a JSON Pointer value that references the location in the\n> target document to move the value from.\n> This operation is functionally identical to a \"remove\" operation on\n> the \"from\" location, followed immediately by an \"add\" operation at\n> the target location with the value that was just removed.\n\n> The \"from\" location MUST NOT be a proper prefix of the \"path\"\n> location; i.e., a location cannot be moved into one of its children.\n\nTODO: throw if the check described in the previous paragraph fails.\n*/\nfunction move(object, operation) {\n    var from_endpoint = pointer_1.Pointer.fromJSON(operation.from).evaluate(object);\n    if (from_endpoint.value === undefined) {\n        return new MissingError(operation.from);\n    }\n    var endpoint = pointer_1.Pointer.fromJSON(operation.path).evaluate(object);\n    if (endpoint.parent === undefined) {\n        return new MissingError(operation.path);\n    }\n    _remove(from_endpoint.parent, from_endpoint.key);\n    _add(endpoint.parent, endpoint.key, from_endpoint.value);\n    return null;\n}\nexports.move = move;\n/**\n> The \"copy\" operation copies the value at a specified location to the\n> target location.\n> The operation object MUST contain a \"from\" member, which is a string\n> containing a JSON Pointer value that references the location in the\n> target document to copy the value from.\n> The \"from\" location MUST exist for the operation to be successful.\n\n> This operation is functionally identical to an \"add\" operation at the\n> target location using the value specified in the \"from\" member.\n\nAlternatively, it's like 'move' without the 'remove'.\n*/\nfunction copy(object, operation) {\n    var from_endpoint = pointer_1.Pointer.fromJSON(operation.from).evaluate(object);\n    if (from_endpoint.value === undefined) {\n        return new MissingError(operation.from);\n    }\n    var endpoint = pointer_1.Pointer.fromJSON(operation.path).evaluate(object);\n    if (endpoint.parent === undefined) {\n        return new MissingError(operation.path);\n    }\n    _add(endpoint.parent, endpoint.key, util_1.clone(from_endpoint.value));\n    return null;\n}\nexports.copy = copy;\n/**\n> The \"test\" operation tests that a value at the target location is\n> equal to a specified value.\n> The operation object MUST contain a \"value\" member that conveys the\n> value to be compared to the target location's value.\n> The target location MUST be equal to the \"value\" value for the\n> operation to be considered successful.\n*/\nfunction test(object, operation) {\n    var endpoint = pointer_1.Pointer.fromJSON(operation.path).evaluate(object);\n    var result = equal_1.compare(endpoint.value, operation.value);\n    if (!result) {\n        return new TestError(endpoint.value, operation.value);\n    }\n    return null;\n}\nexports.test = test;\nvar InvalidOperationError = /** @class */ (function (_super) {\n    __extends(InvalidOperationError, _super);\n    function InvalidOperationError(operation) {\n        var _this = _super.call(this, \"Invalid operation: \" + operation.op) || this;\n        _this.operation = operation;\n        _this.name = 'InvalidOperationError';\n        return _this;\n    }\n    return InvalidOperationError;\n}(Error));\nexports.InvalidOperationError = InvalidOperationError;\n/**\nSwitch on `operation.op`, applying the corresponding patch function for each\ncase to `object`.\n*/\nfunction apply(object, operation) {\n    // not sure why TypeScript can't infer typesafety of:\n    //   {add, remove, replace, move, copy, test}[operation.op](object, operation)\n    // (seems like a bug)\n    switch (operation.op) {\n        case 'add': return add(object, operation);\n        case 'remove': return remove(object, operation);\n        case 'replace': return replace(object, operation);\n        case 'move': return move(object, operation);\n        case 'copy': return copy(object, operation);\n        case 'test': return test(object, operation);\n    }\n    return new InvalidOperationError(operation);\n}\nexports.apply = apply;\n"]},"metadata":{},"sourceType":"script"}