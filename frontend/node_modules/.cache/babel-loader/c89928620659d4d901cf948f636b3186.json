{"ast":null,"code":"'use strict';\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nfunction _toConsumableArray(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  } else {\n    return Array.from(arr);\n  }\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\nvar EventEmitter = require('events').EventEmitter;\n\nvar util = require('./util');\n/**\n * {@link StateMachine} represents a state machine. The state machine supports a\n * reentrant locking mechanism to allow asynchronous state transitions to ensure\n * they have not been preempted. Calls to {@link StateMachine#takeLock} are\n * guaranteed to be resolved in FIFO order.\n * @extends EventEmitter\n * @property {boolean} isLocked - whether or not the {@link StateMachine} is\n *   locked performing asynchronous state transition\n * @property {string} state - the current state\n * @emits {@link StateMachine#stateChanged}\n */\n\n\nvar StateMachine = function (_EventEmitter) {\n  _inherits(StateMachine, _EventEmitter);\n  /**\n   * Construct a {@link StateMachine}.\n   * @param {string} initialState - the intiial state\n   * @param {object} states\n   */\n\n\n  function StateMachine(initialState, states) {\n    _classCallCheck(this, StateMachine);\n\n    var _this = _possibleConstructorReturn(this, (StateMachine.__proto__ || Object.getPrototypeOf(StateMachine)).call(this));\n\n    var lock = null;\n    var state = initialState;\n    states = transformStates(states);\n    Object.defineProperties(_this, {\n      _lock: {\n        get: function get() {\n          return lock;\n        },\n        set: function set(_lock) {\n          lock = _lock;\n        }\n      },\n      _reachableStates: {\n        value: reachable(states)\n      },\n      _state: {\n        get: function get() {\n          return state;\n        },\n        set: function set(_state) {\n          state = _state;\n        }\n      },\n      _states: {\n        value: states\n      },\n      _whenDeferreds: {\n        value: new Set()\n      },\n      isLocked: {\n        enumerable: true,\n        get: function get() {\n          return lock !== null;\n        }\n      },\n      state: {\n        enumerable: true,\n        get: function get() {\n          return state;\n        }\n      }\n    });\n\n    _this.on('stateChanged', function (state) {\n      _this._whenDeferreds.forEach(function (deferred) {\n        deferred.when(state, deferred.resolve, deferred.reject);\n      });\n    });\n\n    return _this;\n  }\n  /**\n   * Returns a promise whose executor function is called on each state change.\n   * @param {function(state: string, resolve: function, reject: function): void} when\n   * @returns {Promise.<*>}\n   * @private\n   */\n\n\n  _createClass(StateMachine, [{\n    key: '_whenPromise',\n    value: function _whenPromise(when) {\n      var _this2 = this;\n\n      if (typeof when !== 'function') {\n        return Promise.reject(new Error('when() executor must be a function'));\n      }\n\n      var deferred = util.defer();\n      deferred.when = when;\n\n      this._whenDeferreds.add(deferred);\n\n      return deferred.promise.then(function (payload) {\n        _this2._whenDeferreds.delete(deferred);\n\n        return payload;\n      }, function (error) {\n        _this2._whenDeferreds.delete(deferred);\n\n        throw error;\n      });\n    }\n    /**\n     * This method takes a lock and passes the {@link StateMachine#Key} to your\n     * transition function. You may perform zero or more state transitions in your\n     * transition function, but you should check for preemption in each tick. You\n     * may also reenter the lock. Once the Promise returned by your transition\n     * function resolves or rejects, this method releases the lock it acquired for\n     * you.\n     * @param {string} name - a name for the lock\n     * @param {function(StateMachine#Key): Promise} transitionFunction\n     * @returns {Promise}\n     */\n    // NOTE(mroberts): This method is named after a Haskell function:\n    // https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Exception.html#v:bracket\n\n  }, {\n    key: 'bracket',\n    value: function bracket(name, transitionFunction) {\n      var key = void 0;\n      var self = this;\n\n      function releaseLock(error) {\n        if (self.hasLock(key)) {\n          self.releaseLockCompletely(key);\n        }\n\n        if (error) {\n          throw error;\n        }\n      }\n\n      return this.takeLock(name).then(function gotKey(_key) {\n        key = _key;\n        return transitionFunction(key);\n      }).then(function success(result) {\n        releaseLock();\n        return result;\n      }, releaseLock);\n    }\n    /**\n     * Check whether or not a {@link StateMachine#Key} matches the lock.\n     * @param {StateMachine#Key} key\n     * @returns {boolean}\n     */\n\n  }, {\n    key: 'hasLock',\n    value: function hasLock(key) {\n      return this._lock === key;\n    }\n    /**\n     * Preempt any pending state transitions and immediately transition to the new\n     * state. If a lock name is specified, take the lock and return the\n     * {@link StateMachine#Key}.\n     * @param {string} newState\n     * @param {?string} [name=null] - a name for the lock\n     * @param {Array<*>} [payload=[]]\n     * @returns {?StateMachine#Key}\n     */\n\n  }, {\n    key: 'preempt',\n    value: function preempt(newState, name, payload) {\n      // 1. Check that the new state is valid.\n      if (!isValidTransition(this._states, this.state, newState)) {\n        throw new Error('Cannot transition from \"' + this.state + '\" to \"' + newState + '\"');\n      } // 2. Release the old lock, if any.\n\n\n      var oldLock = void 0;\n\n      if (this.isLocked) {\n        oldLock = this._lock;\n        this._lock = null;\n      } // 3. Take the lock, if requested.\n\n\n      var key = null;\n\n      if (name) {\n        key = this.takeLockSync(name);\n      } // 4. If a lock wasn't requested, take a \"preemption\" lock in order to\n      // maintain FIFO order of those taking locks.\n\n\n      var preemptionKey = key ? null : this.takeLockSync('preemption'); // 5. Transition.\n\n      this.transition(newState, key || preemptionKey, payload); // 6. Preempt anyone blocked on the old lock.\n\n      if (oldLock) {\n        oldLock.resolve();\n      } // 7. Release the \"preemption\" lock, if we took it.\n\n\n      if (preemptionKey) {\n        this.releaseLock(preemptionKey);\n      }\n\n      return key;\n    }\n    /**\n     * Release a lock. This method succeeds only if the {@link StateMachine} is\n     * still locked and has not been preempted.\n     * @param {StateMachine#Key} key\n     * @throws Error\n     */\n\n  }, {\n    key: 'releaseLock',\n    value: function releaseLock(key) {\n      if (!this.isLocked) {\n        throw new Error('Could not release the lock for ' + key.name + ' because the StateMachine is not locked');\n      } else if (!this.hasLock(key)) {\n        throw new Error('Could not release the lock for ' + key.name + ' because ' + this._lock.name + ' has the lock');\n      }\n\n      if (key.depth === 0) {\n        this._lock = null;\n        key.resolve();\n      } else {\n        key.depth--;\n      }\n    }\n    /**\n     * Release a lock completely, even if it has been reentered. This method\n     * succeeds only if the {@link StateMachine} is still locked and has not been\n     * preempted.\n     * @param {StateMachine#Key} key\n     * @throws Error\n     */\n\n  }, {\n    key: 'releaseLockCompletely',\n    value: function releaseLockCompletely(key) {\n      if (!this.isLocked) {\n        throw new Error('Could not release the lock for ' + key.name + ' because the StateMachine is not locked');\n      } else if (!this.hasLock(key)) {\n        throw new Error('Could not release the lock for ' + key.name + ' because ' + this._lock.name + ' has the lock');\n      }\n\n      key.depth = 0;\n      this._lock = null;\n      key.resolve();\n    }\n    /**\n     * Take a lock, returning a Promise for the {@link StateMachine#Key}. You should\n     * take a lock anytime you intend to perform asynchronous transitions. Calls to\n     * this method are guaranteed to be resolved in FIFO order. You may reenter\n     * a lock by passing its {@link StateMachine#Key}.\n     * @param {string|StateMachine#Key} nameOrKey - a name for the lock or an\n     * existing {@link StateMachine#Key}\n     * @returns {Promise<object>}\n     */\n\n  }, {\n    key: 'takeLock',\n    value: function takeLock(nameOrKey) {\n      var _this3 = this; // Reentrant lock\n\n\n      if ((typeof nameOrKey === 'undefined' ? 'undefined' : _typeof(nameOrKey)) === 'object') {\n        var key = nameOrKey;\n        return new Promise(function (resolve) {\n          resolve(_this3.takeLockSync(key));\n        });\n      } // New lock\n\n\n      var name = nameOrKey;\n\n      if (this.isLocked) {\n        var takeLock = this.takeLock.bind(this, name);\n        return this._lock.promise.then(takeLock);\n      }\n\n      return Promise.resolve(this.takeLockSync(name));\n    }\n    /**\n     * Take a lock, returning the {@Link StateMachine#Key}. This method throws if\n     * the {@link StateMachine} is locked or the wrong {@link StateMachine#Key} is\n     * provided. You may reenter a lock by passing its {@link StateMachine#Key}.\n     * @param {string|StateMachine#Key} nameOrKey - a name for the lock or an\n     * existing {@link StateMachine#Key}\n     * @returns {object}\n     * @throws Error\n     */\n\n  }, {\n    key: 'takeLockSync',\n    value: function takeLockSync(nameOrKey) {\n      var key = typeof nameOrKey === 'string' ? null : nameOrKey;\n      var name = key ? key.name : nameOrKey;\n\n      if (key && !this.hasLock(key) || !key && this.isLocked) {\n        throw new Error('Could not take the lock for ' + name + ' because the lock for ' + this._lock.name + ' was not released');\n      } // Reentrant lock\n\n\n      if (key) {\n        key.depth++;\n        return key;\n      } // New lock\n\n\n      var lock = makeLock(name);\n      this._lock = lock;\n      return lock;\n    }\n    /**\n     * Transition to a new state. If the {@link StateMachine} is locked, you must\n     * provide the {@link StateMachine#Key}. An invalid state or the wrong\n     * {@link StateMachine#Key} will throw an error.\n     * @param {string} newState\n     * @param {?StateMachine#Key} [key=null]\n     * @param {Array<*>} [payload=[]]\n     * @throws {Error}\n     */\n\n  }, {\n    key: 'transition',\n    value: function transition(newState, key, payload) {\n      payload = payload || []; // 1. If we're locked, required the key.\n\n      if (this.isLocked) {\n        if (!key) {\n          throw new Error('You must provide the key in order to ' + 'transition');\n        } else if (!this.hasLock(key)) {\n          throw new Error('Could not transition using the key for ' + key.name + ' because ' + this._lock.name + ' has the lock');\n        }\n      } else if (key) {\n        throw new Error('Key provided for ' + key.name + ', but the StateMachine was not locked (possibly due to preemption)');\n      } // 2. Check that the new state is valid.\n\n\n      if (!isValidTransition(this._states, this.state, newState)) {\n        throw new Error('Cannot transition from \"' + this.state + '\" to \"' + newState + '\"');\n      } // 3. Update the state and emit an event.\n\n\n      this._state = newState;\n      this.emit.apply(this, _toConsumableArray(['stateChanged', newState].concat(payload)));\n    }\n    /**\n     * Attempt to transition to a new state. Unlike {@link StateMachine#transition},\n     * this method does not throw.\n     * @param {string} newState\n     * @param {?StateMachine#Key} [key=null]\n     * @param {Array<*>} [payload=[]]\n     * @returns {boolean}\n     */\n\n  }, {\n    key: 'tryTransition',\n    value: function tryTransition(newState, key, payload) {\n      try {\n        this.transition(newState, key, payload);\n      } catch (error) {\n        return false;\n      }\n\n      return true;\n    }\n    /**\n     * Return a Promise that resolves when the {@link StateMachine} transitions to\n     * the specified state. If the {@link StateMachine} transitions such that the\n     * requested state becomes unreachable, the Promise rejects.\n     * @param {string} state\n     * @returns {Promise<this>}\n     */\n\n  }, {\n    key: 'when',\n    value: function when(state) {\n      var _this4 = this;\n\n      if (this.state === state) {\n        return Promise.resolve(this);\n      } else if (!isValidTransition(this._reachableStates, this.state, state)) {\n        return Promise.reject(createUnreachableError(this.state, state));\n      }\n\n      return this._whenPromise(function (newState, resolve, reject) {\n        if (newState === state) {\n          resolve(_this4);\n        } else if (!isValidTransition(_this4._reachableStates, newState, state)) {\n          reject(createUnreachableError(newState, state));\n        }\n      });\n    }\n  }]);\n\n  return StateMachine;\n}(EventEmitter);\n/**\n * @event StateMachine#stateChanged\n * @param {string} newState\n */\n\n/**\n * Check if a transition is valid.\n * @private\n * @param {Map<*, Set<*>>} graph\n * @param {*} from\n * @param {*} to\n * @returns {boolean}\n */\n\n\nfunction isValidTransition(graph, from, to) {\n  return graph.get(from).has(to);\n}\n/**\n * @typedef {object} StateMachine#Key\n */\n\n\nfunction makeLock(name) {\n  var lock = util.defer();\n  lock.name = name;\n  lock.depth = 0;\n  return lock;\n}\n/**\n * Compute the transitive closure of a graph (i.e. what nodes are reachable from\n * where).\n * @private\n * @param {Map<*, Set<*>>} graph\n * @returns {Map<*, Set<*>>}\n */\n\n\nfunction reachable(graph) {\n  return Array.from(graph.keys()).reduce(function (newGraph, from) {\n    return newGraph.set(from, reachableFrom(graph, from));\n  }, new Map());\n}\n/**\n * Compute the Set of node reachable from a particular node in the graph.\n * @private\n * @param {Map<*, Set<*>>} graph\n * @param {*} from\n * @param {Set<*>} [to]\n * @returns {Set<*>}\n */\n\n\nfunction reachableFrom(graph, from, to) {\n  to = to || new Set();\n  graph.get(from).forEach(function (node) {\n    if (!to.has(node)) {\n      to.add(node);\n      reachableFrom(graph, node, to).forEach(to.add, to);\n    }\n  });\n  return to;\n}\n\nfunction transformStates(states) {\n  var newStates = new Map();\n\n  for (var key in states) {\n    newStates.set(key, new Set(states[key]));\n  }\n\n  return newStates;\n}\n/**\n * Create an \"unreachable state\" Error.\n * @param {string} here\n * @param {string} there\n * @returns {Error}\n */\n\n\nfunction createUnreachableError(here, there) {\n  return new Error('\"' + there + '\" cannot be reached from \"' + here + '\"');\n}\n\nmodule.exports = StateMachine;","map":{"version":3,"sources":["/home/ascencion/sebrae_megahack/node_modules/twilio-video/es5/statemachine.js"],"names":["_typeof","Symbol","iterator","obj","constructor","prototype","_createClass","defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","Constructor","protoProps","staticProps","_toConsumableArray","arr","Array","isArray","arr2","from","_classCallCheck","instance","TypeError","_possibleConstructorReturn","self","call","ReferenceError","_inherits","subClass","superClass","create","value","setPrototypeOf","__proto__","EventEmitter","require","util","StateMachine","_EventEmitter","initialState","states","_this","getPrototypeOf","lock","state","transformStates","_lock","get","set","_reachableStates","reachable","_state","_states","_whenDeferreds","Set","isLocked","on","forEach","deferred","when","resolve","reject","_whenPromise","_this2","Promise","Error","defer","add","promise","then","payload","delete","error","bracket","name","transitionFunction","releaseLock","hasLock","releaseLockCompletely","takeLock","gotKey","_key","success","result","preempt","newState","isValidTransition","oldLock","takeLockSync","preemptionKey","transition","depth","nameOrKey","_this3","bind","makeLock","emit","apply","concat","tryTransition","_this4","createUnreachableError","graph","to","has","keys","reduce","newGraph","reachableFrom","Map","node","newStates","here","there","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar EventEmitter = require('events').EventEmitter;\nvar util = require('./util');\n\n/**\n * {@link StateMachine} represents a state machine. The state machine supports a\n * reentrant locking mechanism to allow asynchronous state transitions to ensure\n * they have not been preempted. Calls to {@link StateMachine#takeLock} are\n * guaranteed to be resolved in FIFO order.\n * @extends EventEmitter\n * @property {boolean} isLocked - whether or not the {@link StateMachine} is\n *   locked performing asynchronous state transition\n * @property {string} state - the current state\n * @emits {@link StateMachine#stateChanged}\n */\n\nvar StateMachine = function (_EventEmitter) {\n  _inherits(StateMachine, _EventEmitter);\n\n  /**\n   * Construct a {@link StateMachine}.\n   * @param {string} initialState - the intiial state\n   * @param {object} states\n   */\n  function StateMachine(initialState, states) {\n    _classCallCheck(this, StateMachine);\n\n    var _this = _possibleConstructorReturn(this, (StateMachine.__proto__ || Object.getPrototypeOf(StateMachine)).call(this));\n\n    var lock = null;\n    var state = initialState;\n    states = transformStates(states);\n    Object.defineProperties(_this, {\n      _lock: {\n        get: function get() {\n          return lock;\n        },\n        set: function set(_lock) {\n          lock = _lock;\n        }\n      },\n      _reachableStates: {\n        value: reachable(states)\n      },\n      _state: {\n        get: function get() {\n          return state;\n        },\n        set: function set(_state) {\n          state = _state;\n        }\n      },\n      _states: {\n        value: states\n      },\n      _whenDeferreds: {\n        value: new Set()\n      },\n      isLocked: {\n        enumerable: true,\n        get: function get() {\n          return lock !== null;\n        }\n      },\n      state: {\n        enumerable: true,\n        get: function get() {\n          return state;\n        }\n      }\n    });\n\n    _this.on('stateChanged', function (state) {\n      _this._whenDeferreds.forEach(function (deferred) {\n        deferred.when(state, deferred.resolve, deferred.reject);\n      });\n    });\n    return _this;\n  }\n\n  /**\n   * Returns a promise whose executor function is called on each state change.\n   * @param {function(state: string, resolve: function, reject: function): void} when\n   * @returns {Promise.<*>}\n   * @private\n   */\n\n\n  _createClass(StateMachine, [{\n    key: '_whenPromise',\n    value: function _whenPromise(when) {\n      var _this2 = this;\n\n      if (typeof when !== 'function') {\n        return Promise.reject(new Error('when() executor must be a function'));\n      }\n\n      var deferred = util.defer();\n\n      deferred.when = when;\n      this._whenDeferreds.add(deferred);\n\n      return deferred.promise.then(function (payload) {\n        _this2._whenDeferreds.delete(deferred);\n        return payload;\n      }, function (error) {\n        _this2._whenDeferreds.delete(deferred);\n        throw error;\n      });\n    }\n\n    /**\n     * This method takes a lock and passes the {@link StateMachine#Key} to your\n     * transition function. You may perform zero or more state transitions in your\n     * transition function, but you should check for preemption in each tick. You\n     * may also reenter the lock. Once the Promise returned by your transition\n     * function resolves or rejects, this method releases the lock it acquired for\n     * you.\n     * @param {string} name - a name for the lock\n     * @param {function(StateMachine#Key): Promise} transitionFunction\n     * @returns {Promise}\n     */\n    // NOTE(mroberts): This method is named after a Haskell function:\n    // https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Exception.html#v:bracket\n\n  }, {\n    key: 'bracket',\n    value: function bracket(name, transitionFunction) {\n      var key = void 0;\n      var self = this;\n\n      function releaseLock(error) {\n        if (self.hasLock(key)) {\n          self.releaseLockCompletely(key);\n        }\n        if (error) {\n          throw error;\n        }\n      }\n\n      return this.takeLock(name).then(function gotKey(_key) {\n        key = _key;\n        return transitionFunction(key);\n      }).then(function success(result) {\n        releaseLock();\n        return result;\n      }, releaseLock);\n    }\n\n    /**\n     * Check whether or not a {@link StateMachine#Key} matches the lock.\n     * @param {StateMachine#Key} key\n     * @returns {boolean}\n     */\n\n  }, {\n    key: 'hasLock',\n    value: function hasLock(key) {\n      return this._lock === key;\n    }\n\n    /**\n     * Preempt any pending state transitions and immediately transition to the new\n     * state. If a lock name is specified, take the lock and return the\n     * {@link StateMachine#Key}.\n     * @param {string} newState\n     * @param {?string} [name=null] - a name for the lock\n     * @param {Array<*>} [payload=[]]\n     * @returns {?StateMachine#Key}\n     */\n\n  }, {\n    key: 'preempt',\n    value: function preempt(newState, name, payload) {\n      // 1. Check that the new state is valid.\n      if (!isValidTransition(this._states, this.state, newState)) {\n        throw new Error('Cannot transition from \"' + this.state + '\" to \"' + newState + '\"');\n      }\n\n      // 2. Release the old lock, if any.\n      var oldLock = void 0;\n      if (this.isLocked) {\n        oldLock = this._lock;\n        this._lock = null;\n      }\n\n      // 3. Take the lock, if requested.\n      var key = null;\n      if (name) {\n        key = this.takeLockSync(name);\n      }\n\n      // 4. If a lock wasn't requested, take a \"preemption\" lock in order to\n      // maintain FIFO order of those taking locks.\n      var preemptionKey = key ? null : this.takeLockSync('preemption');\n\n      // 5. Transition.\n      this.transition(newState, key || preemptionKey, payload);\n\n      // 6. Preempt anyone blocked on the old lock.\n      if (oldLock) {\n        oldLock.resolve();\n      }\n\n      // 7. Release the \"preemption\" lock, if we took it.\n      if (preemptionKey) {\n        this.releaseLock(preemptionKey);\n      }\n\n      return key;\n    }\n\n    /**\n     * Release a lock. This method succeeds only if the {@link StateMachine} is\n     * still locked and has not been preempted.\n     * @param {StateMachine#Key} key\n     * @throws Error\n     */\n\n  }, {\n    key: 'releaseLock',\n    value: function releaseLock(key) {\n      if (!this.isLocked) {\n        throw new Error('Could not release the lock for ' + key.name + ' because the StateMachine is not locked');\n      } else if (!this.hasLock(key)) {\n        throw new Error('Could not release the lock for ' + key.name + ' because ' + this._lock.name + ' has the lock');\n      }\n      if (key.depth === 0) {\n        this._lock = null;\n        key.resolve();\n      } else {\n        key.depth--;\n      }\n    }\n\n    /**\n     * Release a lock completely, even if it has been reentered. This method\n     * succeeds only if the {@link StateMachine} is still locked and has not been\n     * preempted.\n     * @param {StateMachine#Key} key\n     * @throws Error\n     */\n\n  }, {\n    key: 'releaseLockCompletely',\n    value: function releaseLockCompletely(key) {\n      if (!this.isLocked) {\n        throw new Error('Could not release the lock for ' + key.name + ' because the StateMachine is not locked');\n      } else if (!this.hasLock(key)) {\n        throw new Error('Could not release the lock for ' + key.name + ' because ' + this._lock.name + ' has the lock');\n      }\n      key.depth = 0;\n      this._lock = null;\n      key.resolve();\n    }\n\n    /**\n     * Take a lock, returning a Promise for the {@link StateMachine#Key}. You should\n     * take a lock anytime you intend to perform asynchronous transitions. Calls to\n     * this method are guaranteed to be resolved in FIFO order. You may reenter\n     * a lock by passing its {@link StateMachine#Key}.\n     * @param {string|StateMachine#Key} nameOrKey - a name for the lock or an\n     * existing {@link StateMachine#Key}\n     * @returns {Promise<object>}\n     */\n\n  }, {\n    key: 'takeLock',\n    value: function takeLock(nameOrKey) {\n      var _this3 = this;\n\n      // Reentrant lock\n      if ((typeof nameOrKey === 'undefined' ? 'undefined' : _typeof(nameOrKey)) === 'object') {\n        var key = nameOrKey;\n        return new Promise(function (resolve) {\n          resolve(_this3.takeLockSync(key));\n        });\n      }\n\n      // New lock\n      var name = nameOrKey;\n      if (this.isLocked) {\n        var takeLock = this.takeLock.bind(this, name);\n        return this._lock.promise.then(takeLock);\n      }\n      return Promise.resolve(this.takeLockSync(name));\n    }\n\n    /**\n     * Take a lock, returning the {@Link StateMachine#Key}. This method throws if\n     * the {@link StateMachine} is locked or the wrong {@link StateMachine#Key} is\n     * provided. You may reenter a lock by passing its {@link StateMachine#Key}.\n     * @param {string|StateMachine#Key} nameOrKey - a name for the lock or an\n     * existing {@link StateMachine#Key}\n     * @returns {object}\n     * @throws Error\n     */\n\n  }, {\n    key: 'takeLockSync',\n    value: function takeLockSync(nameOrKey) {\n      var key = typeof nameOrKey === 'string' ? null : nameOrKey;\n      var name = key ? key.name : nameOrKey;\n\n      if (key && !this.hasLock(key) || !key && this.isLocked) {\n        throw new Error('Could not take the lock for ' + name + ' because the lock for ' + this._lock.name + ' was not released');\n      }\n\n      // Reentrant lock\n      if (key) {\n        key.depth++;\n        return key;\n      }\n\n      // New lock\n      var lock = makeLock(name);\n      this._lock = lock;\n      return lock;\n    }\n\n    /**\n     * Transition to a new state. If the {@link StateMachine} is locked, you must\n     * provide the {@link StateMachine#Key}. An invalid state or the wrong\n     * {@link StateMachine#Key} will throw an error.\n     * @param {string} newState\n     * @param {?StateMachine#Key} [key=null]\n     * @param {Array<*>} [payload=[]]\n     * @throws {Error}\n     */\n\n  }, {\n    key: 'transition',\n    value: function transition(newState, key, payload) {\n      payload = payload || [];\n\n      // 1. If we're locked, required the key.\n      if (this.isLocked) {\n        if (!key) {\n          throw new Error('You must provide the key in order to ' + 'transition');\n        } else if (!this.hasLock(key)) {\n          throw new Error('Could not transition using the key for ' + key.name + ' because ' + this._lock.name + ' has the lock');\n        }\n      } else if (key) {\n        throw new Error('Key provided for ' + key.name + ', but the StateMachine was not locked (possibly due to preemption)');\n      }\n\n      // 2. Check that the new state is valid.\n      if (!isValidTransition(this._states, this.state, newState)) {\n        throw new Error('Cannot transition from \"' + this.state + '\" to \"' + newState + '\"');\n      }\n\n      // 3. Update the state and emit an event.\n      this._state = newState;\n      this.emit.apply(this, _toConsumableArray(['stateChanged', newState].concat(payload)));\n    }\n\n    /**\n     * Attempt to transition to a new state. Unlike {@link StateMachine#transition},\n     * this method does not throw.\n     * @param {string} newState\n     * @param {?StateMachine#Key} [key=null]\n     * @param {Array<*>} [payload=[]]\n     * @returns {boolean}\n     */\n\n  }, {\n    key: 'tryTransition',\n    value: function tryTransition(newState, key, payload) {\n      try {\n        this.transition(newState, key, payload);\n      } catch (error) {\n        return false;\n      }\n      return true;\n    }\n\n    /**\n     * Return a Promise that resolves when the {@link StateMachine} transitions to\n     * the specified state. If the {@link StateMachine} transitions such that the\n     * requested state becomes unreachable, the Promise rejects.\n     * @param {string} state\n     * @returns {Promise<this>}\n     */\n\n  }, {\n    key: 'when',\n    value: function when(state) {\n      var _this4 = this;\n\n      if (this.state === state) {\n        return Promise.resolve(this);\n      } else if (!isValidTransition(this._reachableStates, this.state, state)) {\n        return Promise.reject(createUnreachableError(this.state, state));\n      }\n      return this._whenPromise(function (newState, resolve, reject) {\n        if (newState === state) {\n          resolve(_this4);\n        } else if (!isValidTransition(_this4._reachableStates, newState, state)) {\n          reject(createUnreachableError(newState, state));\n        }\n      });\n    }\n  }]);\n\n  return StateMachine;\n}(EventEmitter);\n\n/**\n * @event StateMachine#stateChanged\n * @param {string} newState\n */\n\n/**\n * Check if a transition is valid.\n * @private\n * @param {Map<*, Set<*>>} graph\n * @param {*} from\n * @param {*} to\n * @returns {boolean}\n */\n\n\nfunction isValidTransition(graph, from, to) {\n  return graph.get(from).has(to);\n}\n\n/**\n * @typedef {object} StateMachine#Key\n */\n\nfunction makeLock(name) {\n  var lock = util.defer();\n  lock.name = name;\n  lock.depth = 0;\n  return lock;\n}\n\n/**\n * Compute the transitive closure of a graph (i.e. what nodes are reachable from\n * where).\n * @private\n * @param {Map<*, Set<*>>} graph\n * @returns {Map<*, Set<*>>}\n */\nfunction reachable(graph) {\n  return Array.from(graph.keys()).reduce(function (newGraph, from) {\n    return newGraph.set(from, reachableFrom(graph, from));\n  }, new Map());\n}\n\n/**\n * Compute the Set of node reachable from a particular node in the graph.\n * @private\n * @param {Map<*, Set<*>>} graph\n * @param {*} from\n * @param {Set<*>} [to]\n * @returns {Set<*>}\n */\nfunction reachableFrom(graph, from, to) {\n  to = to || new Set();\n  graph.get(from).forEach(function (node) {\n    if (!to.has(node)) {\n      to.add(node);\n      reachableFrom(graph, node, to).forEach(to.add, to);\n    }\n  });\n  return to;\n}\n\nfunction transformStates(states) {\n  var newStates = new Map();\n  for (var key in states) {\n    newStates.set(key, new Set(states[key]));\n  }\n  return newStates;\n}\n\n/**\n * Create an \"unreachable state\" Error.\n * @param {string} here\n * @param {string} there\n * @returns {Error}\n */\nfunction createUnreachableError(here, there) {\n  return new Error('\"' + there + '\" cannot be reached from \"' + here + '\"');\n}\n\nmodule.exports = StateMachine;"]},"metadata":{},"sourceType":"script"}