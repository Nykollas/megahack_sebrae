{"ast":null,"code":"var _jsxFileName = \"/home/ascencion/sebrae_megahack/src/state/index.tsx\";\nimport React, { createContext, useContext, useState } from 'react';\nimport useFirebaseAuth from './useFirebaseAuth/useFirebaseAuth';\nimport usePasscodeAuth from './usePasscodeAuth/usePasscodeAuth';\nexport const StateContext = createContext(null);\n/*\n  The 'react-hooks/rules-of-hooks' linting rules prevent React Hooks fron being called\n  inside of if() statements. This is because hooks must always be called in the same order\n  every time a component is rendered. The 'react-hooks/rules-of-hooks' rule is disabled below\n  because the \"if (process.env.REACT_APP_SET_AUTH === 'firebase')\" statements are evaluated\n  at build time (not runtime). If the statement evaluates to false, then the code is not\n  included in the bundle that is produced (due to tree-shaking). Thus, in this instance, it\n  is ok to call hooks inside if() statements.\n*/\n\nexport default function AppStateProvider(props) {\n  const [error, setError] = useState(null);\n  const [isFetching, setIsFetching] = useState(false);\n  let contextValue = {\n    error,\n    setError,\n    isFetching\n  };\n\n  if (process.env.REACT_APP_SET_AUTH === 'firebase') {\n    contextValue = { ...contextValue,\n      ...useFirebaseAuth() // eslint-disable-line react-hooks/rules-of-hooks\n\n    };\n  } else if (process.env.REACT_APP_SET_AUTH === 'passcode') {\n    contextValue = { ...contextValue,\n      ...usePasscodeAuth() // eslint-disable-line react-hooks/rules-of-hooks\n\n    };\n  } else {\n    contextValue = { ...contextValue,\n      getToken: async (identity, roomName) => {\n        const headers = new window.Headers();\n        const endpoint = process.env.REACT_APP_TOKEN_ENDPOINT || '/token';\n        const params = new window.URLSearchParams({\n          identity,\n          roomName\n        });\n        console.log(`${endpoint}?${params}`);\n        return fetch(`${endpoint}?${params}`, {\n          headers\n        }).then(res => res.text());\n      }\n    };\n  }\n\n  const getToken = (name, room) => {\n    setIsFetching(true);\n    return contextValue.getToken(name, room).then(res => {\n      setIsFetching(false);\n      return res;\n    }).catch(err => {\n      setError(err);\n      setIsFetching(false);\n      return Promise.reject(err);\n    });\n  };\n\n  return /*#__PURE__*/React.createElement(StateContext.Provider, {\n    value: { ...contextValue,\n      getToken\n    },\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 77,\n      columnNumber: 10\n    }\n  }, props.children);\n}\nexport function useAppState() {\n  const context = useContext(StateContext);\n\n  if (!context) {\n    throw new Error('useAppState must be used within the AppStateProvider');\n  }\n\n  return context;\n}","map":{"version":3,"sources":["/home/ascencion/sebrae_megahack/src/state/index.tsx"],"names":["React","createContext","useContext","useState","useFirebaseAuth","usePasscodeAuth","StateContext","AppStateProvider","props","error","setError","isFetching","setIsFetching","contextValue","process","env","REACT_APP_SET_AUTH","getToken","identity","roomName","headers","window","Headers","endpoint","REACT_APP_TOKEN_ENDPOINT","params","URLSearchParams","console","log","fetch","then","res","text","name","room","catch","err","Promise","reject","children","useAppState","context","Error"],"mappings":";AAAA,OAAOA,KAAP,IAAgBC,aAAhB,EAA+BC,UAA/B,EAA2CC,QAA3C,QAA2D,OAA3D;AAEA,OAAOC,eAAP,MAA4B,mCAA5B;AACA,OAAOC,eAAP,MAA4B,mCAA5B;AAcA,OAAO,MAAMC,YAAY,GAAGL,aAAa,CAAmB,IAAnB,CAAlC;AAEP;;;;;;;;;;AASA,eAAe,SAASM,gBAAT,CAA0BC,KAA1B,EAA8D;AAC3E,QAAM,CAACC,KAAD,EAAQC,QAAR,IAAoBP,QAAQ,CAAqB,IAArB,CAAlC;AACA,QAAM,CAACQ,UAAD,EAAaC,aAAb,IAA8BT,QAAQ,CAAC,KAAD,CAA5C;AAEA,MAAIU,YAAY,GAAG;AACjBJ,IAAAA,KADiB;AAEjBC,IAAAA,QAFiB;AAGjBC,IAAAA;AAHiB,GAAnB;;AAMA,MAAIG,OAAO,CAACC,GAAR,CAAYC,kBAAZ,KAAmC,UAAvC,EAAmD;AACjDH,IAAAA,YAAY,GAAG,EACb,GAAGA,YADU;AAEb,SAAGT,eAAe,EAFL,CAES;;AAFT,KAAf;AAID,GALD,MAKO,IAAIU,OAAO,CAACC,GAAR,CAAYC,kBAAZ,KAAmC,UAAvC,EAAmD;AACxDH,IAAAA,YAAY,GAAG,EACb,GAAGA,YADU;AAEb,SAAGR,eAAe,EAFL,CAES;;AAFT,KAAf;AAID,GALM,MAKA;AACLQ,IAAAA,YAAY,GAAG,EACb,GAAGA,YADU;AAEbI,MAAAA,QAAQ,EAAE,OAAOC,QAAP,EAAiBC,QAAjB,KAA8B;AACtC,cAAMC,OAAO,GAAG,IAAIC,MAAM,CAACC,OAAX,EAAhB;AACA,cAAMC,QAAQ,GAAGT,OAAO,CAACC,GAAR,CAAYS,wBAAZ,IAAwC,QAAzD;AACA,cAAMC,MAAM,GAAG,IAAIJ,MAAM,CAACK,eAAX,CAA2B;AAAER,UAAAA,QAAF;AAAYC,UAAAA;AAAZ,SAA3B,CAAf;AACAQ,QAAAA,OAAO,CAACC,GAAR,CAAa,GAAEL,QAAS,IAAGE,MAAO,EAAlC;AACA,eAAOI,KAAK,CAAE,GAAEN,QAAS,IAAGE,MAAO,EAAvB,EAA0B;AAAEL,UAAAA;AAAF,SAA1B,CAAL,CAA4CU,IAA5C,CAAiDC,GAAG,IAAIA,GAAG,CAACC,IAAJ,EAAxD,CAAP;AACD;AARY,KAAf;AAUD;;AAED,QAAMf,QAAsC,GAAG,CAACgB,IAAD,EAAOC,IAAP,KAAgB;AAC7DtB,IAAAA,aAAa,CAAC,IAAD,CAAb;AACA,WAAOC,YAAY,CAChBI,QADI,CACKgB,IADL,EACWC,IADX,EAEJJ,IAFI,CAECC,GAAG,IAAI;AACXnB,MAAAA,aAAa,CAAC,KAAD,CAAb;AACA,aAAOmB,GAAP;AACD,KALI,EAMJI,KANI,CAMEC,GAAG,IAAI;AACZ1B,MAAAA,QAAQ,CAAC0B,GAAD,CAAR;AACAxB,MAAAA,aAAa,CAAC,KAAD,CAAb;AACA,aAAOyB,OAAO,CAACC,MAAR,CAAeF,GAAf,CAAP;AACD,KAVI,CAAP;AAWD,GAbD;;AAeA,sBAAO,oBAAC,YAAD,CAAc,QAAd;AAAuB,IAAA,KAAK,EAAE,EAAE,GAAGvB,YAAL;AAAmBI,MAAAA;AAAnB,KAA9B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,KAA8DT,KAAK,CAAC+B,QAApE,CAAP;AACD;AAED,OAAO,SAASC,WAAT,GAAuB;AAC5B,QAAMC,OAAO,GAAGvC,UAAU,CAACI,YAAD,CAA1B;;AACA,MAAI,CAACmC,OAAL,EAAc;AACZ,UAAM,IAAIC,KAAJ,CAAU,sDAAV,CAAN;AACD;;AACD,SAAOD,OAAP;AACD","sourcesContent":["import React, { createContext, useContext, useState } from 'react';\nimport { TwilioError } from 'twilio-video';\nimport useFirebaseAuth from './useFirebaseAuth/useFirebaseAuth';\nimport usePasscodeAuth from './usePasscodeAuth/usePasscodeAuth';\nimport { User } from 'firebase';\n\nexport interface StateContextType {\n  error: TwilioError | null;\n  setError(error: TwilioError | null): void;\n  getToken(name: string, room: string, passcode?: string): Promise<string>;\n  user?: User | null | { displayName: undefined; photoURL: undefined; passcode?: string };\n  signIn?(passcode?: string): Promise<void>;\n  signOut?(): Promise<void>;\n  isAuthReady?: boolean;\n  isFetching: boolean;\n}\n\nexport const StateContext = createContext<StateContextType>(null!);\n\n/*\n  The 'react-hooks/rules-of-hooks' linting rules prevent React Hooks fron being called\n  inside of if() statements. This is because hooks must always be called in the same order\n  every time a component is rendered. The 'react-hooks/rules-of-hooks' rule is disabled below\n  because the \"if (process.env.REACT_APP_SET_AUTH === 'firebase')\" statements are evaluated\n  at build time (not runtime). If the statement evaluates to false, then the code is not\n  included in the bundle that is produced (due to tree-shaking). Thus, in this instance, it\n  is ok to call hooks inside if() statements.\n*/\nexport default function AppStateProvider(props: React.PropsWithChildren<{}>) {\n  const [error, setError] = useState<TwilioError | null>(null);\n  const [isFetching, setIsFetching] = useState(false);\n\n  let contextValue = {\n    error,\n    setError,\n    isFetching,\n  } as StateContextType;\n\n  if (process.env.REACT_APP_SET_AUTH === 'firebase') {\n    contextValue = {\n      ...contextValue,\n      ...useFirebaseAuth(), // eslint-disable-line react-hooks/rules-of-hooks\n    };\n  } else if (process.env.REACT_APP_SET_AUTH === 'passcode') {\n    contextValue = {\n      ...contextValue,\n      ...usePasscodeAuth(), // eslint-disable-line react-hooks/rules-of-hooks\n    };\n  } else {\n    contextValue = {\n      ...contextValue,\n      getToken: async (identity, roomName) => {\n        const headers = new window.Headers();\n        const endpoint = process.env.REACT_APP_TOKEN_ENDPOINT || '/token';\n        const params = new window.URLSearchParams({ identity, roomName });\n        console.log(`${endpoint}?${params}`);\n        return fetch(`${endpoint}?${params}`, { headers }).then(res => res.text());\n      },\n    };\n  }\n\n  const getToken: StateContextType['getToken'] = (name, room) => {\n    setIsFetching(true);\n    return contextValue\n      .getToken(name, room)\n      .then(res => {\n        setIsFetching(false);\n        return res;\n      })\n      .catch(err => {\n        setError(err);\n        setIsFetching(false);\n        return Promise.reject(err);\n      });\n  };\n\n  return <StateContext.Provider value={{ ...contextValue, getToken }}>{props.children}</StateContext.Provider>;\n}\n\nexport function useAppState() {\n  const context = useContext(StateContext);\n  if (!context) {\n    throw new Error('useAppState must be used within the AppStateProvider');\n  }\n  return context;\n}\n"]},"metadata":{},"sourceType":"module"}